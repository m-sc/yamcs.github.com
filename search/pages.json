[{"title":"APT Repository","url":"/downloads/APT_Repository/","body":"APT (Debian, Ubuntu) Packages suitable for x86_64 are available via an APT repository. The repository and key can be installed with the following script: wget -q -O - https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://nexus.spaceapplications.com/repository/yamcs/apt stable main\" &gt; /etc/apt/sources.list.d/yamcs.list' "},{"title":"Actions","url":"/docs/studio/Actions/","body":"Widgets have an Actions property which is used to trigger actions upon user interaction. The common case is to associate Actions with Control Widgets, but in principle it can be made to work with other widgets as well. The list of available actions currently includes: Open OPI Often used in combination with Action Buttons to organize displays hierarchically. Indicate the workspace path to the OPI with File Path. Use the Mode to select whether the OPI should by default open in the same tab. Note that the runtime user can override this default behaviour by right-clicking the button. Write PV Writes the specified value to a PV. The variable $(pv_name) is automatically substituted with the PV attached to the widget. Execute Command This executes a command on your operating system. It does not execute a telecommand (although we will probably add such a feature too) Execute JavaScript Execute a JavaScript. Link to a script file in your workspace, or alternatively embed it into the Action Execute Python Script Execute some Python script. Link to a script file in your workspace, or alternatively embed it into the Action Play WAV File Plays the specified sound file Open File Opens a workspace file with the default handler Open Webpage Open the specified web page with the integrated web browser "},{"title":"Alarm Notices","url":"/docs/http/Alarm_Notices/","body":"Subscribe to alarm notices: [ 1, 1, :seq, { \"alarms\": \"subscribe\" } ] Response You first get an empty reply message confirming the positive receipt of your request: [ 1, 2, 789 ] Further messages will be marked as type ALARM_DATA. Directly after you subscribe, you will receive get the active set of alarms – if applicable. [1,4,0,{\"dt\":\"ALARM_DATA\",\"data\":{\"id\":0,\"type\":1,\"triggerValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":227},\"engValue\":{\"type\":2,\"uint32Value\":227},\"acquisitionTime\":1440576556724,\"generationTime\":1440576539714,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:08:40.724Z\",\"generationTimeUTC\":\"2015-08-26T08:08:23.714Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576558224,\"expirationTimeUTC\":\"2015-08-26T08:08:42.224Z\"},\"mostSevereValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":227},\"engValue\":{\"type\":2,\"uint32Value\":227},\"acquisitionTime\":1440576556724,\"generationTime\":1440576539714,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:08:40.724Z\",\"generationTimeUTC\":\"2015-08-26T08:08:23.714Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576558224,\"expirationTimeUTC\":\"2015-08-26T08:08:42.224Z\"},\"currentValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":258},\"engValue\":{\"type\":2,\"uint32Value\":258},\"acquisitionTime\":1440576955780,\"generationTime\":1440576938777,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:15:19.780Z\",\"generationTimeUTC\":\"2015-08-26T08:15:02.777Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576957280,\"expirationTimeUTC\":\"2015-08-26T08:15:21.280Z\"},\"violations\":65}}] [1,4,1,{\"dt\":\"ALARM_DATA\",\"data\":{\"id\":0,\"type\":4,\"triggerValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":227},\"engValue\":{\"type\":2,\"uint32Value\":227},\"acquisitionTime\":1440576556724,\"generationTime\":1440576539714,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:08:40.724Z\",\"generationTimeUTC\":\"2015-08-26T08:08:23.714Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576558224,\"expirationTimeUTC\":\"2015-08-26T08:08:42.224Z\"},\"mostSevereValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":227},\"engValue\":{\"type\":2,\"uint32Value\":227},\"acquisitionTime\":1440576556724,\"generationTime\":1440576539714,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:08:40.724Z\",\"generationTimeUTC\":\"2015-08-26T08:08:23.714Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576558224,\"expirationTimeUTC\":\"2015-08-26T08:08:42.224Z\"},\"currentValue\":{\"id\":{\"name\":\"/YSS/SIMULATOR/O2TankTemp\"},\"rawValue\":{\"type\":2,\"uint32Value\":280},\"engValue\":{\"type\":2,\"uint32Value\":280},\"acquisitionTime\":1440576962013,\"generationTime\":1440576945011,\"acquisitionStatus\":0,\"processingStatus\":true,\"monitoringResult\":21,\"acquisitionTimeUTC\":\"2015-08-26T08:15:26.013Z\",\"generationTimeUTC\":\"2015-08-26T08:15:09.011Z\",\"watchLow\":10.0,\"watchHigh\":12.0,\"warningLow\":30.0,\"warningHigh\":32.0,\"distressLow\":40.0,\"distressHigh\":42.0,\"criticalLow\":60.0,\"criticalHigh\":62.0,\"severeLow\":80.0,\"severeHigh\":82.0,\"expirationTime\":1440576963513,\"expirationTimeUTC\":\"2015-08-26T08:15:27.513Z\"},\"violations\":66}}] Notice how we are first getting an alarm of type ACTIVE that triggered somewhere before we connected, and only then a further update on that alarm of type PVAL_UPDATED. Unsubscribe Unsubscribe from all further alarm updates: [ 1, 1, 790, { \"alarms\": \"unsubscribe\" } ] This will be confirmed with an empty reply message: [ 1, 2, 790 ] "},{"title":"Alarm Recorder","url":"/docs/server/Alarm_Recorder/","body":"Records alarms. This service stores the data coming from one or more streams into a table alarms. Class Name org.yamcs.archive.AlarmRecorder Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.AlarmRecorder streamConfig: alarm: - alarms_realtime With this configuration alarms emitted to the alarms_realtime stream are stored into the table alarms. "},{"title":"Alarm Reporter","url":"/docs/server/Alarm_Reporter/","body":"Generates events for changes in the alarm state of any parameter on the specific processor. Note that this is independent from the actual alarm checking. Class Name org.yamcs.alarms.AlarmReporter Configuration This service is defined in etc/processor.yaml. Example from a typical deployment: processor.yaml realtime: services: - class: org.yamcs.alarms.AlarmReporter Configuration Options Name Type Description source string The source name of the generated events. Default: AlarmChecker "},{"title":"Alarms","url":"/docs/server/Alarms/","body":"Yamcs supports the XTCE notion of alarms. Based on the value of a parameter, Yamcs assigns a monitoring result to each parameter. The default monitoring result is DISABLED. For enumerated parameters, the monitoring result can be: null (no alarm states are defined for this parameter) DISABLED (no alarms are applicable given the current set of updated parameter values) IN_LIMITS (an alarm was checked, but the value is within limits) WATCH WARNING DISTRESS CRITICAL SEVERE For numeric parameters, the monitoring result can be: null (no alarm ranges are defined for this parameter) DISABLED (no alarms are applicable given the current set of updated parameter values) IN_LIMITS (an alarm was checked, but the value is within limits) WATCH WARNING DISTRESS CRITICAL SEVERE Numeric parameter values get also tagged with a range condition LOW or HIGH, indicating whether the parameter value is too low or too high. As part of the MDB definition, the user can define for each parameter on which conditions the monitoring result should be set to a certain value. If the alarm conditions for multiple severity levels match, the highest severity level will always win. For each parameter, multiple different sets of alarm conditions can be defined. A context condition is used to determine which set is applicable (for example, apply a different set of alarms if some other parameter is set to ‘CONTINGENCY MODE’). "},{"title":"Alarms","url":"/docs/studio/Alarms/","body":"This view is under development, and will offer a centralised view of all active alarms, with the opportunity to acknowledge alarms or to mute any sounds. The Alarms view is not yet bundled in current copies of Yamcs Studio, but will be so in the short term. Currently the only way to be noticed of alarms in Yamcs Studio is by following events (if your Yamcs Server is configured to report alarm state changes as events), or by manually iterating your displays to look for widgets that have red (= major alarm) or orange (= minor alarm) colored borders around them. The upcoming Alarms view aims to improve this process. "},{"title":"Alarms","url":"/docs/http/Alarms/","body":" "},{"title":"Algorithm Manager","url":"/docs/server/Algorithm_Manager/","body":"Executes algorithms and provides output parameters. Class Name org.yamcs.algorithms.AlgorithmManager Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.algorithms.AlgorithmManager args: libraries: JavaScript: - \"mdb/mylib.js\" Configuration Options Name Type Description libraries map Libraries to be included in algorithms. The map points from the scripting language to a list of file paths. "},{"title":"Algorithms","url":"/docs/server/Algorithms/","body":"Yamcs supports the XTCE notion of algorithms. Algorithms are user scripts that can perform arbitrary logic on a set of incoming parameters. The result is typically one or more derived parameters, called output parameters, that are delivered together with the original set of parameters (at least, if they have been subscribed to). Output parameters are very much identical to regular parameters. They can be calibrated (in which case the algorithm’s direct outcome is considered the raw value), and they can also be subject to alarm generation. Algorithms can be written in any JSR-223 scripting language. The preferred language is specified in the instance configuration file, and applies to all algorithms within that instance. By default Yamcs ships with support for JavaScript algorithms since the standard Oracle Java distribution contains the Nashorn JavaScript engine. Support for other languages (e.g. Python) requires installing additional dependencies. Yamcs will bind these input parameters in the script’s execution context, so that they can be accessed from within there. In particular the following attributes are made available: value: the engineering value rawValue: the raw value (if the parameter has a raw value) monitoringResult: the result of the monitoring: null, DISABLED, WATCH, WARNING, DISTRESS, CRITICAL or SEVERE. rangeCondition: LOW or HIGH. If there was no update for a certain parameter, yet the algorithm is still being executed, the previous value of that parameter will be retained. Triggers Algorithms can trigger on two conditions: Whenever a specified parameter is updated Periodically (expressed in milliseconds) Multiple triggers can be combined. In the typical example, an algorithm will trigger on updates for each of its input parameters. In other cases (for example because the algorithm doesn’t have any inputs), it may be necessary to trigger on some other parameter. Or maybe a piece of logic just needs to be run at regular time intervals, rather than with each parameter update. If an algorithm was triggered and not all of its input parameters were set, these parameters will be defined in the algorithm’s scope, but with their value set to null. User Libraries The Yamcs algorithm engine can be configured to import a number of user libraries. Just like with algorithms, these libraries can contain any sort of logic and are written in the same scripting language. Yamcs will load user libraries one time only at start-up in their defined order. This will happen before running any algorithm. Anything that was defined in the user library, will be accessible by any algorithm. In other words, user libraries define a kind-of global scope. Common use cases for libraries are: sharing functions between algorithms, shortening user algorithms, easier outside testing of algorithm logic, … Being able to split the code in different user libraries is merely a user convenience. For all Yamcs cares, they could all be merged together in one big file. Algorithm Scope User algorithms themselves have each their own scope. This scope is safe with regards to other algorithms (i.e. variables defined in algorithm a will not leak to algorithm b. An algorithm’s scope, however, will be shared across multiple algorithm runs. This feature allows you to keep variables inside internal memory if needed. Do take caution with initializing your variables correctly at the beginning of your algorithm if you only update them under a certain set of conditions (unless of course you intend them to keep their value across runs). Sharing State If some kind of a shared state is required between multiple algorithms, the user libraries’ shared scope could be (ab)used for this. In many cases, the better solution would be to just output a parameter from one algorithm, and input it into another. Yamcs will automatically detect such dependencies, and will execute algorithms in the correct order. Historic Values With what has been described so far, it would already be possible to store values in an algorithm’s scope and perform windowing operations, such as averages. Yamcs goes a step further by allowing you to input a particular instance of a parameter. By default instance 0 is inputted, which means the parameter’s actual value. But you could also define instance -1 for inputting the parameter’s value as it was on the previous parameter update. If you define input parameters for, say, each of the instances -4, -3, -2, -1 and 0, your user algorithm could be just a simple oneliner, since Yamcs is taking care of the administration. Algorithms with windowed parameters will only trigger as soon as each of these parameters have all instances defined (i.e. when the windows are full). "},{"title":"Archive","url":"/docs/server/Archive/","body":"The Yamcs archive is divided in two parts: Stream Archive stores time ordered tuples (t, v1, v2…vn) where t is the time and v1, v2, vn are values of various types. This is used for storing raw telemetry packets, commands, events, alarms and processed parameters. The stream archive can be seen as a row-oriented archive and is optimized for accessing entire records (e.g. a packet or a group of processed parameters). Parameter Archive stores time ordered parameter values. The parameter archive is column oriented archive and it is optimized for accessing a (relatively small) number of parameters over longer periods of time. Data is stored in the Stream Archive as soon as it is being received, whereas the Parmeter Archive involves some data transformation and it is filled in batches. However, for an external user, Yamcs should make the filling process invisible so data from both archives can be retrieved (almost) as soon as it been received by Yamcs. "},{"title":"Archive","url":"/docs/studio/Archive/","body":"The Archive view represents a visual view of the data stored in the Yamcs archive. Through this view we can also initialize and control replays of archived telemetry. User Interface Choosing a Data Range Selecting Data Navigating Replaying data User Interface The Archive view always works on a range of indexed data, which it fetches from the server. All further actions like zooming happen client-side on the loaded data range. Choosing a Data Range As a first step you should select your data range. Click the pull-down icon to bring up this menu: You can choose one of the predefined half-open time intervals, or you can select Custom… to specify your preferred range. Ranges can be half-open, which means they will always grow to include more bordering data as it becomes available. If you choose for example Last Day, Yamcs Studio will fetch an index of the archive for that time period, and refresh your view. Your chosen data range is stored in your user preferences and will be restored the next time you open Yamcs Studio. Selecting Data If this is the first time you have opened Yamcs Studio on your workstation, you won’t see anything other than some empty zones named: Completeness Index APID TM Histogram PP Histogram CMDHIST Histogram You need to choose which index data you actually want to display in your view. If there is data available for a zone, you can right-click it to bring up a pop-up menu where you select Add Packets &gt; … &gt; All Packets. Your view will then update to show the selected packets. We say packets since this is typically what we are interested in when browsing the Archive, but any recorded data can in reality be displayed through the Archive view. Note that the view does not refresh itself, so hit Refresh whenever you want to load the latest data for your selected time range. Navigating The vertical red locator shows the current time as provided by Yamcs. When we hover the mouse over the view, a greyed-out locator indicates the current mouse position. It is also possible to Zoom In or Zoom Out . If you are interested in a specific range, select a time range by clicking and dragging your mouse over the range before you zoom in using the zoom in button. Notice that as you are zooming in and out, a horizontal scroll bar appears. This allows you to scroll left and right within the initially load time range. To clear your zoom stack, select Clear Zoom . Replaying data We can use this view to replay archived data. Click Replay . In the dialog box, confirm or filter the suggested selection of data. Currently only telemetry packets and processed parameters that were made visible in the Archive are part of the selectable data. Modify Start At to the time and date you want to start the replay from. Yamcs will create a processor (next to the built-in realtime processor) with the name that you provide in the Name field. The exact name that you choose is of no importance (although it needs to be unique), it helps you to identify the processor. Click OK to start the replay. Yamcs Studio will reset any operator displays you may have opened, and will automatically switch to the newly created replay processor, as visible in the processor indicator in the top-left of your window. Notice also that the Archive view is now equipped with an additional control bar. The red locator shows you the current time of the replay processing. Double click anywhere to the left or to the right to make the processing jump to another point in time. Click Pause to pause the processing, and use Forward to increase the speed of the processing. This button currently cycles through 5 predefined speed steps. Original Speed 2x Original Speed 4x Original Speed 8x Original Speed 16x Original Speed Speeding up will not cause any reset of your displays, as the same data is arriving, just faster. When you want to leave the replay, there are several possibilities to follow: Hit Return to Realtime ; Open the pull-down menu ▼ next to the Replay button to choose a different processor; Click on the processor info bar in the top left of the window, to choose a different processor. "},{"title":"Artemis Command History Publisher","url":"/docs/server/Artemis_Command_History_Publisher/","body":"Publish cmdhist stream data to an Artemis broker. Class Name org.yamcs.artemis.ArtemisCmdHistoryService Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.artemis.ArtemisCmdHistoryService args: [cmdhist_realtime, cmdhist_dump] args must be a an array of strings indicating which streams to publish. For each stream the target address is composed as instance.stream. In the example tuples from the streams cmdhist_realtime and cmdhist_dump are published to the addresses simulator.cmdhist_realtime and simulator.cmdhist_dump respectively. By default, messages are published to an embedded broker (in-VM). This assumes that Artemis Server was configured as a global service. In order to use an external broker you can configure the property artemisUrl in either etc/yamcs.(instance).yaml or etc/yamcs.yaml: yamcs.simulator.yaml artemisUrl: tcp://remote-host1:5445 yamcs.yaml artemisUrl: tcp://remote-host1:5445 If defined, the instance-specific configuration is selected over the global configuration. The URL format follows Artemis conventions and is not further detailed in this manual. "},{"title":"Artemis Event Publisher","url":"/docs/server/Artemis_Event_Publisher/","body":"Publish event stream data to an Artemis broker. Class Name org.yamcs.artemis.ArtemisEventService Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.artemis.ArtemisEventService args: [events_realtime, events_dump] args must be a an array of strings indicating which streams to publish. For each stream the target address is composed as instance.stream. In the example tuples from the streams events_realtime and events_dump are published to the addresses simulator.events_realtime and simulator.events_dump respectively. By default, messages are published to an embedded broker (in-VM). This assumes that Artemis Server was configured as a global service. In order to use an external broker you can configure the property artemisUrl in either etc/yamcs.(instance).yaml or etc/yamcs.yaml: yamcs.simulator.yaml artemisUrl: tcp://remote-host1:5445 yamcs.yaml artemisUrl: tcp://remote-host1:5445 If defined, the instance-specific configuration is selected over the global configuration. The URL format follows Artemis conventions and is not further detailed in this manual. "},{"title":"Artemis Parameter Data Link","url":"/docs/server/Artemis_Parameter_Data_Link/","body":"Reads param data from an Artemis queue and publishes it to the configured stream. Class Name org.yamcs.tctm.ArtemisParameterDataLink Configuration Options Name Type Description stream string Required. The stream where data is emitted address string Artemis address to bind to. "},{"title":"Artemis Parameter Publisher","url":"/docs/server/Artemis_Parameter_Publisher/","body":"Publish param stream data to an Artemis broker. Class Name org.yamcs.artemis.ArtemisPpService Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.artemis.ArtemisPpService args: [pp_realtime, pp_dump, sys_param] args must be a an array of strings indicating which streams to publish. For each stream the target address is composed as instance.stream. In the example tuples from the streams pp_realtime, pp_dump and pp_dump are published to the addresses simulator.pp_realtime, simulator.pp_dump and simulator.pp_sys_param respectively. By default, messages are published to an embedded broker (in-VM). This assumes that Artemis Server was configured as a global service. In order to use an external broker you can configure the property artemisUrl in either etc/yamcs.(instance).yaml or etc/yamcs.yaml: yamcs.simulator.yaml artemisUrl: tcp://remote-host1:5445 yamcs.yaml artemisUrl: tcp://remote-host1:5445 If defined, the instance-specific configuration is selected over the global configuration. The URL format follows Artemis conventions and is not further detailed in this manual. "},{"title":"Artemis Server","url":"/docs/server/Artemis_Server/","body":"Initializes and starts an embedded instance of the Artemis messaging server. This can be used to connect streams across Yamcs installations. Class Name org.yamcs.artemis.ArtemisServer Configuration This is a global service defined in etc/yamcs.yaml. Example from a typical deployment: yamcs.yaml services: - class: org.yamcs.artemis.ArtemisServer Configuration Options Name Type Description configFile string Filename of the XML configuration file that contains further configuration options. Do not use an absolute path. The file must exist in the /opt/yamcs/etc folder. Default: artemis.xml. securityManager string Class name of a org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager implementation. The implementation should have a no-arg constructor. If unspecified, security is not enabled. "},{"title":"Artemis TM Data Link","url":"/docs/server/Artemis_TM_Data_Link/","body":"Reads tm data from an Artemis queue and publishes it to the configured stream. Class Name org.yamcs.tctm.ArtemisTmDataLink Configuration Options Name Type Description stream string Required. The stream where data is emitted address string Artemis address to bind to. preserveIncomingReceptionTime boolean When true incoming reception times are preserved. When false each packet is tagged with a fresh reception timestamp. Default: false "},{"title":"Artemis TM Publisher","url":"/docs/server/Artemis_TM_Publisher/","body":"Publish tm stream data to an Artemis broker. Class Name org.yamcs.artemis.ArtemisTmService Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.artemis.ArtemisTmService args: [tm_realtime, tm_dump] args must be a an array of strings indicating which streams to publish. For each stream the target address is composed as instance.stream. In the example tuples from the streams tm_realtime and tm_dump are published to the addresses simulator.tm_realtime and simulator.tm_dump respectively. By default, messages are published to an embedded broker (in-VM). This assumes that Artemis Server was configured as a global service. In order to use an external broker you can configure the property artemisUrl in either etc/yamcs.(instance).yaml or etc/yamcs.yaml: yamcs.simulator.yaml artemisUrl: tcp://remote-host1:5445 yamcs.yaml artemisUrl: tcp://remote-host1:5445 If defined, the instance-specific configuration is selected over the global configuration. The URL format follows Artemis conventions and is not further detailed in this manual. "},{"title":"Buckets","url":"/docs/http/Buckets/","body":"Buckets represent a simple mechanism for storing user objects (binary data chunks such as images, monitoring lists, displays…) together with some metadata. Buckets can be created globally or asociated with an instance. The metadata is represented by simple (key,value) pairs where both key and value are strings. By default each user has a bucket named user.username which can be used without extra privileges. Additional buckets may be created and used if the user has the required privileges. The user bucket will be created automatically when the user tries to access it. Buckets can be created at global level or at instance level. The following limitations are implemented in order to prevent disk over consumption and keep the service responsive: The maximum size of an upload including data and metadata is 5MB. The maximum number of objects in one bucket is 1000. The maximum size of an bucket 100MB (counted as the sum of the size of the objects within the bucket). The maximum size of the metadata is 16KB (counted as the sum of the length of the keys and values). "},{"title":"CDMCS MDB Loader","url":"/docs/server/CDMCS_MDB_Loader/","body":"TM/TC This loader loads the telemetry/telecommand definition directly from the Oracle using the oracle jdbc driver. The relevant configuration file is etc/cdmcs-mdb.yaml. This configuration file contains, next to the username/password used to connect to the database, the path and the version of the CCU that will be loaded and also the testConfiguration (an end item of type EGSE_TEST_CONFIGURATION). Based on the CCU parameters and on the opsname of the testConfiguration (the test configuration can only be specified through its opsname, so the opsname must exist and be unique.), Yamcs can determine the following three attributes which are used as attributes of the XTCE header: CCU Internal Version - this is a number uniquely identifying the CCU and the CCU version Test Configuration SID - this is a number uniquely identifying the test configuration Consistency Date - this is the time when the configured CCU has been last modified. Please refer to Telemetry Processing and to Commanding for details on the loading of the MDB end items and on the mapping to Yamcs structures. The configuration parameter checkForUpdatedMdb configures Yamcs to check or not the Oracle database for modified versions of the MDB. If the MDB cannot be loaded from the serialized file, the Oracle database is checked nevertheless. This option is useful for working offline. However if it is set to false, Yamcs will never read new versions of the database, and if the database is modified and SCOE files generated, MCS Tools will refuse to load the SCOE files (it will want old ones corresponding to the saved Yamcs database). The packet description in CD-MCS MDB is spread over different structures. When read into Yamcs, they are converted into the XTCE structures as follows: A generic sequence container named “ccsds” is created. This will be the root of the hierarchy. Three parameters are added to this sequence container: CCSDS_APID the APID in the CCSDS primary header CCSDS_SH_PACKETTYPE the packet type in the CCSDS secondary header CCSDS_PACKETID the packet type in the CCSDS secondary header A generic sequence container named CCSDS_RESPONSE_PACKET inheriting from the “CCSDS” container is created. The inheritance condition is CCSDS_SH_PACKETTYPE=12(Response_packet). This packet can be used by the CIS clients which want to subscribe to all the CCSDS response packets (for example the cmd-history). All the command responses (CCSDS_ADU_DESCRIPTION which have CCSDS Secondary Header set to CCSDS_RESPONSE_PACKET) are set to inherit the CCSDS_RESPONSE_PACKET container defined above. The inheritance condition is set on the CCSDS_APID, CCSDS_PACKETID parameters. All others CCSDS_ADU_DESCRIPTION are set to inherit directly the root container CCSDS. The inheritance condition is set also on the CCSDS_APID and CCSDS_PACKETID parameters. For each CCSDS_ADU_DESCRIPTION that contains a “Reference To a Structure ID or Table” pointing to an end item of type MEASUREMENT_LIST_TABLE, an additional integer parameter is created containing the definition of the “Flexible ID” as defined in this aggregate. Then for each end item of type PUS_STRUCTURE_ID referred in the MEASUREMENT_LIST_TABLE, a sequence container is created in Yamcs, set to inherit the original CCSDS_ADU_DESCRIPTION with the inheritance condition on the Flexible ID as defined in the MEASUREMENT_LIST_TABLE. PP Loader The PP loader scans a configured CD-MCS MDB for all the end items of type UMI_MAPPING_TABLE. The first part of the Opsname (string before the underscore) is used as group name. "},{"title":"Capturing Log Output","url":"/docs/studio/Capturing_Log_Output/","body":"In case you need to debug an issue with a deployed Yamcs Studio client, it can be useful to capture the logging output. Instructions are specific to the platform. Linux Launch the executable from a terminal window while redirecting all output to a file named log.txt ./Yamcs\\ Studio &gt;log.txt 2&gt;&amp;1 Mac OS X With Terminal navigate into the Yamcs Studio application bundle and launch the executable directly from there while redirecting all output to a file named log.txt. For example: cd Yamcs\\ Studio.app/Contents/MacOS ./Yamcs\\ Studio &gt;log.txt 2&gt;&amp;1 Windows With Command Prompt navigate into the location where you installed Yamcs Studio and launch the executable while redirecting all output to a file named log.txt. For example: \"Yamcs Studio.exe\" &gt;log.txt 2&gt;&amp;1 "},{"title":"Clients","url":"/docs/http/Clients/","body":" "},{"title":"Command History","url":"/docs/studio/Command_History/","body":"The Command History keeps track of all commands that were issued using Yamcs (not just by yourself, but by anyone). It will by default only show commands that were received on the realtime processor since you started your copy of Yamcs Studio. To load the command history for an earlier time range, select Import. Clear your view by clicking Clear. You can always import the cleared commands again at a later time. When Yamcs Studio becomes aware of a new command that was issued by Yamcs, it will automatically select and reveal it. You can prevent this default behaviour by toggling the Scroll Lock. The displayed columns are as follows. T Time when the command was issued Command The command in textual format Src The origin of the command. Typically in user@host format Src.ID The ID that was given to the command by the issuing application. This number is assigned by the source application. In case of Yamcs Studio it is an incremental number that resets to 1 on every restart of Yamcs Studio. PTV Result of the Pretransmission Verification as performed by Yamcs. For example, some commands may only be applicable for 10 seconds and needs certain other parameters to be set to specific values. When the PTV bubble colors red, these type of context-dependent checks could not be validated, and therefore the command was not actually issued. Seq.ID The id that was determined by Yamcs before further dispatching the command. This is an incremental number that resets on every restart of Yamcs. Further Columns Indicate acknowledgments of ground hops as the command is being dispatched. The exact number and name of the columns depends largely on how Yamcs is deployed at your site. Yamcs typically calculates the state of these bubbles based on incoming telemetry. The bubble becomes green or red depending on the verification result. The column value shows the time difference with the issuing time T. "},{"title":"Command History Recorder","url":"/docs/server/Command_History_Recorder/","body":"Records command history entries. This service stores the data coming from one or more streams into a table cmdhist. Class Name org.yamcs.archive.CommandHistoryRecorder Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.CommandHistoryRecorder streamConfig: event: - cmdhist_realtime - cmdhist_dump With this configuration events emitted to the cmdhist_realtime or cmdhist_dump stream are stored into the table cmdhist. "},{"title":"Command History Updates","url":"/docs/http/Command_History_Updates/","body":"The cmdhistory resource type within the WebSocket API allows subscribing to commanding history updates. Information will be received when new commands are sent to Yamcs, and when Yamcs Server is notified of acknowledgements over its further lifecycle. Subscribe Within the WebSocket request envelope use these values: request-type cmdhistory request subscribe This will make your web socket connection receive updates of the type CMD_HISTORY. Here’s example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData) for one issued command. [1,2,3] [1,4,0,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"TransmissionConstraints\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"NA\"}}]}}] [1,4,1,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Final_Sequence_Count\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"11\"}}]}}] [1,4,2,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_FSC_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK: OK\"}}]}}] [1,4,3,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_FSC_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956723844}}]}}] [1,4,4,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_FRC_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK: OK\"}}]}}] [1,4,5,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_FRC_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956724244}}]}}] [1,4,6,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_DASS_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK: OK\"}}]}}] [1,4,7,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_DASS_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956724644}}]}}] [1,4,8,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_MCS_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK: OK\"}}]}}] [1,4,9,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_MCS_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956725044}}]}}] [1,4,10,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_A_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK A: OK\"}}]}}] [1,4,11,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_A_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956725444}}]}}] [1,4,12,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_B_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK B: OK\"}}]}}] [1,4,13,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_B_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956726444}}]}}] [1,4,14,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_C_Status\",\"value\":{\"type\":\"STRING\",\"stringValue\":\"ACK C: OK\"}}]}}] [1,4,15,{\"dt\":\"CMD_HISTORY\", \"data\":{\"commandId\":{\"generationTime\":1490956723442,\"origin\":\"user@my-machine\",\"sequenceNumber\":1,\"commandName\":\"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\"},\"attr\":[{\"name\":\"Acknowledge_C_Time\",\"value\":{\"type\":\"TIMESTAMP\",\"timestampValue\":1490956727444}}]}}] Unsubscribe Within the WebSocket request envelope use these values: request-type cmdhistory request unsubscribe This will stop your WebSocket connection from getting further command history updates. "},{"title":"Command Options","url":"/docs/studio/Command_Options/","body":"Yamcs Studio accepts these command options: -version Print version info and quit -workspace /some/workspace Use the provided workspace. If unspecified the workspace is set to ~/yamcs-studio -force-workspace-prompt Prompt for the workspace "},{"title":"Command Queues","url":"/docs/studio/Command_Queues/","body":"This view allows controlling the Yamcs queues from the point of view of Yamcs Server. With sufficient privileges, queues can be blocked or disabled. The view is split into two panels: The upper panel contains a list with all the defined command queues. The queue name, the current state and the number of commands that are currently in the queue is displayed. Right-clicking on a command queue opens a menu with the possibility to change the state of the queue. In addition to setting the new state of the queue, the following additional actions happen when changing the state of a blocked queue: blocked → disabled: all the commands in the queue will be automatically rejected; blocked → enabled: all the commands in the queue will be automatically sent. The bottom panel contains the list of commands currently present in the queue that is selected in the upper panel. For each command the queue name, the command id, the user that has sent the command and the command string are displayed. The list is empty if the selected queue is not in the state blocked. Right-clicking on a command gives the possibility to Send or Reject the command. "},{"title":"Command Queues Updates","url":"/docs/http/Command_Queues_Updates/","body":"The cqueues resource type within the WebSocket API allows subscribing to commanding queue updates. Information will be received when new commands are added into the queues, commands are removed from the queues as well as when the queues state changes (between BLOCKED, ENABLED, DISABLED). Subscribe Within the WebSocket request envelope use these values: request-type cqueues request subscribe This will make your web socket connection receive updates of the type Commanding.CommandQueueInfo and Commanding.CommandQueueEntry. The initial CommandQueueInfo message (right after subscription) will contain the command queue information including all the commands in the queue. The subsequent messages will only be sent each time the command queue state modifies (e.g. from ENABLED to BLOCKED) or when a command is added or sent but will not include the commands in the queue. The information about the commands added/sent/removed is sent in Commanding.CommandQueueEntry messages. Here’s example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData) for a message received just after subscription. [1,2,3] [1,4,0,{\"dt\":\"COMMAND_QUEUE_INFO\",\"data\":{\"instance\":\"simulator\",\"processorName\":\"realtime\",\"name\":\"default\",\"state\":\"BLOCKED\",\"nbSentCommands\":5,\"nbRejectedCommands\":1,\"entry\":[{\"instance\":\"simulator\",\"processorName\":\"realtime\",\"queueName\":\"default\",\"cmdId\":{\"generationTime\":1470381583809,\"origin\":\"127.0.0.1\",\"sequenceNumber\":14,\"commandName\":\"/test123/\"},\"source\":\"test123()\",\"binary\":\"GMnAAAA5ABBDDEBqEwCwRsiBwEcAAABpAAAAAAAPc3ZfaXNDcmlzc0Nyb3NzAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\"username\":\"nm\",\"generationTime\":1470381583809,\"uuid\":\"2459b774-52e2-4011-b753-31151e689821\"}]}}] Below, an example message received when a command is added to the queue: [1,4,3,{\"dt\":\"COMMAND_QUEUE_EVENT\",\"data\":{\"type\":\"COMMAND_ADDED\",\"data\":{\"instance\":\"simulator\",\"processorName\":\"realtime\",\"queueName\":\"default\",\"cmdId\":{\"generationTime\":1470381585809,\"origin\":\"127.0.0.1\",\"sequenceNumber\":14,\"commandName\":\"test124\"},\"source\":\"test124()\",\"binary\":\"GMnAAAA5AAAAAABqewCwRsiBwEcAAABpAAAAAAAPc3ZfaXNDcmlzc0Nyb3NzAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\"username\":\"nm\",\"generationTime\":1470381583809,\"uuid\":\"2459b774-89e2-4011-b753-31151e689821\"}}}] Unsubscribe Within the WebSocket request envelope use these values: request-type cqueues request unsubscribe This will stop your WebSocket connection from getting further commanding queue updates. "},{"title":"Command Stack","url":"/docs/studio/Command_Stack/","body":"The Command Stack allows operators to prepare stacks of commands for manual command issuing. The process is intentionally click-heavy to make sure that operators are aware of what they are doing. When you issue commands from Yamcs Studio, these are queued to Yamcs Server, which will perform any further steps. We’re keen on bringing many improvements to this view for better editing, but it is usable in its current state. Preparing a Stack Executing a Stack Importing and Exporting a Stack Preparing a Stack You can prepare a stack of commands only when you are connected to Yamcs. Yamcs Studio uses this connection to retrieve the list of available commands or to perform server-side validations. When you start Yamcs Studio, the Command Stack view (available from the Display Runner window) is by default shown below the operator displays. If you can’t find it back, select Window &gt; Show View &gt; Command Stack. Add a command by clicking the Add Command button. This opens a wizard dialog with the list of available commands. You can filter the list with the search box on top. Commands are identified by their fully qualified XTCE name. This name matches the hierarchical structure of the commands as defined in the mission database of the connected Yamcs instance. Commands can have varying levels of criticality (called significance in XTCE terminology). The icon in the leftmost column indicates the defined criticality for the command. Icon Criticality Watch Warning Distress Critical Severe If an explanatory message regarding the criticality was defined in the mission database, this will show in the top title area of the dialog when the command is selected. Once you’ve chosen your command, hit Next to go the next page in the wizard, where you can specify any arguments that need to be provided for the command. Currently, only numbers or text can be entered. You can close the wizard from the first page as well by clicking Finish instead of Next. If the command requires any arguments, you will have a chance to add them afterwards as well by editing your stacked command. Click Finish to append your command to the end of your current stack. You can review your provided arguments by double clicking the command. To remove the selected command from the stack select Delete. Clear the entire stack with Delete All. If a stacked command does not pass static validation checks (sometimes referred to as SPTVs – Static PreTransmission Verification) it will be marked with error indicators. This will prevent the user from attempting further execution of the stack until the error is resolved. It is not currently possible to move a command up or down the stack. Executing a Stack As soon as your manual stack contains at least one command, you can start execution. Execution is top-down, so select the first command of your stack. There is currently no clear separation between a ‘stack editing’ mode and a ‘stack executing’ mode. We are happy with this given the current set of features, but may revise this concept as we add more features (e.g. moving commands up and down the stack). In the bottom bar click the 1. Arm button. This will ‘arm’ your command, and is a first required step before issuing it. There is currently no timeout on how long a command stays armed before being reverted to disarmed. If the command you are arming has a defined criticality (watch, warning, distress, critical or severe), you will receive a confirmation dialog first. Once your command is armed it will say so in the Stack State column. Arming a command is a client-side notion. There is no communication with Yamcs during this step. The intention of arming a command is to make the operator aware of his actions, especially when the command is significant. There is currently no support for arming multiple commands together and execution commands in batch. Now that your command is armed, hit 2. Issue. There will be no more confirmation dialogs. If the server refuses your request you will receive an error message. This can happen for example when a command is only to be executed under a certain context, and within a certain time frame. These type of settings are currently exclusively defined in the Yamcs Mission Database. To follow what happens to your command, open up the Command History view, explained in the next section. When the command is issued, the Stack State column is updated, and you can arm the next command in the stack to repeat the process. Skip the selected command by selecting Skip. Reset the execution state by selecting Restart. This will reset all Stack State columns to Disarmed. Importing and Exporting a Stack When you want to save a stack for future use, you can select Export to save your stack in XML-format in any of your drives. Likewise, reuse a stack which you set aside by selecting Import. "},{"title":"Commanding","url":"/docs/server/Commanding/","body":"Yamcs supports XTCE concepts for commanding. Commands have constraints (preconditions) and verifiers (postconditions). The constraints are checked before issuing an command and the verifiers are run after the command has been issued to verify the different stages of execution. In addition to the constraints/verifiers, Yamcs also implements the concept of command queue. This allows an operator to inspect commands of other users before being issued. It also allows to block completely commands from users during certain intervals (this effect can also be obtained with a constraint). The Commands and arguments are formatted to binary packets based on the XTCE definition. Command Significance Yamcs uses the XTCE concept of command significance. Each command’s significance can have one of this values none (default), watch, warning, distress, critical or severe. In addition to the significance, the command has a message explaining why the command has the given significance. Currently, Yamcs Server does not check or impose anything based on the significance of the command. In the future, the privileges may be used to restrict users that can send commands of high significance. However, currently the information (significance + reason) is only given to an external application (Yamcs Studio) to present it to the user in a suitable manner. The command significance can be defined in the Excel Spreadsheet in the CommandOptions tab: Command Queues When a command is sent by an external user, it goes first into a queue. Privileges are checked before the command is put into the queue, so if the user doesn’t have the privilege for the given command, the command will be rejected and not appear at all in the queue. The available queues are defined in the file etc/command-queue.yaml. command-queue.yaml ops: state: enabled significances: [none] ops-critic: state: enabled significances: [watch, warning, distress, critical, severe] stateExpirationTimeS: 300 Each queue has a name, a default state and a list of roles. The commands of a user logging in with a given role will be put in the first queue for which the user has privileges. A queue can be in three different states: Enabled means the commands are sent immediately Blocked means the commands are accepted into the queue but need to be manually sent Disabled means the commands are rejected There is always a command-queue called ‘default’ whose state is enabled. If a command comes from a user without privilege for any of the defined queues, the command will be put in the default queue. The default queue can be redefined in etc/command-queue.yaml in order to have a different state. Control over the command queues, requires the ControlCommandQueue privilege. Transmission Constraints When the is set to be released from the queue (either manually by an operator or automatically because the queue was in the Enabled state), the transmission constraints are verified. The command constraints are conditions set on parameters that have to be met in order for the command to be releasd. There can be multiple constraints for each command and each constraint can specify a timeout which means that the command will fail if the constraint is not met within the timeout. If the timeout is 0, the condition will be checked immediately. The transmission constraints can be defined in the Excel Spreadsheet in the CommandOptions tab. Currently it is only possible to specify the transmission constraints based on parameter verification. This corresponds to Comparison and ComparisonList in XTCE. In the future it will be possible to specify transmission constraints based on algorithms. That will allow for example to check for specific values of arguments (i.e. allow a command to be sent if cmdArgX &gt; 3). "},{"title":"Commanding","url":"/docs/http/Commanding/","body":" "},{"title":"Connecting to Yamcs","url":"/docs/studio/Connecting_to_Yamcs/","body":"Yamcs Studio is a client application that is meant to be connected with Yamcs Server. Yamcs Server, or ‘Yamcs’, handles the processing, archiving and dispatching of telemetry data. Yamcs Studio is one of the possible Yamcs clients for receiving telemetry data. To configure a Yamcs connection, select File &gt; Connect…. This will open the Connections window where you can manage your connections. For many missions, one connection will do just fine, but depending on how Yamcs is deployed at your site, you may have multiple Yamcs instances on the same server, or even multiple Yamcs servers. Click Add Server to add a server connection, or Remove Server to remove the selected server connection. Connection Properties The right panel contains editable details for the selected server connection. We document the available properties below, but if you’re unsure what to fill in, ask details to the person that is responsible for installing Yamcs at your site. Yamcs Instance Required Yamcs can run multiple instances in parallel. You can think of instances like different environments, where every instance is completely separated from the other instance. While Yamcs Server may be running multiple instances in parallel, Yamcs Studio will always connects the user to one specific instance, which you have to configure here. User / Password Optional If your Yamcs instance is secured, fill in your user and password here. Primary Server Required Specify your actual host and port connection details here. The port is usually 8090. Failover Server Optional If you specify a second host/port configuration, then Yamcs Studio will automatically failover to this second server in case connection with the primary server could not be established, or was lost. On the server-end, this setup requires two distinct Yamcs servers that are being kept in sync. Name Required You can give your configuration a name of your choosing. This name will be used to represent this connection in the left panel of the Connections window. Save Password Optional If you prefer not to enter your password at every occasion, tick this box to save your password to disk. Please be aware that your password will be saved in a manner that is difficult, but not impossible, for an intruder to break. Connecting All changes you make are automatically saved when you click Connect. If you want to discard your changes click Cancel. Select the Connect on startup option, if you would like Yamcs Studio to automatically reconnect to the last used Yamcs instance during start-up. If this connection requires privileges and you chose not to save your password to disk, you will see a specialised login window everytime you start Yamcs Studio: Connection preferences are stored in a hidden folder under your home directory, and will continue functioning whenever you upgrade your copy of Yamcs Studio. You can verify that your copy of Yamcs Studio is properly connected by looking at the bottom status bar: If it says realtime, then you’ve successfully connected. "},{"title":"Control Widgets","url":"/docs/studio/Control_Widgets/","body":"Action Button A button that can be used to trigger Actions. Use the Toggle property to have the option of adding a different action on press and release. Menu Button A button that will show a menu when it’s clicked. The menu will be filled with either the actions from Actions property or the string values from the connected enumerated PV. Text Input A widget that allows the user to write data to the connected (writable) PV. For dates set the Selector Type to Datetime. Spinner The Spinner widget is similar to the Text Input, but allows updating the PV in incremental steps using up and down arrow buttons. Scaled Slider This widget allows adjusting the connected PV value using a configurable slider. Knob Knobs allow adjusting the connected PV value by dragging the thumb around. Scrollbar Scrollbar that allows adjusting the connected PV value by. Useful as a building block for advanced display customizations. Thumb Wheel A widget that allows adjusting the decimal value of a PV digit by digit. Boolean Switch A Boolean Switch is able to write 0 or 1 to a single configurable bit of the connected PV or the whole PV if the Bit property is set to -1. If Width is greater than Height, the switch will render horizontally, otherwise vertically. Boolean Button A Boolean Button is able to write 0 or 1 to a single configurable bit of the connected PV or the whole PV if the Bit property is set to -1. Image Boolean Button Same as the Boolean Button widget, but you can customize the look further by specifying your own images with the Off Image and On Image properties. The selected images must be present in the workspace. Check Box A Check Box is able to write 0 or 1 to a single configurable bit of the connected PV or the whole PV if the Bit property is set to -1. Use the Label property to render a value next to the check box. Radio Box A Radio Box allows the user to choose between a configurable set of values. Use the Items property to specify these values. Choice Button Similar to the Radio Box, but with buttons. Toggling a button within the widget, untoggles the previously active button. Combo The Combo widget, as well, makes the user choose between one of its Items. "},{"title":"Create Bucket","url":"/docs/http/Create_Bucket/","body":"Create a bucket: POST /api/buckets/:instance _global can be used as instance name to create a bucket at the global level. Request Body { \"name\": \"my_bucket\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message CreateBucketRequest { optional string name = 1; } "},{"title":"Create Event","url":"/docs/http/Create_Event/","body":"Create an event for the given Yamcs instance: POST /api/archive/:instance/events/ Parameters Name Type Description message string Required. Event message. type string Description of the type of the event. Useful for quick classification or filtering. severity string The severity level of the event. One of info, watch, warning, distress, critical or severe. Default is info time string Time associated with the event. Must be a date string in ISO 8601 format. If unspecified, this will default to the current mission time. source string Source of the event. Useful for grouping events in the archive. Default is User. sequence_number int Sequence number of this event. This is primarily used to determine unicity of events coming from the same source. If not set Yamcs will automatically assign a sequential number as if every submitted event is unique. Example Create an informatory event at the current mission time: { \"message\": \"Some info message\" } Add a critical event in the past: { \"message\":\"Some critical message\", \"severity\": \"critical\", \"time\": \"2015-01-01T00:00:00.000Z\", } Response The full event is returned in the response body, including fields that are added by Yamcs Server. Status: 200 OK { \"source\": \"User\", \"generationTime\": \"1524258406719\", \"receptionTime\": \"1524258406719\", \"seqNumber\": 0, \"message\": \"Some info message\", \"severity\": \"INFO\", \"generationTimeUTC\": \"2018-04-20T21:06:09.719Z\", \"receptionTimeUTC\": \"2018-04-20T21:06:09.719Z\", \"createdBy\": \"admin\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message CreateEventRequest { optional string type = 1; optional string message = 2; optional string severity = 3; optional string time = 4; optional string source = 5; optional int32 sequenceNumber = 6; } "},{"title":"Create Processor","url":"/docs/http/Create_Processor/","body":"Create a processor for the given Yamcs instance: POST /api/processors/:instance Parameters Name Type Description name string Required. The name of the processor. Must be unique for the Yamcs instance. type string Required. The type of the processor. The available values depend on how Yamcs Server is configured. Most Yamcs deployments support at least a type Archive which allows for the creation of processors replaying archived data persistent bool Keep the processor when terminated. Default: no clientId array of integers The client IDs that should be connected to this processor. config string Configuration options specific to the processor type. Note that this should be a string representation of a valid JSON structure. Replay Config When creating a processor of type Archive, the config JSON supports these parameters: Name Type Description utcStart string Required. The time at which the replay should start. Must be a date string in ISO 8601 format. utcStop string The time at which the replay should stop. Must be a date string in ISO 8601 format. If unspecified, the replay will keep going as long as there is remaining data. loop bool Whether the processing should restart at the end of the replay. Default: no speed string The speed of the processor. One of: afap a speed factor relative to the original speed. Example: 2x a fixed delay value in milliseconds. Example: 2000 Default: 1x Example Start a replay at January 1st 2015 at 4.5x the original speed, and add client 12 to the replay: { \"name\" : \"An example processor\", \"type\": \"Archive\", \"clientId\" : [ 12 ], \"config\": \"{\\\"utcStart\\\":\\\"2015-01-01T00:00:00.000Z\\\",\\\"speed\\\":\\\"4.5x\\\"}\", } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message CreateProcessorRequest { optional string name = 1; repeated int32 clientId = 6; optional bool persistent = 11; optional string type = 12; optional string config = 13; } "},{"title":"Create Tag","url":"/docs/http/Create_Tag/","body":"Create a tag for the given archive instance: POST /api/archive/:instance/tags Parameters Name Type Description name string Required. The name of the tag. description string The description of the tag. start string The start time of the tag. Default is unbounded. stop string The stop time of the tag. Default is unbounded. color string The color of the tag. Must be an RGB hex color, e.g. #ff0000 Example Create a red tag covering January 1st 2015, onwards: { \"name\" : \"My archive annotation\", \"start\" : \"2015-01-01T00:00:00.000Z\", \"color\" : \"#ff0000\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message CreateTagRequest { optional string name = 1; optional string start = 2; optional string stop = 3; optional string description = 4; optional string color = 5; } "},{"title":"Data Link Initialiser","url":"/docs/server/Data_Link_Initialiser/","body":"Manages the various data links and creates needed streams during Yamcs start-up. Data Links represent data connections to external sources. These connections may represent output flows (TC), input flows (TM, PP) or a combination of these. Data links that read TM and PP data receive telemetry packets or parameters and inject them into the realtime or dump TM or PP streams. Data links that send TC subscribe to a TC stream and send data to external systems. Note that any Yamcs Service can connect to external sources and inject data in the streams. Data links however, can report on their status using a predefined interface and can also be controlled to connect or disconnect from their data source. Class Name org.yamcs.tctm.DataLinkInitialiser Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.tctm.DataLinkInitialiser dataLinks: - name: tm_realtime class: org.yamcs.tctm.TcpTmDataLink args: stream: tm_realtime host: localhost port: 10015 - name: tm_dump class: org.yamcs.tctm.TcpTmDataLink args: stream: tm_dump host: localhost port: 10115 - name: udp_realtime class: org.yamcs.tctm.UdpTmDataLink args: stream: tm_realtime port: 5900 maxLength: 2048 - name: tc_realtime class: org.yamcs.tctm.TcpTcDataLink args: stream: tc_realtime host: localhost port: 10025 Each link is defined in terms of an identifying name and a class. There is also a property enabledAtStartup which allows to enable (default) or disable the TM provider for connecting to the external data source at the server start-up. Specific data links may support additional arbitrary configuration options via the args key. "},{"title":"Data Links","url":"/docs/studio/Data_Links/","body":"This view provides an overview of the data links of a running Yamcs server. Data links represent input or output flows to Yamcs. There are three types of Data Links: TM (called TM Providers), TC (called TC Uplinkers) and PP (called PP Providers). TM and PP receive telemetry packets or parameters and inject them into the realtime or dump TM or PP streams. The TC data links subscribe to the realtime TC stream and send data to external systems. There are different types of providers. For details refer to the Yamcs Server Manual. The presented information includes: Name Identifier of this link as assigned by Yamcs Type The type of this link. For example, TcpTmProvider represents an input of TM over TCP Spec Configuration information passed to the provider instance. Significance depends on the type of provider Stream The internal stream where the data is either: sourced from (in the case of uplinkers), or published to (in the case of providers) It is perfectly valid for different providers or uplinkers to use the same stream. Status The status of this link. One of: OK &ndash; if the link is alive DISABLED &ndash; if the link was disabled UNAVAIL &ndash; if the link is enabled, but not available The Status background lights bright green if the data count increased within the last 1500 milliseconds. Data Count The number of data elements (e.g. packets) that this link published or received from its stream since Yamcs started running. With sufficient privileges, you can enable or disable a link manually by right-clicking the applicable row and selecting Enable Link or Disable Link. "},{"title":"Delete Bucket","url":"/docs/http/Delete_Bucket/","body":"Deleting a bucket means also deleting all objects that are part of it. Delete a bucket: DELETE /api/bucket/:instance/:bucketName _global can be used as instance name to delete a bucket at the global level. Response Status: 200 OK "},{"title":"Delete Object","url":"/docs/http/Delete_Object/","body":"Deleting a bucket means also deleting all objects that are part of it. Delete a bucket: DELETE /api/buckets/:instance/:bucketName/:objectName Response Status: 200 OK "},{"title":"Delete Partitions","url":"/docs/http/Delete_Partitions/","body":"Delete partitions from the parameter archive. GET /api/archive/:instance/parameterArchive/deletePartitions Parameters Name Type Description start string Start with the partition that contains this timestamp. Specify a date string in ISO 8601 format. stop string Stop with the partition that contains this timestamp. The stop partition will be removed as well. Specify a date string in ISO 8601 format. Response Status: 200 OK Response is of type string and list the partitions that have been removed. "},{"title":"Delete Processor","url":"/docs/http/Delete_Processor/","body":"Delete a processor: DELETE /api/processors/:instance/:name Only replay processors can be removed. "},{"title":"Delete Tag","url":"/docs/http/Delete_Tag/","body":"Delete a tag: DELETE /api/archive/:instance/tags/:start/:id "},{"title":"Display Builder","url":"/docs/studio/Display_Builder/","body":"The Display Builder window is used to create or edit displays. In the left explorer, expand the YSS Landing project and open for example FlightData.opi by double-clicking the file. The window layout can be decomposed like this: Explorer The Explorer contains all projects within the current workspace. In general a project is at the same level as a mission, but this is not strictly necessary. When we launch Yamcs Studio with a new workspace, it will always automatically create the YSS project. Once you have added your own project, you can remove YSS Landing and it will not be auto created anymore. A project contains Operator Displays (*.opi), images, style definitions (*.def), custom scripts (*.js), etc. By right-clicking an OPI file, displays can be opened in two different modes. In editing mode (default) In runtime mode (via a new view) Editor Area The Editor Area contains tabs for every OPI that was opened for editing. This offers familiar editing controls. Widgets can be selected, grouped, dragged and deleted to your personal taste. Outline The Outline view presents a hierarchical breakdown of all the widgets within the currently active editor tab. It is useful for finding back widgets. Widgets that were named will be easily identifiable. Toolbar The toolbar offers context-sensitive controls. This includes general Save functionality, as well as handy features like grid toggling or space distribution among different widgets. Properties The Properties view shows the properties of widgets (or of the display itself). Notable properties include the PV Name which allows you to connect a widget with a specific Yamcs parameter (with autocompletion support). Other properties allow the display author to greatly tweak default widget behaviour. And in cases where the properties are not sufficient, we can always escape to more customization options using rules and scripts (there are properties for adding these as well). Palette The Palette contains the widgets that are available in your copy of Yamcs Studio. Select a widget from the Palette, and then click somewhere in the editor area to place it down. When you are done doing changes, make sure to save them (File &gt; Save All). You can now test out your changes by clicking the launch button from the toolbar. This will open a new runtime window (notice it uses the OPI Runtime perspective). If you leave this window open, and you save more changes, do a right-click in your display tab and choose Refresh OPI. You will do this a lot as you go about editing displays. You can also refresh by hitting F5, but make sure that your display actually has focus (for example by clicking somewhere in the editor before hitting F5). "},{"title":"Display Runner","url":"/docs/studio/Display_Runner/","body":"The Display Runner window is useful for realtime operations, or for testing out displays as they are being built. The default layout looks like this: Processor Info This zone holds two status indicators. The first indicator light shows the processor that Yamcs Studio is currently listening to. Yamcs supports many concurrent processors (realtime, replay channels). By default Yamcs Studio will always connect to realtime. Next to that we see a second indicator which currently shows the processor time as provided by Yamcs. The simulator outputs generation times equal to the local system clock. Display Tabs Displays open in different tabs. By clicking and dragging these tabs we can easily create split screens, or different tab stacks. We can also drag a tab out of its parent window into a new window. In fact, Yamcs Studio is optimised for multi-monitor systems. Window layouts are restored through restarts of Yamcs Studio. Display Zoom The display shown in the picture was configured in such a way that it automatically stretches (while preserving aspect ratio) to fit the available screen space. This behaviour can be turned on or off by the display author. Regardless of its setting, as a display user we can always zoom in or out of the display using these controls. Operator Displays This area contains displays that were authored in the Display Builder window. Displays contain any number of widgets. Most widgets can be connected to TM, which will also make them alarm-sensitive. In practice this means that they will be highlighted using different decorations depending on the alarm level. There are also things like button widgets which can for example open other displays, or launch a telecommand, or open dialog boxes, etc. All widgets are highly customisable using scripts and/or rules. Built-In Displays Yamcs Studio comes with an array of built-in displays that offer more dynamic views on different aspects of Yamcs. These built-in displays (or Views, as Yamcs Studio calls them) cover concepts like commanding, event logging, alarm overviews (upcoming) and archive insight. "},{"title":"Download Bulk Indexes","url":"/docs/http/Download_Bulk_Indexes/","body":"Download multiple indexes at the same time for the given instance: GET /api/archive/:instance/indexes This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. filter array of strings The type of indexes to retrieve. Choose out of tm, pp, events, commands or completeness. By default all indexes will be sent. packetname array of strings Specify exact names for the TM packets for which you want to retrieve index records. Setting this parameter, automatically implies that tm is added to the filter. Example request URI: /api/archive/simulator/indexes?filter=commands,events&amp;packetname=/YSS/SIMULATOR/Power Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"instance\" : \"simulator\", \"records\" : [ { \"id\" : { \"name\" : \"/YSS/SIMULATOR/Power\" }, \"first\" : 1448272059406, \"last\" : 1448272084398, \"num\" : 5 }, { \"id\" : { \"name\" : \"/YSS/SIMULATOR/Power\" }, \"first\" : 1448823600003, \"last\" : 1448824423242, \"num\" : 133 } ], \"type\" : \"histogram\", \"tableName\" : \"tm\" }{ \"instance\" : \"simulator\", \"records\" : [ { \"id\" : { \"name\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"first\" : 1448731973739, \"last\" : 1448731973739, \"num\" : 1 }, { \"id\" : { \"name\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\" }, \"first\" : 1448791891823, \"last\" : 1448791891823, \"num\" : 1 } ], \"type\" : \"histogram\", \"tableName\" : \"cmdhist\" } Alternative Media Types Protobuf request This can be used when the list of packets is long and the GET URI would be larger than 4096 characters. Use HTTP header: Content-Type: application/protobuf The request is the same but without parameters. The parameters are encoded in the body and they are of type: rest/rest.proto message BulkGetIndexRequest { optional string start = 1; optional string stop = 2; repeated string filter = 3; repeated string packetname = 4; } Protobuf response Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message IndexResult { required string instance = 1; repeated ArchiveRecord records = 2; //type can be histogram or completeness optional string type = 3; //if type=histogram, the tableName is the table for which the histogram is sent optional string tableName = 4; } "},{"title":"Download Command Index","url":"/docs/http/Download_Command_Index/","body":"Download the index of stored commands for the given instance: GET /api/archive/:instance/indexes/commands This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"id\" : { \"name\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"first\" : 1448731973739, \"last\" : 1448731973739, \"num\" : 1 }{ \"id\" : { \"name\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"first\" : 1448782973440, \"last\" : 1448782973440, \"num\" : 1 }{ \"id\" : { \"name\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"first\" : 1448783668726, \"last\" : 1448783674298, \"num\" : 3 } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message ArchiveRecord { required NamedObjectId id = 1; required int64 first = 2; required int64 last = 3; required int32 num = 4; optional string info = 5; } "},{"title":"Download Commands","url":"/docs/http/Download_Commands/","body":"Download command history: GET /api/archive/:instance/downloads/commands This operation will possibly download a very large file. Parameters Name Type Description start string Filter the lower bound of the command's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the command's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. order string The order of the returned results. Can be either asc or desc. Default: asc Response The response will be a stream of self-standing command history records. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited by a VarInt. Messages are of type: commanding/commanding.proto message CommandHistoryAttribute { optional string name = 1; optional yamcs.Value value = 2; optional int64 time = 3; } message CommandHistoryEntry { required CommandId commandId = 1; repeated CommandHistoryAttribute attr = 3; } "},{"title":"Download Completeness Index","url":"/docs/http/Download_Completeness_Index/","body":"Download the completeness index records for the given instance: GET /api/archive/:instance/indexes/completeness This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"id\": { \"name\": \"apid_1\" }, \"first\": \"1522399433316\", \"last\": \"1522399433316\", \"num\": 1, \"info\": \"seqFirst: 0 seqLast: 0\" }{ \"id\": { \"name\": \"apid_1\" }, \"first\": \"1522399433515\", \"last\": \"1522399433515\", \"num\": 1, \"info\": \"seqFirst: 0 seqLast: 0\" }{ \"id\": { \"name\": \"apid_1\" }, \"first\": \"1522399433718\", \"last\": \"1522399433718\", \"num\": 1, \"info\": \"seqFirst: 0 seqLast: 0\" } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message ArchiveRecord { required NamedObjectId id = 1; required int64 first = 2; required int64 last = 3; required int32 num = 4; optional string info = 5; } "},{"title":"Download Event Index","url":"/docs/http/Download_Event_Index/","body":"Download the index of stored events for the given instance: GET /api/archive/:instance/indexes/events This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"id\" : { \"name\" : \"CustomAlgorithm\" }, \"first\" : 1448272052179, \"last\" : 1448272052241, \"num\" : 2 }{ \"id\" : { \"name\" : \"CustomAlgorithm\" }, \"first\" : 1448272057109, \"last\" : 1448272062209, \"num\" : 3 }{ \"id\" : { \"name\" : \"CustomAlgorithm\" }, \"first\" : 1448272067107, \"last\" : 1448272072206, \"num\" : 3 } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message ArchiveRecord { required NamedObjectId id = 1; required int64 first = 2; required int64 last = 3; required int32 num = 4; optional string info = 5; } "},{"title":"Download Events","url":"/docs/http/Download_Events/","body":"Download archived events: GET /api/archive/:instance/downloads/events This operation will possibly download a very large file. If you worry about size for your application, check out the support for paged event retrievals instead. Parameters Name Type Description severity string The minimum severity level of the events. One of info, watch, warning, distress or severe. Default: info q string Text to search for in the message. source array of strings The source of the events. Both these notations are accepted: ?source=DataHandler,CustomAlgorithm ?source[]=DataHandler&amp;source[]=CustomAlgorithm Names must match exactly. start string Filter the lower bound of the event's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the event's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. order string The order of the returned results. Can be either asc or desc. Default: asc Response The response will be a stream of self-standing event records. Alternative Media Types CSV Use HTTP header: Accept: text/csv Or, add this query parameter to the URI: format=csv. Response: Status: 200 OK Content-Type: text/csv Source Generation Time Reception Time Event Type Event Text AlarmChecker 2015-11-13T14:46:36.029Z 2015-11-13T14:46:36.029Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 195 AlarmChecker 2015-11-13T14:46:29.784Z 2015-11-13T14:46:29.784Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 196 AlarmChecker 2015-11-13T14:46:23.571Z 2015-11-13T14:46:23.571Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 197 Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited by a VarInt. Messages are of type: yamcs.proto message Event { enum EventSeverity { INFO = 0; WARNING = 1; ERROR = 2; } required string source = 1; required int64 generationTime = 2; required int64 receptionTime = 3; required int32 seqNumber = 4; optional string type = 5; required string message = 6; optional EventSeverity severity = 7[default=INFO]; optional string generationTimeUTC = 8; optional string receptionTimeUTC = 9; extensions 100 to 10000; } "},{"title":"Download PP Index","url":"/docs/http/Download_PP_Index/","body":"Download the index of stored processed parameter groups for the given instance: GET /api/archive/:instance/indexes/pp This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"id\" : { \"name\" : \"simulation\" }, \"first\" : 1448616349067, \"last\" : 1448616467049, \"num\" : 2 }{ \"id\" : { \"name\" : \"simulation\" }, \"first\" : 1448617368018, \"last\" : 1448617368018, \"num\" : 1 }{ \"id\" : { \"name\" : \"simulation\" }, \"first\" : 1448617667330, \"last\" : 1448617667330, \"num\" : 1 } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message ArchiveRecord { required NamedObjectId id = 1; required int64 first = 2; required int64 last = 3; required int32 num = 4; optional string info = 5; } "},{"title":"Download Packet Index","url":"/docs/http/Download_Packet_Index/","body":"Download the index of stored packets for the given instance: GET /api/archive/:instance/indexes/packets This operation will possibly download a very large file. Parameters Name Type Description start string The time at which to start retrieving index records. stop string The time at which to stop retrieving index records. name array of strings Exact qualified names of the packets to include in the index. By default all packets will be included. Partial wildcard matching is not currently supported. Example You get back a sequence of consecutive self-standing JSON objects. Note that this JSON output can be useful for testing, but you probably want to use the Protobuf media type for decreased network traffic. Status: 200 OK { \"id\" : { \"name\" : \"/YSS/SIMULATOR/FlightData\" }, \"first\" : 1448272053375, \"last\" : 1448272089628, \"num\" : 181 }{ \"id\" : { \"name\" : \"/YSS/SIMULATOR/Power\" }, \"first\" : 1448272059406, \"last\" : 1448272084398, \"num\" : 5 }{ \"id\" : { \"name\" : \"/YSS/SIMULATOR/DHS\" }, \"first\" : 1448272059406, \"last\" : 1448272084398, \"num\" : 5 } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of individual Protobuf messages delimited with a VarInt. Every message is of type: yamcs.proto message ArchiveRecord { required NamedObjectId id = 1; required int64 first = 2; required int64 last = 3; required int32 num = 4; optional string info = 5; } "},{"title":"Download Packets","url":"/docs/http/Download_Packets/","body":"Download archived packets: GET /api/archive/:instance/downloads/packets This operation will possibly download a very large file. If you worry about size for your application, check out the support for paged packet retrievals instead. Parameters Name Type Description name array of strings The archived name of the packets. Both these notations are accepted: ?name=/YSS/SIMULATOR/DHS,/YSS/SIMULATOR/Power ?name[]=/YSS/SIMULATOR/DHS&amp;name[]=/YSS/SIMULATOR/Power Names must match exactly. start string Filter the lower bound of the packet's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the packet's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. order string The order of the returned results. Can be either asc or desc. Default: asc Response The response will be a stream of self-standing JSON messages. Alternative Media Types Raw binary Use HTTP header: Accept: application/octet-stream Or add the query parameter format=raw. Protobuf Use HTTP header: Accept: application/protobuf The response is a stream of self-standing VarInt delimited messages of type: yamcs.proto message TmPacketData { required int64 receptionTime = 1; required bytes packet = 2; optional int64 generationTime = 3; optional int32 sequenceNumber = 4; optional NamedObjectId id = 5; } "},{"title":"Download Parameter Data","url":"/docs/http/Download_Parameter_Data/","body":"Download archived parameters: GET /api/archive/:instance/downloads/parameters/:namespace/:name This operation will possibly download a very large file. If you worry about size for your application, check out the support for paged parameter retrievals instead. Parameters Name Type Description start string Filter the lower bound of the parameter's generation time. Specify a date string in ISO 8601 format stop string Filter the upper bound of the parameter's generation time. Specify a date string in ISO 8601 format norepeat bool Whether to filter out consecutive identical values. Default no. order string The order of the returned results. Can be either asc or desc. Default: asc When using CSV output some columns are hidden by default. You can add them via the extra flag: Name Type Description extra array of strings Extra columns added to the CSV output: raw: Raw parameter values monitoring: Monitoring status Example: ?extra=raw,monitoring Response The response will be a stream of individual parameters. Multi-get Get the value history of multiple parameters in one and the same request using this address: GET /api/archive/:instance/downloads/parameters In addition to the parameters for the single parameter retrieval you can specify these: Name Type Description namespace string Namespace used to display parameter names in e.g. csv header. Only used when no parameter ids were specified ids list of name pairs Parameters to be included in the output. If not specified, all parameters from the MDB will be dumped. Example: { \"id\" : [ { \"name\": \"YSS_ccsds-apid\", \"namespace\": \"MDB:OPS Name\" }, { \"name\": \"/YSS/SIMULATOR/BatteryVoltage2\" } ] } POST requests are also allowed, because some HTTP clients do not support GET with a request body. Alternative Media Types CSV Use HTTP header: Accept: text/csv Or add the query parameter format=csv. Protobuf Use HTTP header: Accept: application/protobuf Bulk request is of type: rest/rest.proto message BulkDownloadParameterValueRequest { optional string start = 1; optional string stop = 2; repeated yamcs.NamedObjectId id = 3; optional string namespace = 4; } The response is a stream of self-standing VarInt delimited messages of type: pvalue/pvalue.proto message ParameterData { repeated ParameterValue parameter = 1; } "},{"title":"Download Table Data","url":"/docs/http/Download_Table_Data/","body":"Download archived table data: GET /api/archive/:instance/downloads/tables/:table This operation will possibly download a very large file. If you worry about size for your application, check out the support for paged table data instead. Parameters Name Type Description cols array of strings The columns to be included in the result. Both these notations are accepted: ?cols=rectime,gentime,pname ?cols[]=rectime&amp;cols[]=gentime&amp;cols[]=pname If unspecified, all table and/or additional tuple columns will be included. order string The order of the returned results. Can be either asc or desc. Default: asc format string If it is dump, the response will contain low level information that allows the data to be used to load the table (see below). Response The response will be a stream of individual table records or rows. When using Protobuf, every table record is delimited by its byte size. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf If non dump format is requested, response is of type: archive/archive.proto message TableData { message TableRecord { repeated ColumnData column = 1; } repeated TableRecord record = 1; } If format=dump parameter is used, the response is a series of Rows, each Row being composed of a list of Cells. Each row has an optional associated list of ColumnInfo messages that define the table columns conainted in the row. The message assigns an integer id for each column and the id is present in each cell belonging to that column (this is done in order to avoid sending the ColumnInfo with each Cell). The column id starts from 0 and are incremented with each new column found. The ids are only valid during one single dump. The dumped data does not contain information on any table characteristics such as (primary) key, partitioning or other storage options. table/table.proto message ColumnInfo { optional uint32 id = 1; optional string name = 2; //one of the types defined in org.yamcs.yarch.DataType //INT, STRING, DOUBLE, PROTOBUF(x.y.z), etc optional string type = 3; } message Cell { optional uint32 columnId = 1; optional bytes data = 2; } message Row { //the column info is only present for new columns in a stream of Row messages repeated ColumnInfo column = 1; repeated Cell cell = 2; } "},{"title":"Downloads","url":"/downloads/","body":" Yamcs Server v4.9.0 Linux x64 .rpm&nbsp;&nbsp; .tar.gz &nbsp; Yamcs Studio v1.2.1 (for Yamcs 4.7) Windows x64 Linux x64 macOS .rpm&nbsp;&nbsp; .tar.gz &nbsp; Linux Signing Key Yamcs RPM and Debian packages are signed with GNU Privacy Guard (GPG). Download: https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc Name: Yamcs Team Fingerprint: E74F A2E7 41D3 018E 5700 C729 16BF 99E3 A3B5 D542 &nbsp; Yum Repository RPM (RHEL, Fedora, CentOS) Packages suitable for x86_64 are available via a yum repository. The repository and key can be installed with the following script: sudo rpm --import https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc sudo sh -c 'echo -e \"[yamcs]\\nname=Yamcs\\nbaseurl=https://nexus.spaceapplications.com/repository/yamcs/rpm/stable/x86_64\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc\" &gt; /etc/yum.repos.d/yamcs.repo' RPM (SLE, openSUSE) Packages suitable for x86_64 are available via a zypper repository. The repository and key can be installed with the following script: sudo rpm --import https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc sudo sh -c 'echo -e \"[yamcs]\\nname=Yamcs\\nbaseurl=https://nexus.spaceapplications.com/repository/yamcs/rpm/stable/x86_64\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://nexus.spaceapplications.com/repository/yamcs/keys/yamcs.asc\" &gt; /etc/zypp/repos.d/yamcs.repo' "},{"title":"Edit Alarm","url":"/docs/http/Edit_Alarm/","body":"PATCH /api/processors/:instance/:processor/parameters/:namespace/:name/alarms/:seqnum Parameters Name Type Description state string Required. The state of the alarm. Either acknowledged or unacknowledged comment string Message documenting the alarm change. Example { \"state\": \"acknowledged\", \"comment\": \"bla bla\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditAlarmRequest { optional string state = 1; optional string comment = 2; } "},{"title":"Edit Client","url":"/docs/http/Edit_Client/","body":"Edit a client: PATCH /api/clients/:id Parameters Name Type Description instance string The instance. If unspecified, this defaults to the instance that the client is currently connected to. processor string The processor. If instance is provided and processor is not, then this will default to the default processor for that instance. Example Update the client’s processor to replay123: { \"processor\" : \"replay123\" } Later on, leave the replay and switch to the default processor (e.g. realtime) on the simulator instance: { \"instance\" : \"simulator\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditClientRequest { optional string instance = 1; optional string processor = 2; } "},{"title":"Edit Command Queue","url":"/docs/http/Edit_Command_Queue/","body":"Edit a command queue: PATCH /api/processors/:instance/:processor/cqueues/:name Parameters Name Type Description state string The state of the queue. Either enabled, disabled or blocked. The same parameters can also be specified in the request body. In case both query string parameters and body parameters are specified, they are merged with priority being given to query string parameters. Example Block a queue: { \"state\" : \"blocked\" } The response contains the updated queue information: Status: 200 OK { \"instance\" : \"simulator\", \"processorName\" : \"realtime\", \"name\" : \"default\", \"state\" : \"BLOCKED\", \"nbSentCommands\" : 0, \"nbRejectedCommands\" : 0 } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditCommandQueueRequest { optional string state = 1; } Response is of type: commanding/commanding.proto message CommandQueueInfo { required string instance = 1; required string processorName = 2; required string name = 3; optional QueueState state = 4; required int32 nbSentCommands = 5; required int32 nbRejectedCommands = 6; optional int32 stateExpirationTimeS = 7; repeated CommandQueueEntry entry = 8; } "},{"title":"Edit Link","url":"/docs/http/Edit_Link/","body":"Edit a link: PATCH /api/links/:instance/:name Parameters Name Type Description state string The state of the link. Either enabled or disabled. The same parameters can also be specified in the request body. In case both query string parameters and body parameters are specified, they are merged with priority being given to query string parameters. Example Enable a link: { \"state\" : \"enabled\" } Disable a link: { \"state\" : \"disabled\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditLinkRequest { optional string state = 1; } "},{"title":"Edit Processor","url":"/docs/http/Edit_Processor/","body":"Edit a processor: PATCH /api/processors/:instance/:name Only replay processors can be edited. Parameters Name Type Description state string The state this replay processor should be updated to. Either paused or running. seek string The time where the processing needs to jump towards. Must be a date string in ISO 8601 format. speed string The speed of the processor. One of: afap a speed factor relative to the original speed. Example: 2x a fixed delay value in milliseconds. Example: 2000 Example Pause the processor: { \"state\" : \"paused\" } Resume the processor, and set speed to 2.5x: { \"state\" : \"running\", \"speed\" : \"2.5x\" } Make processor move according to original speed: { \"speed\" : \"1x\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditProcessorRequest { optional string state = 1; optional string seek = 2; optional string speed = 3; } "},{"title":"Edit Queued Command","url":"/docs/http/Edit_Queued_Command/","body":"Edit a command queue entry: PATCH /api/processors/:instance/:processor/cqueues/:cqueue/entries/:uuid Parameters Name Type Description state string The state of the entry. Either released or rejected. The same parameters can also be specified in the request body. In case both query string parameters and body parameters are specified, they are merged with priority being given to query string parameters. Example Release an entry: { \"state\" : \"released\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditCommandQueueEntryRequest { optional string state = 1; } "},{"title":"Edit Service","url":"/docs/http/Edit_Service/","body":"Edit a global service: PATCH /api/services/_global/:name Edit a service for a specific Yamcs instance: PATCH /api/services/:instance/:name Name Type Description state string The state of the service. Either running or stopped. Note that once stopped, a service cannot be resumed. Instead a new service instance will be created and started. Example Start a service: { \"state\" : \"running\" } Stop a service: { \"state\" : \"stopped\" } "},{"title":"Edit Tag","url":"/docs/http/Edit_Tag/","body":"Edit a tag: PATCH /api/archive/:instance/tags/:start/:id Parameters Name Type Description name string The name of the tag. description string The description of the tag. start string The start time of the tag. Must be a date string in ISO 8601 format. Set to empty to indicate unbounded. stop string The stop time of the tag. Must be a date string in ISO 8601 format. Set to empty to indicate unbounded. color string The color of the tag. Must be an RGB hex color, e.g. #ff0000 The same parameters can also be specified in the request body. In case both query string parameters and body parameters are specified, they are merged with priority being given to query string parameters. Example Change the color, and the description: { \"color\" : \"#00ff00\", \"description\": \"an example description\" } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message EditTagRequest { optional string name = 1; optional string start = 2; optional string stop = 3; optional string description = 4; optional string color = 5; } "},{"title":"Editing Displays","url":"/docs/studio/Editing_Displays/","body":" "},{"title":"Editor Area","url":"/docs/studio/Editor_Area/","body":"The Editor Area is a unique zone in Yamcs Studio where files are opened for editing. Typically this would be a display file (*.opi), but it doesn’t have to be. OPI Files OPI stands for Operator Interface, but is more commonly referred to as a display. OPIs are often static, but when needed can be made very dynamic by combining different widgets and PVs together using concepts like Actions, Rules and Scripts. In the Display Builder window, create a new OPI file, right-click in the Explorer on the desired location, and select New &gt; OPI File. OPI files are created with some default properties, which includes a grid, and a size of 800x600. We will see in the section on Properties that we can edit these properties. Palette Notice the Palette attached to the right of the Editor Area. The Palette contains the widgets bundled with your version of Yamcs Studio. Use the palette as your toolbox when you author a display. To add a widget to your display, click first on its icon in the Palette, then click where you want to put it in the Editor Area. We select as example an LED. Once the widget has been placed, you can finetune its position and size using the Properties View. Some operations are also readily available in the Editor Area itself using familiar controls. For example, to enlarge a widget, select it, then drag its handles around with the mouse. You can also move a widget by pressing it, while dragging it to another location. To select multiple widgets, drag a box around them. To add widgets to an existing selection, hold the Ctrl key (⌘ on Mac) while selecting the widgets one by one. Remove a widget from the selection in similar fashion. Positioning Widgets The toolbar of Yamcs Studio contains tools that help us align multiple selected widgets. For example, clicking Align Left repositions these three LEDs to the leftmost position. There are similar tools for vertical alignments, as well as for distributing horizontal or vertical space between selected widgets. Match Size We can also standardize the size of selected widgets. For example. By clicking Match Width and Match Height in sequence, we made these three LEDs the same size. The size of the last selected widget is taken as the reference. This reference widget is highlighted with black instead of white anchor points. Note that in this particular case of non-square LEDs, clicking only Match Width would actually have been sufficient since round LEDs can’t take on the shape of an ellipse. "},{"title":"Empty Node","url":"/docs/server/Empty_Node/","body":"This “loader” allows to create an empty node (SpaceSystem) with a given name. The loader has been added in version 4.8.2 of Yamcs. For example this configuration will create two parallel nodes “/N1” and “/N2” and underneath each of them, load the xls files of the simulator. mdb: - type: \"emptyNode\" spec: \"N1\" subLoaders: - type: \"sheet\" spec: \"mdb/simulator-ccsds.xls\" subLoaders: - type: \"sheet\" spec: \"mdb/landing.xls\" - type: \"emptyNode\" spec: \"N2\" subLoaders: - type: \"sheet\" spec: \"mdb/simulator-ccsds.xls\" subLoaders: - type: \"sheet\" spec: \"mdb/landing.xls\" "},{"title":"Event Log","url":"/docs/studio/Event_Log/","body":"The Event Log view displays events from Yamcs Server. This could be on-board events, or events generated by Yamcs itself, whenever something significant occurs. To load events for an earlier time range, select Import. Clear your view by clicking Clear. You can always re-import events again at a later moment. When Yamcs Studio becomes aware of a new event, it will automatically select and reveal it. You can prevent this default behaviour by toggling the Scroll Lock. "},{"title":"Event Recorder","url":"/docs/server/Event_Recorder/","body":"Records events. This service stores the data coming from one or more streams into a table events. Class Name org.yamcs.archive.EventRecorder Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.EventRecorder streamConfig: event: - events_realtime - events_dump With this configuration events emitted to the events_realtime or events_dump stream are stored into the table events. "},{"title":"Event Updates","url":"/docs/http/Event_Updates/","body":"The events resource type within the WebSocket API allows subscribing to event updates. Subscribe Within the WebSocket request envelope use these values: request-type events request subscribe This will make your web socket connection receive updates of the type ProtoDataType.EVENT. Here’s example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData). [1,2,3] [1,4,0,{\"dt\":\"EVENT\",\"data\":{\"source\":\"CustomAlgorithm\",\"generationTime\":1440823760490,\"receptionTime\":1440823760490,\"seqNumber\":325,\"type\":\"bla\",\"message\":\"uhuh0.4890178832134868\",\"severity\":0}}] [1,4,1,{\"dt\":\"EVENT\",\"data\":{\"source\":\"CustomAlgorithm\",\"generationTime\":1440823765491,\"receptionTime\":1440823765491,\"seqNumber\":326,\"type\":\"bla\",\"message\":\"uhuh0.29612159559494056\",\"severity\":0}}] [1,4,2,{\"dt\":\"EVENT\",\"data\":{\"source\":\"CustomAlgorithm\",\"generationTime\":1440823770490,\"receptionTime\":1440823770490,\"seqNumber\":327,\"type\":\"bla\",\"message\":\"uhuh0.7098682009567915\",\"severity\":0}}] Unsubscribe Within the WebSocket request envelope use these values: request-type events request unsubscribe This will stop your WebSocket connection from getting further event updates. "},{"title":"Events","url":"/docs/http/Events/","body":" "},{"title":"Excel Specification","url":"/docs/server/Excel_Specification/","body":"Yamcs offers various ways of defining TM packets, parameters, commands and other mission items. The recommended way is to use a spreadsheet. This offers a good mixture between easy user manipulation and flexibility. This section explains the general and structural conventions that apply when defining a space system using Excel. Multiple Space Systems support Conventions Rules for parameter/conainer reference lookup General Sheet Containers Sheet Parameters Sheet Encoding and Raw Types Engineering Types Calibration Sheet Java Expressions Algorithms Sheet JavaScript algorithms Python algorithms Java algorithms Command verifier algorithms Data Decoding algorithms Example Definition Example Definition for a command verifier algorithm Alarms Sheet Example Definition Commands Sheet Encoding and Raw Types for command arguments Command Options Sheet Command Verification Sheet Change Log Sheet Multiple Space Systems support Since version 5.4, the spreadsheet definition supports loading from one Excel file a hierarchy composed of multiple space systems. Until version 5.3 this was only possible by defining multiple Excel files (one per subsystem) and defining the hierarchy in etc/mdb.yaml. Also until version 5.3 the loader forced some sheets to always be present (e.g. Containers). From version 5.4 only the General sheet has to be present, all the other ones are optional. To define the space system hierarchy, the convention is that all the sheets that do not have a prefix contain data for the main space system whose name is defined in the General sheet. To define data in subsystems, a syntax like SYSTEM1|SYSTEM2|Containers can be used. This definition will create a SYSTEM1 as part of the main space system and a child SYSTEM2 of SYSTEM1. Then the containers will be loaded in SYSTEM2. The spreadsheet loader scans and creates the subsystem hierarchy and then it loads the data inside the systems traversing the hierarchy in a depht-first order. Conventions All numeric values can be entered as decimals or as hexadecimals (with prefix 0x) Although column names are used for reference below, columns must not be reordered A number of mandatory named sheets are described as part of this specification, though authors may add their own sheets and still use the spreadsheet file as the reference MDB. Rules for parameter/conainer reference lookup Each time a name reference is mentioned in the spreadsheet, the following rules apply: The reference can use UNIX like directory access expressions (../a/b). If the name is not found as a qualified parameter, and the option enableAliasReferences is configured for the SpreadsheetLoader, the parameter is looked up through all the aliases of the parent systems. The exact result of the lookup depends of course on the exact tree configuration in mdb.yaml” General Sheet This sheet must be named “General”, and the columns described must not be reordered. format version Used by the loader to ensure a compatible spreadsheet structure name Name of the MDB document version Used by the author to track versions in an arbitrary manner Containers Sheet This sheet must be named “Containers”, and the columns described must not be reordered. The sheet contains description of the content of the container (packet). As per XTCE, a container is a structure describing a binary chunk of data composed of multiple entries. A container can inherit from other container - meaning that it takes all entries from the parent and it adds some more. It can have two types of entries: parameters other containers (this is called aggregation) General conventions: first line with a new ‘container name’ starts a new packet second line after a new ‘container name’ should contain the first measurement empty lines are only allowed between two packets Comment lines starting with “#” on the first column can appear everywhere and are ignored. container name The relative name of the packet inside the space system parent Parent container and position in bits where the subcontainer starts, for example PARENT_CONTAINER:64. If position in bits is not specified, the default position is to start from the last parameter in the parent. If parent is not specified, either the container is the root, or it can be used as part of another container in aggregation. condition Inheritance condition, usually specifies a switch within the parent which activates this child, for example `MID=0x101` There are currently three forms supported: Simple condition: Parameter==value Condition list: Parameter==value;Parameter2==value2 - all conditions must be true Boolean condition: op(epx1;exp2;...;expn) op is '&amp;' (AND) or '|' (OR) expi is a boolean expression or a simple condition Currently the only supported conditions are on the parameters of the parent container. This cover the usual case where the parent defines a header and the inheritance condition is based on paraemters from the header. Parameters Sheet This sheet must be named ending with “Parameters”, and the columns described must not be reordered. The sheet contains parameter (sometimes called measurements) information. Any number of sheets ending with “Parameters” can be present and they all have the same structure. Each parameter has a so called “DataSource” (as per XTCE) which is not immediately configured. However by historical convention: DerivedParameters contains all parameter whose data source is set to \"DERIVED\" - these are usually results of algorithm computations. LocalParameters contains all parameters whose data source is set to \"LOCAL\" - these are parameters that can be set by the user using the Yamcs API All other parameter sheets contain parameters whose data source is set to \"TELEMETERED\" - these are parameters received from remote devices A parameter when extracted from a binary packet has two forms: a raw value and an engineering value. The extraction from the raw packet is performed according to the encoding, whereas the conversion from raw to engineering value is performed by a calibrator. This sheet can also be used to specify parameters without encoding - if they are received already extracted, Yamcs can do only their calibration. Or it can be that a parameter is already calibrated, it can still be specified here to be able to associate alarms. Empty lines can appear everywhere and are ignored. Comment lines starting with “#” on the first column can appear everywhere and are ignored. name The name of the parameter in the namespace. encoding Description on how to extract the raw type from the binary packet. See below for all supported encodings. raw type See below for all supported raw types eng type See Engineering Types eng unit Free-form textual description of unit(s). E.g. degC, W, V, A, s, us calibration Name of a calibration described in the Calibration sheet, leave empty if no calibration is applied description Optional human-readable text namespace:&lt;NS-NAME&gt; If present, these columns can be used to assign additional names to the parameters in the namespace NS-NAME. Any number of columns can be present to give additional names in different namespaces. Encoding and Raw Types Raw types describe how the parameter is encoded in the raw packet. All types are case-insensitive. Raw Type Encoding Description uint unsigned(&lt;n&amp;gt,&lt;BE|LE&gt;) Unsigned integer. n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for unsigned(&lt;n&gt;,BE) int twosComplement(&lt;n&gt;, &lt;BE|LE&gt;) two's complement encoding n is size in bits. LE = little endian, BE = big endian. signMagnitude(&lt;n&gt;, &lt;BE|LE&gt;) sign magnitude encoding - first (or last for LE) bit is the sign, the remaining bits represent the magnitude (absolute value). n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for twosComplement(&lt;n&gt;,BE) float ieee754_1985(&lt;n&gt;, &lt;BE|LE&gt;) IEE754_1985 encoding n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for iee754_1985(&lt;n&gt;,BE) boolean &lt;empty&gt; the encoding has to be empty - 1 bit is assumed. string fixed(&lt;n&gt;, &lt;charset&gt;) fixed size string n is the size in bits of the string. Only multiple of 8 supported. charset is one of the charsets supported by java (UTF-8, ISO-8859-1, etc). If not specified, it is by default UTF-8 The string has to start at a byte boundary inside the container. PrependedSize(&lt;x&gt;, &lt;charset&gt;) The size of string in bytes is specified in first x bits of string - the size itself will not be part of the string. x is the size in bits of the size tag charset is as defined above. Note that while x can be any number of bits&lt;=32, the string has to start at a byte boundary. terminated(&lt;0xBB&gt;, &lt;charset&gt;) terminated string - pay attention to the parameters following this one; if the terminator is not found all the buffer will be consumed; 0xBB specifies a byte that is the string terminator charset is as defined above. binary fixed(&lt;n&gt;) fixed size byte array. n size of the array in bits. It has to be multiple of 8 and the parameter has to start at a byte boundary. PrependedSize(&lt;x&gt;) byte array whose size in bytes is specified in the first x bits of the array - the size itself will not be part of the raw value. x is the size in bits of the size tag Note that while x can be any number of bits&lt;=32, the byte array has to start at a byte boundary. &lt;n&gt; shortcut for fixed(&lt;n&gt;) &lt;any of the above&gt; custom(&lt;n&gt;,algorithm) The decoding will be performed by a user defined algorithm. &lt;n&gt; is optional and may be used to specify the size in bits of the entry in the container (in case the size is fixed) - it will use for optimizing the access to the parameters following this one. algorithm the name of the algorithm - it has to be defined in the algorithm sheet Engineering Types Engineering types describe a parameter in its processed form (i.e. after any calibrations). All types are case-insensitive. Depending on the combination of raw and engineering type, automatic conversion is applicable. For more advanced use cases, define and refer to a Calibrator in the Calibration Sheet Type Description Automatic Raw Conversion uint Unsigned 32 bit integer - it corresponds to int in java and uint32 in protobuf From int, uint or string uint64 Unsigned 64 bit integer - it corresponds to long in java and uint64 in protobuf From int, uint or string int Signed 32 bit integer - it corresponds to int in java and int32 in protobuf From int, uint or string int64 Signed 64 bit integer - it corresponds to long in java and int64 in protobuf From int, uint or string string Character string - it corresponds to String in java and string in protobuf From string float 32 bit floating point number - it corresponds to float in java and protobuf From float, int, uint or string double 62 bit floating point number - it corresponds to double in java and protobuf From float, int, uint or string enumerated A kind of string that can only be one out of a fixed set of predefined state values. It corrersponds to String in java and string in protobuf. From int or uint. A Calibrator is required. boolean A binary true/false value - it corresponds to 'boolean' in java and 'bool' in protobuf From any raw type Values equal to zero, all-zero bytes or an empty string are considered false binary Byte array - it corresponds to byte[] in java and bytes in protobuf. From bytestream only Calibration Sheet This sheet must be named “Calibration”, and the columns described must not be reordered. The sheet contains calibration data including enumerations. calibrator name Name of the calibration - it has to match the calibration column in the Parameter sheet. type One of the following: polynomial for polynomial calibration. Note that the polynomial calibration is performed with double precision floating point numbers even though the input and/or output may be 32 bit. spline for linear spline(pointpair) interpolation. As for the polynomial, the computation is performed with double precision numbers. enumeration for mapping enumeration states java-expression for writing more complex functions calib1 If the type is polynomial: it list the coefficients, one per row starting with the constant and up to the highest grade. There is no limit in the number of coefficients (i.e. order of polynomial). If the type is spline: start point (x from (x,y) pair) If the type is enumeration: numeric value If the type is java-expression: the textual formula to be executed (see below) calib2 If the type is polynomial: leave empty If the type is spline: stop point (y) corresponding to the start point(x) in calib1 If the type is enumeration: text state corresponding to the numeric value in calib1 If the type is java-expression: leave empty Java Expressions This is intended as a catch-all case. XTCE specifies a MathOperationCalibration calibrator that is not implemented in Yamcs. However these expressions can be used for the same purpose. They can be used for float or integer calibrations. The expression appearing in the calib1 column will be enclosed and compiled into a class like this: package org.yamcs.xtceproc.jecf; public class Expression665372494 implements org.yamcs.xtceproc.CalibratorProc { public double calibrate(double rv) { return &lt;expression&gt;; } } The expression has usually to return a double; but java will convert implicitly any other primitive type to a double. Java statements cannot be used but the conditional operator “? :” can be used; for example this expression would compile fine: rv&gt;0?rv+5:rv-5 Static functions can be also referenced. In addition to the usual Java ones (e.g. Math.sin, Math.log, etc) user own functions (that can be found as part of a jar on the server in the lib/ext directory) can be referenced by specifying the full class name: my.very.complicated.calibrator.Execute(rv) Algorithms Sheet This sheet must be named “Algorithms”, and the columns described must not be reordered. The sheet contains arbitrarily complex user algorithms that can set (derived) output parameters based on any number of input parameters. Comment lines starting with “#” on the first column can appear everywhere and are ignored. Empty lines are used to separate algorithms and cannot be used inside the specification of one algorithm. algorithm name The identifying name of the algorithm. algorithm language The programming language of the algorithm. Currently supported values are: JavaScript python - note that this requires the presence of jython.jar in the Yamcs lib or lib/ext directory (it is not delivered together with Yamcs). Java text The code of the algorithm (see below for how this is interpreted). trigger Optionally specify when the algorithm should trigger: OnParameterUpdate('/some-param', 'some-other-param')Execute the algorithm whenever any of the specified parameters are updated OnInputParameterUpdateThis is the same as above for all input parameters (i.e. execute whenever any input parameter is updated). OnPeriodicRate(&lt;fireRate&gt;)Execute the algorithm every fireRate milliseconds noneThe algorithm doesn't trigger automatically but can be called upon from other parts of the system (like the command verifier) The default is none. in/out Whether a parameter is inputted to, or outputted from the algorithm. Parameters are defined, one per line, following the line defining the algorithm name parameter reference Reference name of a parameter. See above on how this reference is resolved. Algorithms can be interdependent, meaning that the output parameters of one algorithm could be used as input parameters of another algorithm. instance Allows inputting a specific instance of a parameter. At this stage, only values smaller than or equal to zero are allowed. A negative value, means going back in time. Zero is the default and means the actual value. This functionality allows for time-based window operations over multiple packets. Algorithms with windowed parameters will only trigger as soon as all of those parameters have all instances defined (i.e. when the windows are full). Note that this column should be left empty for output parameters. name used in the algorithm An optional friendlier name for use in the algorithm. By default the parameter name will be used, which may lead to runtime errors depending on the naming conventions of the applicable script language. Note that a unique name will be required in this column, when multiple instances of the same parameter are inputted. JavaScript algorithms A full function body is expected. The body will be encapsulated in a javascript function like function algorithm_name(in_1, in_2, ..., out_1, out_2...) { &lt;algorithm-text&gt; } The in_n and outX are to be names given in the spreadsheet column name used in the algorithm. The method can make use of the input variables and assign out_x.value (this is the engineering value) or out_x.rawValue (this is the raw value) and out_x.updated for each output variable. The .updated can be set to false to indicate that the output value has not to be further processed even if the algorithm has run. By default it is true - meaning that each time the algorithm is run, it is assumed that it updates all the output variables. If out_x.rawValue is set and out_x.value is not, then Yamcs will run a calibration to compute the engineering value. Note that for some algorithms (e.g. command verifiers) need to return a value (rather Python algorithms This works very similarly with the JavaScript algorithms, The thing to pay attention is the indentation. The algorithm text wihch is specified in the spreadsheet will be automatically indeted with 4 characters. function algorithm_name(in_1, in_2, ..., out_1, out_2...) { &lt;algorithm-text&gt; } Java algorithms The algorithm text is a class name with optionally parantheses enclosed string that is parsed into an object by an yaml parser. Yamcs will try to locate the given class who must be implementing the org.yamcs.algorithms.AlgorithmExecutor interface and will create an object with a constructor with three paramethers: &lt;Constructor&gt;(Algorithm, AlgorithmExecutionContext, Object arg) where arg is the argument parsed from the yaml. If the optional argument is not present in the algorithm text definition, then the class constructor should only have two parameters. The abstract class org.yamcs.algorithms.AbstractAlgorithmExecutor offers some helper methods and can be used as base class for implementation of such algorithm. If the algorithm is used for data decoding, it has to implement the org.yamcs.xtceproc.DataDecoder interface instead (see below). Command verifier algorithms Command verifier algorithms are special algorithms associated to the command verifiers. Multiple instances of the same algorithm may execute in parallel if there are multiple pending commands executed in parallel. These algorithms are special as they can use as input variables not only parameters but also command arguments and command history events. These are specified by using “/yamcs/cmd/arg/” and “/yamcs/cmdHist” prefix respectively. In addition these algorithms may return a boolean value (whereas the normal algorithms only have to write to output variables). The returned value is used to indicate if the verifier has succeeded or failed. No return value will mean that the verifier is still pending. Data Decoding algorithms The Data Decoding algorithms are used to extract a raw value from a binary buffer. These algorithms do not produce any output and are triggered whenever the parameter has to be extracted from a container. These algorithms work differently from the other ones and have are some limitations: only Java is supported as a language not possible to specify input parameters These algorithms have to implement the interface org.yamcs.xtceproc.DataDecoder. Example Definition algo name language text trigger in/out param name instance friendlyname my_avg JavaScript r.value = (a.value + b.value + c.value) / 3; OnInputParameterUpdate in /MY_SS/some_temperature -2 a in /MY_SS/some_temperature -1 b in /MY_SS/some_temperature 0 c out /MY_SS/avg_out r Example Definition for a command verifier algorithm algo name language text trigger in/out param name instance friendlyname alg_verif_completed JavaScript if((receivedCmdId.value==sentCmdId.value) &amp;&amp; (receivedSeqNum.value==sentSeqNum.value) &amp;&amp; (stage.value==2) ) { if(result.value==0) return true; else return false;} in /yamcs/cmd/arg/packet-id sentCmdId in /yamcs/cmdHist/ccsds-seqcount sentSeqNum in avc_command_seq receivedSeqNum in avc_command_id receivedCmdId in avc_command_execution_stage stage in avc_command_result result Alarms Sheet This sheet must be named “Alarms”, and the columns described must not be reordered. The sheet defines how the monitoring results of a parameter should be derived. E.g. if a parameter exceeds some pre-defined value, this parameter’s state changes to CRITICAL. parameter name The reference name of the parameter for which this alarm definition applies context A condition under which the defined triggers apply. This can be used to define multiple different sets of triggers for one and the same parameter, that apply depending on some other condition (typically a state of some kind). When left blank, the defined set of conditions are assumed to be part of the default context. Contextual alarms are evaluated from top to bottom, until a match is found. If no context conditions apply, the default context applies. report When alarms under the given context should be reported. Should be one of OnSeverityChange or OnValueChange. With OnSeverityChange being the default. The condition OnValueChange will check value changes based on the engineering values. It can also be applied to a parameter without any defined severity levels, in which case an event will be generated with every change in value. minimum violations Number of successive instances that meet any of the alarm conditions under the given context before the alarm event triggers (defaults to 1). This field affects when an event is generated (i.e. only after X violations). It does not affect the monitoring result associated with each parameter. That would still be out of limits, even after a first violation. watch: trigger type One of low, high or state. For each context of a numeric parameter, you can have both a low and a high trigger that lead to the WATCH state. For each context of an enumerated parameter, you can have multiple state triggers that lead to the WATCH state. watch: trigger value If the trigger type is low or high: a numeric value indicating the low resp. high limit value. The value is considered inclusive with respect to its nominal range. For example, a low limit of 20, will have a WATCH alarm if and only if its value is smaller than 20. If the trigger value is state: a state that would bring the given parameter in its WATCH state. warning: trigger typewarning: trigger value Analogous to watch condition distress: trigger typedistress: trigger value Analogous to watch condition critical: trigger typecritical: trigger value Analogous to watch condition severe: trigger typesevere: trigger value Analogous to watch condition Example Definition param name context rep min.v watch warning distress critical severe type val type val type val type val type val int_para low -11 low -22 low -33 high 30 high 40 high 50 high 60 high 70 &nbsp; other_para = 4 3 high 40 high 50 high 70 &nbsp; enum_para state ST1 state ST2 state ST4 state ST3 Commands Sheet This sheet must be named “Commands”, and the columns described must not be reordered. The sheet contains commands description, including arguments. General convention: First line with a new ‘Command name’ starts a new command Second line after a new ‘Command name’ should contain the first command arguments Empty lines are only allowed between two commands. Command name The name of the command. Any entry starting with `#` is treated as a comment row parent name of the parent command if any. Can be specified starting with / for an absolute reference or with ../ for pointing to parent SpaceSystem :x means that the arguments in this container start at position x (in bits) relative to the topmost container. Currently there is a problem for containers that have no argument: the bit position does not apply to children and has to be repeated. argAssignment name1=value1;name2=value2.. where name1,name2.. are the names of arguments which are assigned when the inheritance takes place flags For commands: A=abstract. For arguments: L = little endian argument name From this column on, most of the cells are valid for arguments only. These have to be defined on a new row after the command. The exceptions are: description, aliases relpos Relative position to the previous argument default is 0 encoding How to convert the raw value to binary. The supported encodings are listed in the table below. eng type Dngineering type; can be one of: uint, int, float, string, binary, enumerated, boolean or FixedValue. FixedValue is like binary but is not considered an argument but just a value to fill in the packet. raw type Raw type: one of the types defined in the table below. (default) value Default value. If eng type is FixedValue, this has to contain the value in hexadecimal. Note that when the size of the argument is not an integer number of bytes (which is how hexadecimal binary strings are specified), the most significant bits are ignored. eng unit calibration Point to a calibration from the Calibration sheet range low The value of the argument cannot be smaller than this. For strings and binary arguments this means the minimum length in characters, respectively bytes. range high The value of the argument cannot be higher than this. Only applies to numbers. For strings and binary arguments this means the minimum length in characters, respectively bytes. description Optional free text description Encoding and Raw Types for command arguments The raw type and encoding describe how the argument is encoded in the binary packet. All types are case-insensitive. Raw Type Encoding Description uint unsigned(&lt;n&amp;gt,&lt;BE|LE&gt;) Unsigned integer. n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for unsigned(&lt;n&gt;,BE) int twosComplement(&lt;n&gt;, &lt;BE|LE&gt;) two's complement encoding n is size in bits. LE = little endian, BE = big endian. signMagnitude(&lt;n&gt;, &lt;BE|LE&gt;) sign magnitude encoding - first (or last for LE) bit is the sign, the remaining bits represent the magnitude (absolute value). n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for twosComplement(&lt;n&gt;,BE) float ieee754_1985(&lt;n&gt;, &lt;BE|LE&gt;) IEE754_1985 encoding n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for iee754_1985(&lt;n&gt;,BE) boolean &lt;empty&gt; the encoding has to be empty - 1 bit is assumed. string fixed(&lt;n&gt;, &lt;charset&gt;) fixed size string n is the size in bits of the string. Only multiple of 8 supported. charset is one of the charsets supported by java (UTF-8, ISO-8859-1, etc). If not specified, it is by default UTF-8 PrependedSize(&lt;x&gt;, &lt;charset&gt;&lt;m;&amp;gt) The size of string in bytes is specified in first x bits of string - the size itself will not be part of the string. x is the size in bits of the size tag charset is as defined above. m if specified, it is the minimum size in bits of the encoded value. Note that the prepended size reflects the real size of the string even if smaller than this minimum size. This option has been added for compatibility with the Airbus CGS system but its usage is discouraged since it is not compliant with XTCE. &lt;n&gt; shortcut for fixed(&lt;n&gt;) terminated(&lt;0xBB&gt;, &lt;charset&gt;&lt;m;&amp;gt) terminated string; 0xBB specifies a byte that is the string terminator charset is as defined above. m if specified is the minimum size in bits of the encoded value. Note that the termination character reflects the real size of the string even if smaller than this minimum size. This option has been added for compatibility with the Airbus CGS system but its usage is discouraged since it is not compliant with XTCE. binary fixed(&lt;n&gt;) fixed size byte array. n size of the array in bits. It has to be multiple of 8 and the argument has to start at a byte boundary. PrependedSize(&lt;x&gt;) byte array whose size in bytes is specified in the first x bits of the array - the size itself will not be part of the raw value. x is the size in bits of the size tag Note that while x can be any number of bits&lt;=32, the byte array has to start at a byte boundary. &lt;n&gt; shortcut for fixed(&lt;n&gt;) Command Options Sheet This sheet must be named “CommandOptions”, and the columns described must not be reordered. This sheet defines two types of options for commands: transmission constraints - these are conditions that have to be met in order for the command to be sent. command significance - this is meant to flag commands that have a certain significance. Currently the significance is only used by the end user applications (e.g. Yamcs Studio) to raise the awarness of the operator when sending such command. Command nameThe name of the command. Any entry starting with `#` is treated as a comment row Transmission ConstraintsConstrains can be specified on multiple lines. All of them have to be met for the command to be allowed for transmission. Constraint TimeoutThis refers to the left column. A command stays in the queue for that many milliseconds. If the constraint is not met, the command is rejected. 0 means that the command is rejected even before being added to the queue, if the constraint is not met. Command SignificanceSignificance level for commands. Depending on the configuration, an extra confirmation or certain privileges may be required to send commands of high significance. one of: - none - watch - warning - distress - critical - severe Significance ReasonA message that will be presented to the user explaining why the command is significant. Command Verification Sheet The Command verification sheets defines how a command shall be verified once it has been sent for execution. The transmission/execution of a command usual goes through multiple stages and a verifier can be associated to each stage. Each verifier runs within a defined time window which can be relative to the release of the command or to the completion of the previous verifier. The verifiers have three possible outcomes: OK = the stage has been passed successfully. NOK = the stage verification has failed (for example there was an error on-board when executing the command, or the uplink was not activated). timeout - the condition could not be verified within the defined time interval. For each verifier it has to be defined what happens for each of the three outputs. Command name The command relative name as defined in the Command sheet. Referencing commands from other subsystems is not supported. CmdVerifier Stage Any name for a stage is accepted but XTCE defines the following ones: TransferredToRange SentFromRange Received Accepted Queued Execution Complete Failed Yamcs interprets these as strings without any special semantics. If special actions (like declaring the command as completed) are required for Complete or Failed, they have to be configured in OnuSccess/OnFail/OnTimeout columns. By default command history events with the name Verification_&lt;stage&gt; are generated.\" CmdVerifier Type Supported types are: container – the command is considered verified when the container is received. Note that this cannot generate a Fail (NOK) condition - it's either OK if the container is received in the timewindow or timeout if the container is not received. algorithm – the result of the algorithm run is used as the output of the verifier. If the algorithm is not run (because it gets no inputs) or returns null, then the timeout condition applies CmdVerifier Text Depending on the type: container: is the name of the container from the Containers sheet. Reference to containers from other space systems is not supported. algorithm: is the name of the algorithm from the Algorithms sheet. Reference to algorithms from other space systems is not supported. Time Check Window start,stop in milliseconds defines when the verifier starts checking the command and when it stops. checkWindow is relative to LastVerifier (default) – the start,stop in the window definition are relative to the end of the previous verifier. If there is no previous verifier, the start,stop are relative to the command release time. If the previous verifier ends with timeout, this verifier will also timeout without checking anything. CommandRelease - the start,stop in the window definition are relative to the command release. OnSuccess Defines what happens when the verification returns true. It has to be one of: SUCCESS: command considered completed successful (CommandComplete event is generated) FAIL: CommandFailed event is generated none (default) – only a Verification_stage event is generated without an effect on the final execution status of the command. OnFail Same like OnSuccess but the evnet is generated in case the verifier returns false. OnTimeout Same as OnSuccess but the event is generated in case the verifier times out. Change Log Sheet This sheet must be named “ChangeLog”, and the columns described must not be reordered. This sheet contains the list of the revision made to the MDB. "},{"title":"Explorer","url":"/docs/studio/Explorer/","body":"The Explorer tab shows a folder-like structure of the resources contained within your current workspace. Projects Recall that within Yamcs Studio, you are always working in one workspace only. Within that workspace you create or import projects. It is the projects that contain the actual resources (files and/or directories). Creating a Project To create a new project, choose File &gt; New Project, or right-click in the explorer and choose New Project from the pop-up menu. Importing Existing Projects To import an existing project, select File &gt; Import and choose Existing Projects into Workspace. Navigate to the project’s folder, and if Yamcs Studio recognizes it as a project you will be able to import it. Projects are just directories on your disk (usually under version control). Yamcs Studio recognizes existing projects by the metadata which is added under the hidden .metadata folder. This metadata includes project-specific preferences, as well as for example the name of the project. Resources Any file can be added to a project or a contained directory. To do so right-click on the desired node to open the popup menu, and choose your desired file type under the New item. To add an existing file to a project (for example a project). Copy it to your clipboard, and paste it onto the node. Alternatively, use the File &gt; Import &gt; General &gt; File System option. Open a file by double-clicking on it. If you open a file, yet Yamcs Studio does not have a specific handler for the type of file, it will open it with your system default program for that extension. The default Yamcs Studio distribution handles *.def and *.opi files. It also comes with a built-in text editor for basic editing of many other types of files as well (including *.txt, *.js and *.py). Use right-click Open With for more control over how the file is to be opened. Searching An advanced search and replace dialog is available from the Search menu. If you select a node in the explorer before opening the Search dialog, this dialog will be configured to only search resources under that node. Your search can include wildcard characters, and can be further specified to only a specific set of resources. The results will be opened in a Search view which also allows for replacing occurrences upon right-click. "},{"title":"File Polling TM Data Link","url":"/docs/server/File_Polling_TM_Data_Link/","body":"Reads data from files in a directory, importing it into the configured stream. The directory is polled regularly for new files and the files are imported one by one. After the import, the file is removed. Class Name org.yamcs.tctm.FilePollingTmDataLink Configuration Options Name Type Description stream string Required. The stream where data is emitted incomingDir string The directory where the data will be read from. If not specified, the data will be read from &lt;yamcs-incoming-dir&gt;/&lt;instance&gt;/tm/ where yamcs-incoming-dir is the value of the incomingDir property in etc/yamcs.yaml. deleteAfterImport boolean Remove the file after importing all the data. By default set to true, can be set to false to import the same data again and again. delayBetweenPackets integer When importing a file, wait this many milliseconds after each packet. This option together with the previous one can be used to simulate incoming realtime data. packetPreprocessorClassName string Class name of a PacketPreprocessor implementation. Default is org.yamcs.tctm.IssPacketPreprocessor which applies ISS conventions. packetPreprocessorArgs map Optional args of arbitrary complexity to pass to the PacketPreprocessor. Each PacketPreprocessor may support different options. "},{"title":"First Steps","url":"/docs/studio/First_Steps/","body":"Launching Yamcs Studio When you launch Yamcs Studio for the first time it will ask you to choose a workspace. A workspace is where you store your resources (e.g. a display file). With Yamcs Studio, you are always working on one workspace at a time. Usually workspaces are fairly static, and you can often do with just one of them. Choose your preferred location, and click OK. Empty Workspace Yamcs Studio is now launched and you should see an empty workspace with the default window arrangement: The empty area in the middle is where displays will open. Yamcs Studio has two different windows. Display Builder and Display Runner. When Yamcs Studio is launched for the first time on a new workspace the user will be welcomed with the default Display Builder window. "},{"title":"Fundamentals","url":"/docs/server/Fundamentals/","body":"Mission Database The Mission Database is a dictionary containing the description of all the telemetry packets, parameters and commands. Yamcs implements concepts from the XTCE standard (XML Telemetric &amp; Command Exchange). Although this standard specifies how to describe a mission database in XML, it also prescribes a series of building blocks for such a database: SpaceSystens, containers, parameters, commands, algorithms, etc. In Yamcs we do not have as a primary goal the compliance with the XML representation (although Yamcs does have an XTCE XML loader) but more to the structure and the concepts of an XTCE database. In fact the primary representation for the mission database in Yamcs is an excel spreadsheet because we noticed that many operators prefer to work with such tool. It is however possible to create database loaders for different formats and it has been done many times in order to be interoperable with other tools (integration is key aspect of Yamcs). Note: XTCE is a standard created by many space agencies and thus it contains quite a wide range of features. The standard is also evolving with version 1.2 (not yet public) having many changes from version 1.1. Yamcs does not implement completely the standard, thus we cannot state compliance with a particular version. Instances The Yamcs instances provide means for one Yamcs server to monitor/control different payloads or sattelites or version of the payloads or satellites at the same time. Each instance has a name and a directory where all data from that instance is stored, as well as a specific Mission Database used to process data for that instance. Therefore, each time the Mission Database changes (e.g. due to an on-board software upgrade), a new instance has to be created. One strategy to deal with long duration missions which require multiple instances, is to put the old instances in readonly mode by disabling the components that inject data. Streams The concept of streams was inspired from the domain of Complex Event Processing (CEP) or Stream Processing. Streams are similar to database tables, but represent continuously moving data. SQL-like statements can be defined on streams for filtering, aggregation, merging or other operations. Yamcs uses streams for distributing data between all components running inside the same JVM. Typically there is a stream for realtime telemetry called tm_realtime, one for realtime processed parameters called pp_realtime, one for commands called tc, etc. Streams can be made ‘visible’ to the external word by two means: Apache ActiveMQ Artemis wrappers. There are several services that can take data from streams and publish them to Artemis addresses. Unlike the Yamcs streams which are synchronous and lightweight, Artemis addresses are asynchronous and involve more overhead. Care has to be taken with Artemis for not filling up the memory if clients are slow to read messages from the queue. WebSocket subscription. This can be done using the HTTP API documented separately at https://www.yamcs.org/docs/http/. Processors Yamcs processes TM/TC according to Mission Database definitions. Yamcs supports concurrent processing of parallel streams; one processing context is called Processor. Processors have clients that receive TM and send TC. Typically one Yamcs instance contains one realtime processor processing data coming in realtime and on-request replay processors, processing data from the archive. Internally, Yamcs creates a replay processors for tasks like filling up the parameter archive. Processor Clients are TM monitoring and/or TC commanding applications (Yamcs Studio, USS, MCS Tools). Data Links Data Links represent special components that communicate with the external world. There are three types of Data Links: TM, TC and PP (processed parameters). TM and PP receive telemetry packets or parameters and inject them into the realtime or dump TM or PP streams. The TC data links subscribe to the realtime TC stream and send data to the external systems. Data Links can report on their status and can also be controlled by an operator to connect or disconnect from their data source. Data Types Yamcs supports the following high-level data types: A parameter is a data value corresponding to the observed value of a certain device. Parameters have different properties like Raw Value, Engineering Value, Monitoring status and Validity status. Currently the raw and engineering values must be of scalar types (i.e int, float, string, etc), however in the future arrays and aggregated parameters (analogous to structs in C programming language) will be supported. A processed parameter (abbreviated PP) is a particular type of parameter that is processed by an external (to Yamcs) entity. Yamcs does not contain information about how they are processed. The processed parameters have to be converted into Yamcs internal format (and therefore compatible with the Yamcs parameter types) in order to be propagated to the monitoring clients. A telemetry packet is a binary chunk of data containing a number of parameters in raw format. The packets are split into parameters according to the definitions contained in the Mission Database. (Tele)commands are used to control remote devices and are composed of a name and a list of arguments. The commands are transformed into binary packets according to the definition in the Mission Database. An event is a data type containing a source, type, level and message used by the payload to log certain kind of events. Yamcs generates internally a number of events. In order to extract events from telemetry, a special component called Event Decoder has to be written. The high-level data types described above are modelled internally on a data structure called tuple. A tuple is a list of (name, value) pairs, where the names are simple strings and the values being of a few predefined basic data types. The exact definition of the Yamcs high-level data types in terms of tuple (e.g. a telemetry packet has the attributes gentime(timestamp), rectime(timestamp), packet(binary), etc) is currently hard-coded inside the java source code. In the future it might be externalised in configuration files to allow a certain degree of customisation. Services Yamcs functionality is modularised into different services, representing objects with operational state, with methods to start and stop. Yamcs acts as a container for services, each running in a different thread. Services carry out a specific function. Some services are vital to core functionality, others can be thought of as more optional and give Yamcs its pluggable nature. Services appear at three different conceptual levels: Global services provide functionality across all instances. Instance services provide functionality for one specific instance. Processor services provide functionality for one specific processor. "},{"title":"General","url":"/docs/http/General/","body":"Yamcs provides an HTTP API allowing external tools to integrate with Yamcs resources. Most HTTP endpoints send and expect JSON messages. If you develop in Python consider using the Python Client which provides an idiomatic mapping for most of the operations documented here. HTTP Verbs The supported HTTP verbs are: GET Retrieve a resource POST Create a new resource PATCH Update an existing resource DELETE Delete a resource Time All timestamps are returned as UTC and formatted according to ISO 8601. For example: 2015-08-26T08:08:40.724Z 2015-08-26 Namespaces Mission Database entries like parameters and containers may be available under different namespaces. When an operation documents the use of /:namespace/:name in the URI, the namespace segment can be repeated for every subsystem in case of hierarchical XTCE names. For example, these resources evaluate to the same parameter resource: /api/mdb/simulator/parameters/MDB%3AOPS+Name/SIMULATOR_BatteryVoltage2 /api/mdb/simulator/parameters/YSS/SIMULATOR/BatteryVoltage2 Notice as well the use of %3A and + to URL-encode MDB:OPS Name to the ASCII character set. The server supports UTF-8 but your client may not. Error Handling When an exception is caught while handling an HTTP request, the server will try to give some feedback to the client by wrapping it in a generic exception message like so: { \"exception\" : { \"type\": \"&lt;short&gt;\", \"msg\": \"&lt;long&gt;\" } } Clients should check on whether the status code is between 200 and 299, and if not, interpret the response with the above structure. CORS Cross-origin Resource Sharing (CORS) allows access to the Yamcs HTTP API from a remotely hosted web page. This is the HTML5 way of bypassing the self-origin policy typically enforced by browsers. With CORS, the browser will issue a preflight request to Yamcs to verify that it allows browser requests from the originating web page. CORS is off by default on Yamcs Server, but this is configurable by your site administrator. Protobuf As an alternative to JSON, most endpoints also support Google Protocol Buffers for a lighter footprint. To mark a request as Protobuf, set this HTTP header: Content-Type: application/protobuf If you also want to server to respond with Protobuf messages, add the Accept header: Accept: application/protobuf The proto files are available at GitHub. Using the protoc compiler, client code can be generated for Java, Python, C++ and more. The applicable top-level Protobuf messages are documented for every operation separately. If the response status is not between 200 and 299, deserialize the response as of type RestExceptionMessage. "},{"title":"Get Command Info","url":"/docs/http/Get_Command_Info/","body":"Return the data for the given command: GET /api/mdb/:instance/commands/:namespace/:name Response Status: 200 OK { \"name\": \"SWITCH_VOLTAGE_ON\", \"qualifiedName\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\", \"alias\" : [ { \"name\" : \"SIMULATOR_SWITCH_VOLTAGE_ON\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"SWITCH_VOLTAGE_ON\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"baseCommand\" : { \"name\": \"SIM_TC\", \"qualifiedName\" : \"/YSS/SIMULATOR/SIM_TC\", \"alias\" : [ { \"name\" : \"SIMULATOR_SIM_TC\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"SIM_TC\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"baseCommand\" : { \"name\": \"ccsds-tc\", \"qualifiedName\" : \"/YSS/ccsds-tc\", \"alias\" : [ { \"name\" : \"YSS_ccsds-tc\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"ccsds-tc\", \"namespace\" : \"/YSS\" } ], \"abstract\" : true, \"argument\" : [ { \"name\" : \"ccsds-apid\", \"type\" : \"integer\" }, { \"name\" : \"timeId\", \"type\" : \"integer\" }, { \"name\" : \"checksumIndicator\", \"type\" : \"integer\", \"initialValue\" : \"1\" }, { \"name\" : \"packet-type\", \"type\" : \"integer\" }, { \"name\" : \"packet-id\", \"type\" : \"integer\" } ] }, \"abstract\" : true, \"argumentAssignment\" : [ { \"name\" : \"ccsds-apid\", \"value\" : \"100\" }, { \"name\" : \"timeId\", \"value\" : \"1\" }, { \"name\" : \"packet-type\", \"value\" : \"10\" } ] }, \"abstract\" : false, \"argument\" : [ { \"name\" : \"voltage_num\", \"description\" : \"voltage number to switch on\", \"type\" : \"integer\", \"unitSet\" : [ { \"unit\" : \"V\" } ] } ], \"argumentAssignment\" : [ { \"name\" : \"packet-id\", \"value\" : \"1\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: mdb/mdb.proto message CommandInfo { optional string name = 1; optional string qualifiedName = 2; optional string shortDescription = 3; optional string longDescription = 4; repeated yamcs.NamedObjectId alias = 5; optional CommandInfo baseCommand = 6; optional bool abstract = 7; repeated ArgumentInfo argument = 8; repeated ArgumentAssignmentInfo argumentAssignment = 9; optional SignificanceInfo significance = 10; repeated TransmissionConstraintInfo constraint = 11; } "},{"title":"Get Command Queue","url":"/docs/http/Get_Command_Queue/","body":"Get data on a command queue: GET /api/processors/:instance/:processor/cqueues/:name Response { \"instance\" : \"simulator\", \"processorName\" : \"realtime\", \"name\" : \"default\", \"state\" : \"BLOCKED\", \"nbSentCommands\" : 0, \"nbRejectedCommands\" : 0, \"entry\" : [ { \"instance\" : \"simulator\", \"processorName\" : \"realtime\", \"queueName\" : \"default\", \"cmdId\" : { \"generationTime\" : 1448782973440, \"origin\" : \"000349-WS.local\", \"sequenceNumber\" : 5, \"commandName\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"source\" : \"SWITCH_VOLTAGE_OFF(voltage_num: 2)\", \"binary\" : \"GGTAAAAAAAAAAABqAAAAAgI=\", \"username\" : \"anonymous\", \"generationTime\" : 1448782973440, \"uuid\" : \"3e867111-048a-4343-b195-47ba07d07093\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: commanding/commanding.proto message CommandQueueInfo { required string instance = 1; required string processorName = 2; required string name = 3; optional QueueState state = 4; required int32 nbSentCommands = 5; required int32 nbRejectedCommands = 6; optional int32 stateExpirationTimeS = 7; } "},{"title":"Get Container Info","url":"/docs/http/Get_Container_Info/","body":"Return the data for the given container: GET /api/mdb/:instance/containers/:namespace/:name Response Status: 200 OK { \"name\": \"DHS\", \"qualifiedName\" : \"/YSS/SIMULATOR/DHS\", \"alias\" : [ { \"name\" : \"SIMULATOR_DHS\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"DHS\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"maxInterval\" : 1500, \"baseContainer\" : { \"name\": \"ccsds-default\", \"qualifiedName\" : \"/YSS/ccsds-default\", \"alias\" : [ { \"name\" : \"YSS_ccsds-default\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"ccsds-default\", \"namespace\" : \"/YSS\" } ], \"entry\" : [ { \"locationInBits\" : 5, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"ccsds-apid\", \"qualifiedName\" : \"/YSS/ccsds-apid\", \"alias\" : [ { \"name\" : \"YSS_ccsds-apid\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"ccsds-apid\", \"namespace\" : \"/YSS\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:11, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } }, { \"locationInBits\" : 82, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"packet-type\", \"qualifiedName\" : \"/YSS/packet-type\", \"alias\" : [ { \"name\" : \"YSS_packet-type\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"packet-type\", \"namespace\" : \"/YSS\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:4, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } }, { \"locationInBits\" : 96, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"packet-id\", \"qualifiedName\" : \"/YSS/packet-id\", \"alias\" : [ { \"name\" : \"YSS_packet-id\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"packet-id\", \"namespace\" : \"/YSS\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:32, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } } ] }, \"restrictionCriteria\" : [ { \"parameter\" : { \"name\": \"ccsds-apid\", \"qualifiedName\" : \"/YSS/ccsds-apid\" }, \"operator\" : \"EQUAL_TO\", \"value\" : \"1\" }, { \"parameter\" : { \"name\": \"packet-id\", \"qualifiedName\" : \"/YSS/packet-id\" }, \"operator\" : \"EQUAL_TO\", \"value\" : \"2\" } ], \"entry\" : [ { \"locationInBits\" : 128, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"PrimBusVoltage1\", \"qualifiedName\" : \"/YSS/SIMULATOR/PrimBusVoltage1\", \"alias\" : [ { \"name\" : \"SIMULATOR_PrimBusVoltage1\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"PrimBusVoltage1\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:8, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } }, { \"locationInBits\" : 136, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"PrimBusCurrent1\", \"qualifiedName\" : \"/YSS/SIMULATOR/PrimBusCurrent1\", \"alias\" : [ { \"name\" : \"SIMULATOR_PrimBusCurrent1\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"PrimBusCurrent1\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:8, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: mdb/mdb.proto message ContainerInfo { optional string name = 1; optional string qualifiedName = 2; optional string shortDescription = 3; optional string longDescription = 4; repeated yamcs.NamedObjectId alias = 5; optional int64 maxInterval = 6; optional int32 sizeInBits = 7; optional ContainerInfo baseContainer = 8; repeated ComparisonInfo restrictionCriteria = 9; repeated SequenceEntryInfo entry = 10; } "},{"title":"Get Instance Detail","url":"/docs/http/Get_Instance_Detail/","body":"Get data on a Yamcs instance: GET /api/instances/:instance Response Status: 200 OK { \"name\" : \"simulator\", \"missionDatabase\" : { \"configName\" : \"landing\", \"name\" : \"\", \"spaceSystem\" : [ { \"name\" : \"yamcs\", \"qualifiedName\" : \"/yamcs\" }, { \"name\" : \"YSS\", \"qualifiedName\" : \"/YSS\", \"sub\" : [ { \"name\" : \"SIMULATOR\", \"qualifiedName\" : \"/YSS/SIMULATOR\" } ] }, { \"name\" : \"GS\", \"qualifiedName\" : \"/GS\" } ] }, \"processor\" : [ { \"name\" : \"realtime\" } ] } If an instance does not have web services enabled, it will be listed among the results, but none of its URLs will be filled in. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcsManagement/yamcsManagement.proto message YamcsInstance { required string name = 1; optional MissionDatabase missionDatabase = 3; repeated ProcessorInfo processor = 4; } "},{"title":"Get Link","url":"/docs/http/Get_Link/","body":"Get data on a specific link for the given Yamcs instance: GET /api/links/:instance/:name Response Status: 200 OK { \"instance\" : \"simulator\", \"name\" : \"tm1\", \"type\" : \"HkDataHandler\", \"spec\" : \"\", \"stream\" : \"tm_realtime\", \"disabled\" : false, \"status\" : \"OK\", \"dataCount\" : 34598, \"detailedStatus\" : \"reading files from /storage/yamcs-incoming/simulator/tm\" } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcsManagement/yamcsManagement.proto message LinkInfo { required string instance = 1; required string name = 2; optional string type = 3; optional string spec = 4; optional string stream = 5; optional bool disabled = 6; optional string status = 7; optional int64 dataCount = 8; optional string detailedStatus = 9; } "},{"title":"Get MDB Detail","url":"/docs/http/Get_MDB_Detail/","body":"Get data on a the Mission Database for the given Yamcs instance: GET /api/mdb/:instance Response Status: 200 OK { \"configName\" : \"landing\", \"name\" : \"\", \"spaceSystem\" : [ { \"name\" : \"YSS\", \"qualifiedName\" : \"/YSS\", \"version\" : \"1.2\", \"parameterCount\" : 3, \"containerCount\" : 1, \"commandCount\" : 1, \"sub\" : [ { \"name\" : \"SIMULATOR\", \"qualifiedName\" : \"/YSS/SIMULATOR\", \"version\" : \"1.0\", \"parameterCount\" : 59, \"containerCount\" : 9, \"commandCount\" : 8, \"history\" : [ { \"version\" : \"1.3\", \"date\" : \"21-June-2020\", \"message\" : \"modified this and that\" } ] } ] } Alternative Media Types Java-serialized XtceDb Use HTTP header: Accept: application/x-java-serialized-object This returns a full java-serialized binary dump of the XtceDb. You will need a dependency on the LGPL yamcs-api jar if you want to interpret it. Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcsManagement/yamcsManagement.proto message MissionDatabase { required string configName = 1; required string name = 2; optional string version = 3; repeated SpaceSystemInfo spaceSystem = 4; } "},{"title":"Get Object","url":"/docs/http/Get_Object/","body":"Get an object: GET /api/buckets/:instance/:bucketName/:objectName _global can be used as instance name to get an object from a bucket at the global level. Response The object data is returned in the body of the response. The response Content-Type is set to the content type of the object specified when uploading the object. If no Content-Type has been specified when creating the object, the Content-Type of the response will be set to “application/octet-stream”. "},{"title":"Get Packet","url":"/docs/http/Get_Packet/","body":"Get a single packet: GET /api/archive/:instance/packets/:gentime/:seqnum The gentime must be an exact match of the packet’s generation time in ISO 8601 format. Example: /api/archive/simulator/packets/2015-10-20T06:47:02.000/808465467 Response Status: 200 OK { \"receptionTime\" : 1447880235182, \"packet\" : \"MDA0O1NVOzE7MDsyOzI7MjswOy0yMi43MTMwOysyNC44NTQwOzIwMTUvMTAvMjA7MDY6NDc6MDUuMDAwOzA7Ow==\", \"generationTime\" : 1445323658000, \"sequenceNumber\" : 808465467 } The binary inside the packet variable is encoded in Base64 format Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcs.proto message TmPacketData { required int64 receptionTime = 1; required bytes packet = 2; optional int64 generationTime = 3; optional int32 sequenceNumber = 4; optional NamedObjectId id = 5; } "},{"title":"Get Packet Index","url":"/docs/http/Get_Packet_Index/","body":"Get the index of stored packets for the given instance: GET /api/archive/:instance/packet-index Parameters Name Type Description start string Filter the lower bound of the index entries. Specify a date string in ISO 8601 format. stop string Filter the upper bound of the index entries. Specify a date string in ISO 8601 format. mergeTime integer Value in milliseconds that indicates the maximum gap before two consecutive index ranges are merged together. Default: 2000 limit integer The maximum number of returned entries. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 1000 Note that in general it is advised to control the size of the response via mergeTime, rather than via limit. Example Status: 200 OK { \"group\": [{ \"id\": { \"name\": \"/YSS/SIMULATOR/DHS\" }, \"entry\": [{ \"start\": \"2018-04-26T10:45:26.671Z\", \"stop\": \"2018-04-26T10:59:22.679Z\", \"count\": 134 }] }, { \"id\": { \"name\": \"/YSS/SIMULATOR/FlightData\" }, \"entry\": [{ \"start\": \"2018-04-26T10:45:20.621Z\", \"stop\": \"2018-04-26T10:59:22.882Z\", \"count\": 4155 }] }, { \"id\": { \"name\": \"/YSS/SIMULATOR/Power\" }, \"entry\": [{ \"start\": \"2018-04-26T10:45:26.671Z\", \"stop\": \"2018-04-26T10:59:22.679Z\", \"count\": 134 }] }, { \"id\": { \"name\": \"/YSS/SIMULATOR/RCS\" }, \"entry\": [{ \"start\": \"2018-04-26T10:45:26.671Z\", \"stop\": \"2018-04-26T10:59:22.679Z\", \"count\": 134 }] }] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: archive/archive.proto message IndexResponse { repeated IndexGroup group = 1; } "},{"title":"Get Parameter Info","url":"/docs/http/Get_Parameter_Info/","body":"Return the data for the given parameter: GET /api/mdb/:instance/parameters/:namespace/:name Response Status: 200 OK { \"name\": \"BatteryVoltage2\", \"qualifiedName\" : \"/YSS/SIMULATOR/BatteryVoltage2\", \"alias\" : [ { \"name\" : \"SIMULATOR_BatteryVoltage2\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"BatteryVoltage2\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:8, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } Bulk Combine multiple parameter queries in one and the same request using this address: GET /api/mdb/:instance/parameters/bulk Specify the parameter IDs in the request body: { \"id\" : [ { \"name\": \"YSS_ccsds-apid\", \"namespace\": \"MDB:OPS Name\" }, { \"name\": \"YSS_packet-type\", \"namespace\": \"MDB:OPS Name\" } ] } POST requests are also allowed, because some HTTP clients do not support GET with a request body. In the response the requested parameter ID is returned for every match. Example: { \"response\" : [ { \"id\" : { \"name\" : \"YSS_ccsds-apid\", \"namespace\" : \"MDB:OPS Name\" }, \"parameter\" : { \"name\": \"ccsds-apid\", \"qualifiedName\" : \"/YSS/ccsds-apid\", \"aliases\" : [ { \"name\" : \"YSS_ccsds-apid\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"ccsds-apid\", \"namespace\" : \"/YSS\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:11, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } } ] } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Response is of type: mdb/mdb.proto message ParameterInfo { optional string name = 1; optional string qualifiedName = 2; optional string shortDescription = 3; optional string longDescription = 4; repeated yamcs.NamedObjectId alias = 5; optional ParameterTypeInfo type = 6; optional DataSourceType dataSource = 7; } Bulk request is of type: rest/rest.proto message BulkGetParameterRequest { repeated yamcs.NamedObjectId id = 1; } Bulk response is of type: rest/rest.proto message BulkGetParameterResponse { message GetParameterResponse { optional yamcs.NamedObjectId id = 1; optional mdb.ParameterInfo parameter = 2; } repeated GetParameterResponse response = 1; } "},{"title":"Get Parameter Ranges","url":"/docs/http/Get_Parameter_Ranges/","body":"Retrieve a history of ranges for the specified parameter: GET /api/archive/:instance/parameters/:namespace/:name/ranges A range is a tuple (start, stop, value, count) that represents the time interval for which the parameter has been steadily coming in with the same value. This request is useful for retrieving an overview for parameters that change unfrequently in a large time interval. For example an on/off status of a device, or some operational status. Two consecutive ranges containing the same value will be returned if there was a gap in the data. The gap is determined according to the parameter expiration time configured in the MDB. Parameters Name Type Description start string Filter the lower bound of the parameter's generation time. Specify a date string in ISO 8601 format stop string Filter the upper bound of the parameter's generation time. Specify a date string in ISO 8601 format minGap long Time in milliseconds. Any gap (detected based on parameter expiration) smaller than this will be ignored. However if the parameter changes value, the ranges will still be split. maxGap long Time in milliseconds. If the distance between two subsequent values of the parameter is bigger than this value (but smaller than the parameter expiration), then an artificial gap will be constructed. This also applies if there is no parameter expiration defined for the parameter. norealtime boolean Disable loading of parameters from the parameter cache. Default: false processor string The name of the processor from which to use the parameter cache. Default: realtime Response Status: 200 OK { \"range\": [{ \"timeStart\": \"2018-04-06T11:24:01.752Z\", \"timeStop\": \"2018-04-06T12:21:25.187Z\", \"engValue\": { \"type\": \"STRING\", \"stringValue\": \"UNLOCKED\" }, \"count\": 11 }, { \"timeStart\": \"2018-04-06T12:21:25.187Z\", \"timeStop\": \"2018-04-06T12:26:25.187Z\", \"engValue\": { \"type\": \"STRING\", \"stringValue\": \"LOCKED\" }, \"count\": 1 }] } engValue is the engineering value of the parameter in the interval [timeStart, timeStop) time interval have to be considered as closed at start and open at stop. timeStart is the generation time of a parameter value. timeStop is: if the value changes, timeStop is the generation time of the new value if the parameter expires or the maxGap has been set, timeStop is the generation time of the last value plus the expiration time or the maxGap. count is the number of parameter values received in the interval. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: pvalue/pvalue.proto message Ranges { message Range { optional string timeStart = 1; optional string timeStop = 2; optional yamcs.Value engValue = 3; optional int32 count = 4; } repeated Range range = 1; } "},{"title":"Get Parameter Samples","url":"/docs/http/Get_Parameter_Samples/","body":"Sample the history of values for the specified parameter by dividing it in a number of intervals and returning aggregated statistics (max,min,avg) about each interval: GET /api/archive/:instance/parameters/:namespace/:name/samples This operation is useful when making high-level overviews (such as plots) of a parameter’s value over large time intervals without having to retrieve each and every individual parameter value. By default this operation fetches data from the parameter archive and/or parameter cache. If these services are not configured, you can still get correct results by specifying the option source=replay as detailed below. Parameters Name Type Description start string Filter the lower bound of the parameter's generation time. Specify a date string in ISO 8601 format stop string Filter the upper bound of the parameter's generation time. Specify a date string in ISO 8601 format count int Number of intervals to use. Default: 500 order string The order of the returned results. Can be either asc or desc. Default: asc norealtime boolean Disable loading of parameters from the parameter cache. Default: false processor string The name of the processor from which to use the parameter cache. Default: realtime source string Specifies how to retrieve the parameters. Either ParameterArchive or replay. If replay is specified, a replay processor will be created and data will be processed with the active XTCEDB. Note that this is much slower than receiving data from the ParameterArchive.Default: ParameterArchive Response Status: 200 OK { \"sample\" : [ { \"time\" : \"2015-11-11T09:11:37.626\", \"avg\" : 169.41836734693865, \"min\" : 103.0, \"max\" : 237.0, \"n\" : 98 } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: pvalue/pvalue.proto message TimeSeries { message Sample { optional string time = 1; optional double avg = 2; optional double min = 3; optional double max = 4; optional int32 n = 5; } repeated Sample sample = 1; } "},{"title":"Get Parameter Value","url":"/docs/http/Get_Parameter_Value/","body":"Retrieves the current value of the specified parameter. GET /api/processors/:instance/:processor/parameters/:namespace/:name Parameters Name Type Description fromCache bool Whether the latest cached value may be returned. Default: yes timeout number Time in milliseconds to wait on a value (only considered if fromCache=no). When the timeout is met, the call will return with no or partial data. Default: 10000 Response Status: 200 OK { \"id\" : { \"name\" : \"BatteryVoltage2\", \"namespace\" : \"/YSS/SIMULATOR\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 184 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 184 }, \"acquisitionTime\" : 1445940421269, \"generationTime\" : 1445940404207, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"acquisitionTimeUTC\" : \"2015-10-27T10:06:25.269Z\", \"generationTimeUTC\" : \"2015-10-27T10:06:08.207Z\", \"expirationTime\" : 1445940428269, \"expirationTimeUTC\" : \"2015-10-27T10:06:32.269Z\" } Multi-get Get the values of multiple parameters in one and the same request using this address: GET /api/processors/:instance/:processor/parameters/mget The same options as in the query string can be specified in the request body. Parameter IDs are added to a list: { \"fromCache\" : false, \"timeout\" : 15000, \"id\" : [ { \"name\": \"YSS_ccsds-apid\", \"namespace\": \"MDB:OPS Name\" }, { \"name\": \"/YSS/SIMULATOR/BatteryVoltage2\" } ] } POST requests are also allowed, because some HTTP clients do not support GET with a request body. The response is a list of parameter values: { \"value\" : [ { \"id\" : { \"name\" : \"/YSS/SIMULATOR/BatteryVoltage2\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 206 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 206 }, \"acquisitionTime\" : 1445944393466, \"generationTime\" : 1445944376410, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"acquisitionTimeUTC\" : \"2015-10-27T11:12:37.466Z\", \"generationTimeUTC\" : \"2015-10-27T11:12:20.410Z\", \"expirationTime\" : 1445944400466, \"expirationTimeUTC\" : \"2015-10-27T11:12:44.466Z\" } ] } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: pvalue/pvalue.proto message ParameterValue { optional yamcs.NamedObjectId id = 1; optional yamcs.Value rawValue = 2; optional yamcs.Value engValue = 3; optional int64 acquisitionTime = 4; optional int64 generationTime = 5; optional AcquisitionStatus acquisitionStatus = 6; optional bool processingStatus = 7; optional MonitoringResult monitoringResult = 8; optional string acquisitionTimeUTC = 11; optional string generationTimeUTC = 12; optional int64 expirationTime = 23; optional string expirationTimeUTC = 24; repeated mdb.AlarmRange alarmRange = 25; } Bulk request is of type: rest/rest.proto message BulkGetParameterValueRequest { repeated yamcs.NamedObjectId id = 1; optional bool fromCache = 2; optional uint64 timeout = 3; //if not fromCache, wait this time (in milliseconds) to receive the parameter } Bulk response is of type: rest/rest.proto message BulkGetParameterValueResponse { repeated pvalue.ParameterValue value = 1; } "},{"title":"Get Processor Info","url":"/docs/http/Get_Processor_Info/","body":"Get info on a specific Yamcs processor: GET /api/processors/:instance/:name Response Status: 200 OK { \"instance\" : \"simulator\", \"name\" : \"realtime\", \"type\" : \"realtime\", \"creator\" : \"system\", \"hasCommanding\" : true, \"state\" : \"RUNNING\" } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcsManagement/yamcsManagement.proto message ProcessorInfo { optional string instance = 1; optional string name = 2; optional string type = 3; optional string spec = 4; optional string creator = 5; optional bool hasCommanding = 6; optional ServiceState state = 7; optional yamcs.ReplayRequest replayRequest = 8; optional yamcs.ReplayStatus.ReplayState replayState = 9; } "},{"title":"Get Stream Info","url":"/docs/http/Get_Stream_Info/","body":"Get info on a Yamcs stream: GET /api/archive/:instance/streams/:name This is low-level API for those cases where access to an internal stream of Yamcs is wanted. It is recommended to use other API operations for any of the default built-in streams. Response Status: 200 OK { \"name\" : \"tm_realtime\", \"column\" : [ { \"name\" : \"gentime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"seqNum\", \"type\" : \"INT\" }, { \"name\" : \"rectime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"packet\", \"type\" : \"BINARY\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response if of type: archive/archive.proto message StreamInfo { optional string name = 1; repeated ColumnInfo column = 2; } "},{"title":"Get Table Info","url":"/docs/http/Get_Table_Info/","body":"Get info on a Yamcs table: GET /api/archive/:instance/tables/:name This is low-level API for those cases where access to an internal key/value table of Yamcs is wanted. It is recommended to use other API operations for any of the default built-in tables. Response Status: 200 OK { \"name\" : \"tm\", \"keyColumn\" : [ { \"name\" : \"gentime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"seqNum\", \"type\" : \"INT\" } ], \"valueColumn\" : [ { \"name\" : \"rectime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"packet\", \"type\" : \"BINARY\" }, { \"name\" : \"pname\", \"type\" : \"ENUM\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: archive/archive.proto message TableInfo { optional string name = 1; repeated ColumnInfo keyColumn = 2; repeated ColumnInfo valueColumn = 3; } "},{"title":"Get Tag","url":"/docs/http/Get_Tag/","body":"Get info on a specific tag for the given archive instance: GET /api/archive/:instance/tags/:start/:id Response Status: 200 OK { \"id\" : 1, \"name\" : \"My annotation\", \"start\" : 1449128432000, \"stop\" : 1449174255000, \"description\" : \"blabla\", \"color\" : \"#ffc800\" } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcs.proto message ArchiveTag { optional int32 id = 1; required string name = 2; optional int64 start = 3; optional int64 stop = 4; optional string description = 5; optional string color = 6; } "},{"title":"Getting Started","url":"/docs/cli/Getting_Started/","body":"Installation The Yamcs Command-Line Interface is written in Python and distributed separately from Yamcs Server. Install with pip: pip install --upgrade yamcs-cli Run yamcs login to initialize your environment: yamcs login "},{"title":"Global Services","url":"/docs/server/Global_Services/","body":" "},{"title":"Graphic Widgets","url":"/docs/studio/Graphic_Widgets/","body":"Arc Draws an arc contained by the bounding box. To modify the size of the arc, modify the X, Y, Width and Height properties. By default the arc starts with an angle of 0 degrees (right center). Modify this property using Start Angle (in degrees). The arc length is determined using Total Angle. Polyline Use the polyline tool to draw lines of two or more points. After selecting the widget from the Palette, start by clicking on your desired start location. Every next click will add a new point. Double-click if this is your last point. You can modify your points by moving around the yellow handles. Finetune your points using the Points properties. Polylines have a direction and can be decorated with arrow heads using the various Arrow properties. Polygon Similar in functionality to polylines, but the last point is always connected to the first point to form a closed shape. Unlike polylines, polygons are not directed. The can be filled from left to right or from bottom to top using the Fill Level, and Horizontal Fill properties. In the section Rules we’ll learn that this (or just about any other property) can also be dynamically modified. Rectangle Rectangles are constrained polygons. They can be customized in much the same way as polygons. Unlike polygons the background and foreground can also be colored using gradients which makes them look less flat. Rounded Rectangle Rounded rectangles are a specialised form of Rectangles. They support additional properties for controlling Corner Height and Corner Width. Ellipse The Ellipse’s shape is determined by its bounding box using the Width and Height properties. Ellipses support similar properties as rectangles. Label The Label widget allows displaying text within a bounding box indicated by the X, Y, Width and Height properties. Adapt your bounding box to the content using Auto Size property. For long texts consider using the Wrap Words and Show Scrollbar properties. To edit the text of a label, either select the Label property to open an input dialog, or press F2 to edit the label in-place. Image Yamcs Studio supports GIF, JPG, PNG and BMP images. Images must be added to your project before you can select them with the Image File property. Transparency is automatically supported as well, but make sure to set the background of the Image widget to the same color as the container. "},{"title":"HTTP Server","url":"/docs/server/HTTP_Server/","body":"Embedded HTTP server that provides these functionalities: Serve HTTP API (REST and WebSocket) Serve the Yamcs web interface The HTTP Server is tightly integrated with the security system of Yamcs and serves as the default interface for external tooling wanting to integrate. This covers both server-to-server and server-to-user communication patterns. The HTTP Server can be disabled when its functionality is not needed. Note that in this case also official external clients such as Yamcs Studio will not be able to connect to Yamcs. Class Name org.yamcs.web.HttpServer Configuration This is a global service defined in etc/yamcs.yaml. Example from a typical deployment: yamcs.yaml services: - class: org.yamcs.web.HttpServer args: webRoot: lib/yamcs-web port: 8090 webSocket: writeBufferWaterMark: low: 32768 high: 65536 connectionCloseNumDroppedMsg: 5 cors: allowOrigin: \"*\" allowCredentials: false website: displayScope: GLOBAL Configuration Options Name Type Description port integer The port at which Yamcs web services may be reached. Default: 8090 webRoot string or string[] List of file paths that are statically served. This usually points to the web files for the built-in Yamcs web interface (lib/yamcs-web). zeroCopyEnabled boolean Indicates whether zero-copy can be used to optimize non-SSL static file serving. Default: true webSocket map Configure WebSocket properties. Detailed below. If unset, Yamcs uses sensible defaults. cors map Configure cross-origin resource sharing for the HTTP API. Detailed below. If unset, CORS is not supported. website map Configure properties of the Yamcs website. WebSocket sub-configuration Name Type Description maxFrameLength integer Maximum frame length in bytes. Default: 65535 writeBufferWaterMark map Water marks for the write buffer of each WebSocket connection. When the buffer is full, messages are dropped. High values lead to increased memory use, but connections will be more resilient against unstable networks (i.e. high jitter). Increasing the values also help if a large number of messages are generated in bursts. The map requires keys low and high indicating the low/high water mark in bytes. Default: { low: 32768, high: 65536} connectionCloseNumDroppedMsg integer Allowed number of message drops before closing the connection. Default: 5 CORS sub-configuration CORS (cross-origin resource sharing) facilitates use of the API in client-side applications that run in the browser. CORS is a W3C specification enforced by all major browsers. Details are described at https://www.w3.org/TR/cors/. Yamcs simply adds configurable support for some of the CORS preflight response headers. Note that the embedded web interface of Yamcs does not need CORS enabled, because it shares the same origin as the HTTP API. Name Type Description allowOrigin string Exact string that will be set in the Access-Control-Allow-Origin header of the preflight response. allowCredentials boolean Whether the Access-Control-Allow-Credentials header of the preflight response is set to true. Default: false Website sub-configuration Name Type Description displayScope string Where to locate displays and layouts. One of INSTANCE or GLOBAL. Setting this to GLOBAL means that displays are shared between all instances. Setting this to INSTANCE, means that each instance uses its own displays. Default: GLOBAL "},{"title":"Index Server","url":"/docs/server/Index_Server/","body":"Supports retrieval of archive indexes and tags. Class Name org.yamcs.archive.IndexServer Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.IndexServer Configuration Options Name Type Description tmIndexer string Class name of a TmIndex implementation. Default is org.yamcs.archive.CcsdsTmIndex which applies CCSDS conventions. "},{"title":"Indexes","url":"/docs/http/Indexes/","body":" "},{"title":"Inspector Windows","url":"/docs/studio/Inspector_Windows/","body":"There are a few standalone windows that can be opened for inspecting widgets. "},{"title":"Installation","url":"/docs/server/Installation/","body":"Prerequisites Yamcs Server runs on 64-bit Linux. RAM &gt;= 1Gb HD &gt;= 500Gb (dependent on amount of data archived) Java Runtime Environment (JRE) &gt;= version 1.8 Install Manually Yamcs Server software is packaged in RPM format. To install: $ rpm -U yamcs-version.noarch.rpm This command also works for upgrading. If a configuration file (in the etc directory) has been updated with regard to the previous installed version, the old files will be saved with the extension .rpmsave. The user then has to inspect the difference between the two versions and to implement the newly added options into the old configuration files. To uninstall Yamcs Server use: $ rpm -e yamcs Note that this will also remove the yamcs user. Install from Repository Yamcs Server packages are distributed via yum and APT. Configure the Yamcs repository appropriate to your distribution following the repository instructions. RPM (RHEL, Fedora, CentOS) Install via dnf (or yum on older distributions) $ dnf check-update $ sudo dnf install yamcs RPM (SLE, openSUSE) $ sudo zypper refresh $ sudo zypper install yamcs File Layout After installing the rpms, the following directories are created under /opt/yamcs: bin Contains shell scripts for starting the different programs cache Contains cached serialized java files for the Mission Database. This has to be writable by the user yamcs etc Contains all the configuration files lib Contains the jars required by Yamcs. lib/ext is where extensions reside log Contains the log files of Yamcs. It has to be writable by the user yamcs mdb Empty directory where the mission database has to be located. In addition to the default Yamcs package, in order to get a running server, the yamcs-simulation rpm can also be installed: $ rpm -U yamcs-simulation-version.noarch.rpm This package will provide default configuration files and MDB for running a simple simulation of a UAV. In addition to the directories mentioned above, yamcs also uses /storage/yamcs-data to store the data (telemetry, telecomand, event archive). This directory has to be writable by the user yamcs. The location of the data directory can be changed by editing /opt/yamcs/etc/yamcs.yaml In addition to the default Yamcs package, there are other proprietary extensions. For example: yamcs-cdmcs Provides loading of TM/TC directly from CD-MCS MDB or from SCOE files (only TM) and also provides the CORBA (CIS) protocol for communicating with USS and MCS Tools yamcs-dass Provides TM/TC receivers/senders via the DaSS protocol yamcs-spell Provides the modules required to use SPELL with Yamcs. SPELL is a procedure execution environment developed by SES. The extensions are not part of the Yamcs open-source release. If you are interested in using them, please contact Space Applications Services. Configuration Yamcs configuration files are written in YAML format. This format allows to encode in a human friendly way the most common data types: numbers, strings, lists and maps. For detailed syntax rules, please see https://www.yaml.org. The root configuration file is etc/yamcs.yaml. It contains a list of Yamcs instances. For each instance, a file called etc/yamcs.instance-name.yaml defines all the components that are part of the instance. Depending on which components are selected, different configuration files are needed. Starting Yamcs Server Normally Yamcs Server should be configured to start automatically on boot via /etc/init.d/yamcs-server. The command will automatically run itself as a lower privilege user (username yamcs), but must initially be run as root for this to happen. Yamcs Server can be started and stopped as a service via commands such as service yamcs-server start and service yamcs-server stop. These commands use the init.d script and will run Yamcs as the appropriate user. It is also possible to directly use the script /opt/yamcs/bin/yamcsd, but use of the service command is preferred. "},{"title":"Installation","url":"/docs/studio/Installation/","body":"Prerequisites Java 8 or higher must be installed. We currently recommend the latest Oracle JDK 8. 64-bit packages are generated for Linux, Windows and Mac OS. Install Manually Download the latest Yamcs Studio release for your platform. Extract to your preferred location and launch it. When it asks you to choose a workspace, choose a new directory where you have write rights , e.g. under your home directory. Workspaces contain displays, scripts and user preferences. By default your workspace will be populated with a few sample projects. These projects contain displays that show simulated parameters as produced by a default-configured Yamcs Server. Install from Repository On Linux distributions you can install the open-source version of Yamcs Studio via a package repository. Configure the Yamcs repository appropriate to your distribution following the repository instructions. RPM (RHEL, Fedora, CentOS) Install via dnf (or yum on older distributions) $ dnf check-update $ sudo dnf install yamcs-studio RPM (SLE, openSUSE) $ sudo zypper refresh $ sudo zypper install yamcs-studio Troubleshooting Most problems related to starting Yamcs Studio have to do with Java not being correctly detected, or by trying to launch Yamcs Studio with an old version of Java. Both of these issues are usually resolved by installing Oracle JDK 8. In case that didn’t help, Try defining the -vm property in the root Yamcs Studio.ini file. Refer to the instructions available at https://wiki.eclipse.org/Eclipse.ini. "},{"title":"Instance Services","url":"/docs/server/Instance_Services/","body":" "},{"title":"Instances","url":"/docs/http/Instances/","body":" "},{"title":"Introduction","url":"/docs/server/Introduction/","body":"Yamcs Server, or short Yamcs, is a central component for monitoring and controlling remote devices. Yamcs stores and processes packets, and provides an interface for end-user applications to subscribe to realtime or archived data. Typical use cases for such applications include telemetry displays and commanding tools. Yamcs ships with an embedded web server for administering the server, the mission databases or for basic monitoring tasks. For more advanced requirements, Yamcs exposes its functionality over a well-documented HTTP-based API. Yamcs is implemented entirely in Java, but it does rely on an external storage engine for actual data archiving. Currently the storage engine is RocksDB. The preferred target platform is linux x64, but Yamcs can also be made to run on Mac OS X and Windows. While Yamcs binaries are typically used to run the Yamcs Server, they can also be useful as a library for reusable tasks such as processing of packet telemetry according to XTCE definitions. This manual describes how to use Yamcs as a server. If you want to use it for other purposes, please contact the developers at Yamcs mailing list. "},{"title":"Introduction","url":"/docs/studio/Introduction/","body":" "},{"title":"Issue Command","url":"/docs/http/Issue_Command/","body":"Issue a new command of the given type: POST /api/processors/:instance/:processor/commands/:namespace/:name After validating the input parameters, the command will be added to the appropriate command queue for further dispatch. Parameters Name Type Description origin string The origin of the command. Typically in \"user@host\" format. sequenceNumber integer The sequence number as specified by the origin. This gets communicated back in command history and command queue entries, thereby allowing clients to map local with remote command identities. dryRun bool Whether a response will be returned without actually issuing the command. This is useful when debugging commands. Default no assignment array&nbsp;ofstring&nbsp;pairs The name/value assignments for this command. comment string Comment attached to this command. Example { \"sequenceNumber\" : 1, \"origin\" : \"user@my-machine\", \"assignment\" : [ { \"name\": \"voltage_num\", \"value\": \"3\" } ], \"dryRun\" : true } Response Status: 200 OK { \"queue\" : \"default\", \"source\" : \"SWITCH_VOLTAGE_ON(voltage_num: 3)\", \"hex\" : \"1864C000000000000000006A0000000103\", \"binary\" : \"GGTAAAAAAAAAAABqAAAAAQM=\" } The binary is encoded in Base64 format. Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: rest/rest.proto message IssueCommandRequest { message Assignment { optional string name = 1; optional string value = 2; } repeated Assignment assignment = 1; optional string origin = 2; optional int32 sequenceNumber = 3; optional bool dryRun = 4; } Response rest/rest.proto message IssueCommandResponse { optional string queue = 1; optional string source = 2; optional string hex = 3; optional bytes binary = 4; } "},{"title":"LDAP AuthModule","url":"/docs/server/LDAP_AuthModule/","body":"The LDAP AuthModule supports authentication and authorization of users via the LDAP protocol. This module adds privileges to users through the use of roles: a user has specific roles, and some role is required for a specific privilege. All the user, role and privilege definitions are looked up in the LDAP database. Yamcs reads only LDAP objects of type groupOfNames. The algorithm used to build the list of user privileges is as follows: From the path configured by rolePath find all the roles associated to the user. The roles defined in LDAP must contain references using the member attribute to objects member=uid=username from the userPath. For each role found previously, do a search in the corresponding system, tc, tm packet or tm parameter path using the match member=cn=role_name. The cn of the matching entries is used to build the list of privileges that the user has. This class can be stacked with other AuthModules such that it is responsible for either authentication or authorization. In the case of authorization read-only access to the LDAP database is assumed. Class Name org.yamcs.security.LdapAuthModule Configuration Options Name Type Description host string Required. The LDAP host userPath string Required. The path to user definitions rolePath string The path to role definitions systemPath string The path to system privileges tmParameterPath string The path to ReadParameter object privileges tmPacketPath string The path to ReadPacket object privileges tcPath string The path to Command object privileges "},{"title":"Link Updates","url":"/docs/http/Link_Updates/","body":"The links resource type within the WebSocket API allows subscribing to link updates. Subscribe Within the WebSocket request envelope use these values: request-type links request subscribe This will make your web socket connection receive updates of the type ProtoDataType.LINK_EVENT. Here’s example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData). [1,2,3] [1,4,0,{\"dt\":\"LINK_EVENT\",\"data\":{\"type\":\"REGISTERED\",\"linkInfo\":{\"instance\":\"simulator\",\"name\":\"tm_realtime\",\"type\":\"TcpTmDataLink\",\"spec\":\"local\",\"stream\":\"tm_realtime\",\"disabled\":false,\"status\":\"UNAVAIL\",\"dataCount\":4344,\"detailedStatus\":\"Not connected to simulator:10015\"}}}] [1,4,1,{\"dt\":\"LINK_EVENT\",\"data\":{\"type\":\"REGISTERED\",\"linkInfo\":{\"instance\":\"simulator\",\"name\":\"tm_dump\",\"type\":\"TcpTmDataLink\",\"spec\":\"localDump\",\"stream\":\"tm_dump\",\"disabled\":false,\"status\":\"UNAVAIL\",\"dataCount\":0,\"detailedStatus\":\"Not connected to simulator:10115\"}}}] [1,4,2,{\"dt\":\"LINK_EVENT\",\"data\":{\"type\":\"REGISTERED\",\"linkInfo\":{\"instance\":\"simulator\",\"name\":\"tc1\",\"type\":\"TcpTcDataLink\",\"spec\":\"local\",\"stream\":\"tc_realtime\",\"disabled\":false,\"status\":\"UNAVAIL\",\"dataCount\":0,\"detailedStatus\":\"Not connected to simulator:10025\"}}}] The type of every LINK_EVENT can be either REGISTERED, UNREGISTERED or UPDATED. Directly after subscribing you will first get a REGISTERED link at that time. REGISTERED: a new link was registered. You also receive this event directly after you subscribe, for every link that is registered at that time. UNREGISTERED: a link was unregistered. UPDATED: a link was updated in one of its attributes, for example the dataCount has increased, or the status has changed. Unsubscribe Within the WebSocket request envelope use these values: request-type links request unsubscribe This will stop your WebSocket connection from getting further link updates. "},{"title":"Links","url":"/docs/http/Links/","body":" "},{"title":"List Alarms","url":"/docs/http/List_Alarms/","body":"List the active alarms for the given processor: GET /api/processors/:instance/:processor/alarms List the history of alarms: GET /api/archive/:instance/alarms List the history of alarms for the given parameter: GET /api/archive/:instance/alarms/:namespace/:name For each alarm the response contains detailed information on the value occurrence that initially triggered the alarm, the most severe value since it originally triggered, and the latest value at the time of your request. Parameters Name Type Description start string Filter the lower bound of the alarm's trigger time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the alarm's trigger time. Specify a date string in ISO 8601 format. This bound is exclusive. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The order of the returned results. Can be either asc or desc. The sorting is always by trigger time (i.e. the generation time of the trigger value). Default: desc Example Status: 200 OK { \"alarm\" : [ { \"seqNum\" : 1, \"triggerValue\" : { \"id\" : { \"name\" : \"/YSS/SIMULATOR/BatteryVoltage2\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 49 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 49 }, \"acquisitionTime\" : 1448229350720, \"generationTime\" : 1448229333628, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"monitoringResult\" : \"WATCH\", \"rangeCondition\": \"LOW\", \"acquisitionTimeUTC\" : \"2015-11-22T21:55:14.720Z\", \"generationTimeUTC\" : \"2015-11-22T21:54:57.628Z\", \"expirationTime\" : 1448229357720, \"expirationTimeUTC\" : \"2015-11-22T21:55:21.720Z\", \"alarmRange\" : [ { \"level\" : \"WATCH\", \"minInclusive\" : 50.0 }, { \"level\" : \"WARNING\", \"minInclusive\" : 40.0 }, { \"level\" : \"DISTRESS\", \"minInclusive\" : 30.0 }, { \"level\" : \"CRITICAL\", \"minInclusive\" : 20.0 }, { \"level\" : \"SEVERE\", \"minInclusive\" : 10.0 } ] }, \"mostSevereValue\" : { \"id\" : { \"name\" : \"/YSS/SIMULATOR/BatteryVoltage2\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 39 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 39 }, \"acquisitionTime\" : 1448229413038, \"generationTime\" : 1448229395945, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"monitoringResult\" : \"WARNING\", \"rangeCondition\": \"LOW\", \"acquisitionTimeUTC\" : \"2015-11-22T21:56:17.038Z\", \"generationTimeUTC\" : \"2015-11-22T21:55:59.945Z\", \"expirationTime\" : 1448229420038, \"expirationTimeUTC\" : \"2015-11-22T21:56:24.038Z\", \"alarmRange\" : [ { \"level\" : \"WATCH\", \"minInclusive\" : 50.0 }, { \"level\" : \"WARNING\", \"minInclusive\" : 40.0 }, { \"level\" : \"DISTRESS\", \"minInclusive\" : 30.0 }, { \"level\" : \"CRITICAL\", \"minInclusive\" : 20.0 }, { \"level\" : \"SEVERE\", \"minInclusive\" : 10.0 } ] }, \"currentValue\" : { \"id\" : { \"name\" : \"/YSS/SIMULATOR/BatteryVoltage2\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 48 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 48 }, \"acquisitionTime\" : 1448229356954, \"generationTime\" : 1448229339867, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"monitoringResult\" : \"WATCH\", \"rangeCondition\": \"LOW\", \"acquisitionTimeUTC\" : \"2015-11-22T21:55:20.954Z\", \"generationTimeUTC\" : \"2015-11-22T21:55:03.867Z\", \"expirationTime\" : 1448229363954, \"expirationTimeUTC\" : \"2015-11-22T21:55:27.954Z\", \"alarmRange\" : [ { \"level\" : \"WATCH\", \"minInclusive\" : 50.0 }, { \"level\" : \"WARNING\", \"minInclusive\" : 40.0 }, { \"level\" : \"DISTRESS\", \"minInclusive\" : 30.0 }, { \"level\" : \"CRITICAL\", \"minInclusive\" : 20.0 }, { \"level\" : \"SEVERE\", \"minInclusive\" : 10.0 } ] } } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListAlarmsResponse { repeated alarms.AlarmData alarm = 1; } "},{"title":"List Buckets","url":"/docs/http/List_Buckets/","body":"List all buckets for the given Yamcs instance: GET /api/buckets/:instance _global can be used as instance name to list the buckets at the global level. Response Status: 200 OK { \"buckets\": [{ \"name\": \"my_bucket\", \"size\": \"1542391\", \"numObjects\": 7 }, { \"name\": \"user.admin\", \"size\": \"1738\", \"numObjects\": 2 }] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message BucketInfo { optional string name = 1; optional uint64 size = 2; //total size in bytes of all objects in the bucket (metadata is not counted) optional uint32 numObjects = 3; //number of objects in the bucket } message ListBucketsResponse { repeated BucketInfo buckets = 1; } "},{"title":"List Clients","url":"/docs/http/List_Clients/","body":"List all clients: GET /api/clients List all clients for the given Yamcs instance: GET /api/instances/:instance/clients List all clients for the given processor: GET /api/processors/:instance/:processor/clients Response Status: 200 OK { \"client\": [{ \"instance\": \"simulator\", \"id\": 6, \"username\": \"admin\", \"applicationName\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15\", \"processorName\": \"realtime\", \"state\": \"CONNECTED\", \"loginTime\": \"1524258579036\", \"loginTimeUTC\": \"2018-04-20T21:09:02.036Z\" }] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListClientsResponse { repeated yamcsManagement.ClientInfo client = 1; } "},{"title":"List Command Info","url":"/docs/http/List_Command_Info/","body":"List all commands defined in the Mission Database for the given Yamcs instance: GET /api/mdb/:instance/commands Parameters Name Type Description namespace string Include commands under the specified namespace only recurse bool If a namespace is given, specifies whether to list commands of any nested sub systems. Default no. q string The search keywords. The q parameter supports searching on namespace or name. For example: /api/mdb/simulator/commands?q=volt+on Response Status: 200 OK { \"command\" : [ { \"name\": \"SWITCH_VOLTAGE_ON\", \"qualifiedName\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_ON\", \"alias\" : [ { \"name\" : \"SIMULATOR_SWITCH_VOLTAGE_ON\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"SWITCH_VOLTAGE_ON\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"baseCommand\" : { \"name\": \"SIM_TC\", \"qualifiedName\" : \"/YSS/SIMULATOR/SIM_TC\" }, \"abstract\" : false, \"argument\" : [ { \"name\" : \"voltage_num\", \"description\" : \"voltage number to switch on\", \"type\" : \"integer\", \"unitSet\" : [ { \"unit\" : \"V\" } ] } ], \"argumentAssignment\" : [ { \"name\" : \"packet-id\", \"value\" : \"1\" } ] } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListCommandInfoResponse { repeated mdb.CommandInfo command = 1; } "},{"title":"List Command Queues","url":"/docs/http/List_Command_Queues/","body":"List all command queues for the given processor: GET /api/processors/:instance/:processor/cqueues Response Status: 200 OK { \"queue\" : [ { \"instance\" : \"simulator\", \"processorName\" : \"realtime\", \"name\" : \"default\", \"state\" : \"ENABLED\", \"nbSentCommands\" : 0, \"nbRejectedCommands\" : 0 } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListCommandQueuesResponse { repeated commanding.CommandQueueInfo queue = 1; } "},{"title":"List Commands","url":"/docs/http/List_Commands/","body":"List the command history of all commands: GET /api/archive/:instance/commands List the command history of one specific command: GET /api/archive/:instance/commands/:namespace/:name Parameters Name Type Description start string Filter the lower bound of the command's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the command's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The order of the returned results. Can be either asc or desc. Default: desc The pos and limit allow for pagination. Keep in mind that in-between two requests extra data may have been recorded, causing a shift of the results. This stateless operation does not provide a reliable mechanism against that, so address it by overlapping your pos parameter with rows of the previous query. In this example we overlap by 4: ?pos=0&amp;limit=50&amp;order=desc ?pos=45&amp;limit=50&amp;order=desc An alternative is to download the command history instead. Response Status: 200 OK { \"entry\" : [ { \"commandId\" : { \"generationTime\" : 1491552506387, \"origin\" : \"user@my-machine\", \"sequenceNumber\" : 1, \"commandName\" : \"/YSS/SIMULATOR/DUMP_RECORDING\" }, \"attr\" : [ { \"name\" : \"binary\", \"value\" : { \"type\" : \"BINARY\", \"binaryValue\" : \"GGTAAAAAAAAAAABqAAAABnNkZnFzZgAAAAAH\" } }, { \"name\" : \"username\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"admin\" } }, { \"name\" : \"source\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"YSS/SIMULATOR/DUMP_RECORDING(filename: \\\"sdfqsf\\\", speed: 7)\" } }, { \"name\" : \"TransmissionConstraints\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"NA\" } }, { \"name\" : \"Final_Sequence_Count\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"80\" } }, { \"name\" : \"Acknowledge_FSC_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK: OK\" } }, { \"name\" : \"Acknowledge_FSC_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552507470 } }, { \"name\" : \"Acknowledge_FRC_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK: OK\" } }, { \"name\" : \"Acknowledge_FRC_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552507870 } }, { \"name\" : \"Acknowledge_DASS_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK: OK\" } }, { \"name\" : \"Acknowledge_DASS_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552508270 } }, { \"name\" : \"Acknowledge_MCS_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK: OK\" } }, { \"name\" : \"Acknowledge_MCS_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552508670 } }, { \"name\" : \"Acknowledge_A_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK A: OK\" } }, { \"name\" : \"Acknowledge_A_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552509070 } }, { \"name\" : \"Acknowledge_B_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK B: OK\" } }, { \"name\" : \"Acknowledge_B_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552510070 } }, { \"name\" : \"Acknowledge_C_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK C: OK\" } }, { \"name\" : \"Acknowledge_C_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552511070 } }, { \"name\" : \"Acknowledge_D_Status\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"ACK D: OK\" } }, { \"name\" : \"Acknowledge_D_Time\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1491552517070 } } ] } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Responses are of type: rest/rest.proto message ListCommandsResponse { repeated commanding.CommandHistoryEntry entry = 1; } "},{"title":"List Container Info","url":"/docs/http/List_Container_Info/","body":"List all containers defined in the Mission Database for the given Yamcs instance: GET /api/mdb/:instance/containers Parameters Name Type Description namespace string Include containers under the specified namespace only recurse bool If a namespace is given, specifies whether to list containers of any nested sub systems. Default no. q string The search keywords. The q parameter supports searching on the namespace or name. For example: /api/mdb/simulator/containers?q=yss+dhs Response Status: 200 OK { \"container\" : [ { \"name\": \"DHS\", \"qualifiedName\" : \"/YSS/SIMULATOR/DHS\", \"alias\" : [ { \"name\" : \"SIMULATOR_DHS\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"DHS\", \"namespace\" : \"/YSS/SIMULATOR\" } ], \"maxInterval\" : 1500, \"baseContainer\" : { \"name\": \"ccsds-default\", \"qualifiedName\" : \"/YSS/ccsds-default\" }, \"restrictionCriteria\" : [ { \"parameter\" : { \"name\": \"ccsds-apid\", \"qualifiedName\" : \"/YSS/ccsds-apid\" }, \"operator\" : \"EQUAL_TO\", \"value\" : \"1\" }, { \"parameter\" : { \"name\": \"packet-id\", \"qualifiedName\" : \"/YSS/packet-id\" }, \"operator\" : \"EQUAL_TO\", \"value\" : \"2\" } ], \"entry\" : [ { \"locationInBits\" : 128, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"PrimBusVoltage1\", \"qualifiedName\" : \"/YSS/SIMULATOR/PrimBusVoltage1\" } }, { \"locationInBits\" : 136, \"referenceLocation\" : \"CONTAINER_START\", \"parameter\" : { \"name\": \"PrimBusCurrent1\", \"qualifiedName\" : \"/YSS/SIMULATOR/PrimBusCurrent1\" } } ] } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListContainerInfoResponse { repeated mdb.ContainerInfo container = 1; } "},{"title":"List Events","url":"/docs/http/List_Events/","body":"List the history of events: GET /api/archive/:instance/events/ Parameters Name Type Description severity string The minimum severity level of the events. One of info, watch, warning, distress, critical or severe. Default: info q string Text to search for in the message. source array of strings The source of the events. Both these notations are accepted: ?source=DataHandler,CustomAlgorithm ?source[]=DataHandler&amp;source[]=CustomAlgorithm Names must match exactly. start string Filter the lower bound of the event's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the event's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The order of the returned results. Can be either asc or desc. Default: desc The pos and limit allow for pagination. Keep in mind that in-between two requests extra data may have been recorded, causing a shift of the results. This stateless operation does not provide a reliable mechanism against that, so address it by overlapping your pos parameter with rows of the previous query. In this example we overlap by 4: ?pos=0&amp;limit=50&amp;order=desc ?pos=45&amp;limit=50&amp;order=desc An alternative is to download the events instead. Response Status: 200 OK { \"event\" : [ { \"source\" : \"AlarmChecker\", \"generationTime\" : 1447425863786, \"receptionTime\" : 1447425863786, \"seqNumber\" : 15, \"type\" : \"IN_LIMITS\", \"message\" : \"Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 222\", \"severity\" : \"INFO\", \"generationTimeUTC\" : \"2015-11-13T14:43:47.786Z\", \"receptionTimeUTC\" : \"2015-11-13T14:43:47.786Z\" } ] } Alternative Media Types CSV Use HTTP header: Accept: text/csv Or, add this query parameter to the URI: format=csv. Response: Status: 200 OK Content-Type: text/csv Source Generation Time Reception Time Event Type Event Text AlarmChecker 2015-11-13T14:46:36.029Z 2015-11-13T14:46:36.029Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 195 AlarmChecker 2015-11-13T14:46:29.784Z 2015-11-13T14:46:29.784Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 196 AlarmChecker 2015-11-13T14:46:23.571Z 2015-11-13T14:46:23.571Z IN_LIMITS Parameter /YSS/SIMULATOR/BatteryVoltage2 has changed to value 197 Protobuf Use HTTP header: Accept: application/protobuf Responses are of type: rest/rest.proto message ListEventsResponse { repeated yamcs.Event event = 1; } "},{"title":"List Instances","url":"/docs/http/List_Instances/","body":"List all configured Yamcs instances: GET /api/instances Response Status: 200 OK { \"instance\" : [ { \"name\" : \"simulator\", \"missionDatabase\" : { \"configName\" : \"landing\", \"name\" : \"\", \"spaceSystem\" : [ { \"name\" : \"yamcs\", \"qualifiedName\" : \"/yamcs\" }, { \"name\" : \"YSS\", \"qualifiedName\" : \"/YSS\", \"sub\" : [ { \"name\" : \"SIMULATOR\", \"qualifiedName\" : \"/YSS/SIMULATOR\" } ] }, { \"name\" : \"GS\", \"qualifiedName\" : \"/GS\" } ] }, \"processor\" : [ { \"name\" : \"realtime\" } ] } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListInstancesResponse { repeated yamcsManagement.YamcsInstance instance = 1; } "},{"title":"List Links","url":"/docs/http/List_Links/","body":"List all links: GET /api/links List all links for the given Yamcs instance: GET /api/links/:instance Response Status: 200 OK { \"link\" : [ { \"instance\" : \"simulator\", \"name\" : \"tm1\", \"type\" : \"HkDataHandler\", \"spec\" : \"\", \"stream\" : \"tm_realtime\", \"disabled\" : false, \"status\" : \"OK\", \"dataCount\" : 34598, \"detailedStatus\" : \"reading files from /storage/yamcs-incoming/simulator/tm\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListLinkInfoResponse { repeated yamcsManagement.LinkInfo link = 1; } "},{"title":"List Objects","url":"/docs/http/List_Objects/","body":"List all objects from a bucket GET /api/buckets/:instance/:bucketName _global can be used as instance name to list the objects from a bucket at the global level. Parameters Name Type Description prefix string List only objects whose name start with prefix delimiter string Return only objects whose name do not contain the delimiter after the prefix. For the other objects, the response contains (in the prefix response parameter) the name truncated after the delimiter. Duplicates are omitted. The parameters prefix and delimiter provide filtering capabilities. These work similar to Google Cloud Storage and Amazon S3. The delimiter allows the list to work in a directory mode despite the object namespace being flat. For example if the delimiter is set to “/”, then listing the bucket containing objects “a/b”, “a/c”, “d”, “e” and “e/f” returns objects “d” and “e” and prefixes “a/” and “e/”. Response Status: 200 OK { \"prefix\": [ \"a/\"], \"object\": [{ \"name\": \"request-example-to-REST-Archive-CSV-API.txt\", \"created\": \"2018-05-28T08:25:19.809Z\", \"size\": \"869\" }] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ObjectInfo { optional string name = 1; optional string created = 2; //time in UTC format optional uint64 size = 3; //size in bytes map&lt;string, string&gt; metadata = 4; } message ListObjectsResponse { repeated string prefix = 1; repeated ObjectInfo object = 2; } "},{"title":"List Packets","url":"/docs/http/List_Packets/","body":"List the history of packets: GET /api/archive/:instance/packets List the packets for the specified generation time GET /api/archive/:instance/packets/:gentime The :gentime must be in ISO 8601 format. E.g. 2015-10-20T06:47:02.000Z Parameters Name Type Description name array of strings The archived name of the packets. Both these notations are accepted: ?name=/YSS/SIMULATOR/DHS,/YSS/SIMULATOR/Power ?name[]=/YSS/SIMULATOR/DHS&amp;name[]=/YSS/SIMULATOR/Power Names must match exactly. start string Filter the lower bound of the packet's generation time. Specify a date string in ISO 8601 format. This bound is inclusive. stop string Filter the upper bound of the packet's generation time. Specify a date string in ISO 8601 format. This bound is exclusive. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The order of the returned results. Can be either asc or desc. Default: desc The pos and limit allow for pagination. Keep in mind that in-between two requests extra data may have been recorded, causing a shift of the results. This generic stateless operation does not provide a reliable mechanism against that, so address it by overlapping your pos parameter with rows of the previous query. In this example we overlap by 4: ?pos=0&amp;limit=50&amp;order=desc ?pos=45&amp;limit=50&amp;order=desc An alternative is to download the packets instead. Response Status: 200 OK { \"packet\" : [ { \"receptionTime\" : 1447625895283, \"packet\" : \"CAEAAABFQ3PHAzxFAAAAIUMCgADCcgxKQlS0OUYh0ADDClmaP9AnUj9yMP1DV9wpQ1fcKT85frs/dofTQwErhUJLPXHCDdLywwpZmg==\", \"generationTime\" : 1447625878234, \"sequenceNumber\" : 134283264 } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListPacketsResponse { repeated yamcs.TmPacketData packet = 1; } "},{"title":"List Parameter Data","url":"/docs/http/List_Parameter_Data/","body":"List the history of values for the specified parameter: GET /api/archive/:instance/parameters/:namespace/:name Parameters Name Type Description start string Filter the lower bound of the parameter's generation time. Specify a date string in ISO 8601 format stop string Filter the upper bound of the parameter's generation time. Specify a date string in ISO 8601 format norepeat bool Whether to filter out consecutive identical values. Default no. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The order of the returned results. Can be either asc or desc. Default: desc norealtime boolean Disable loading of parameters from the parameter cache. Default: false processor string The name of the processor from which to use the parameter cache. Default: realtime source string Specifies how to retrieve the parameters. Either ParameterArchive or replay. If replay is specified, a replay processor will be created and data will be processed with the active XTCEDB. Note that this is much slower than receiving data from the ParameterArchive.Default: ParameterArchive The pos and limit allow for pagination. Keep in mind that in-between two requests extra data may have been recorded, causing a shift of the results. This generic stateless operation does not provide a reliable mechanism against that, so address it by overlapping your pos parameter with rows of the previous query. In this example we overlap by 4: ?pos=0&amp;limit=50&amp;order=desc ?pos=45&amp;limit=50&amp;order=desc When using CSV output some columns are hidden by default. You can add them via the extra flag: Name Type Description extra array of strings Extra columns added to the CSV output: raw: Raw parameter values monitoring: Monitoring status Example: ?extra=raw,monitoring Response Status: 200 OK { \"parameter\" : [ { \"id\" : { \"name\" : \"BatteryVoltage2\", \"namespace\" : \"/YSS/SIMULATOR\" }, \"rawValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 144 }, \"engValue\" : { \"type\" : \"UINT32\", \"uint32Value\" : 144 }, \"acquisitionTime\" : 1447417449218, \"generationTime\" : 1447417432121, \"acquisitionStatus\" : \"ACQUIRED\", \"processingStatus\" : true, \"monitoringResult\" : \"IN_LIMITS\", \"acquisitionTimeUTC\" : \"2015-11-13T12:23:33.218Z\", \"generationTimeUTC\" : \"2015-11-13T12:23:16.121Z\", \"expirationTime\" : 1447417456218, \"expirationTimeUTC\" : \"2015-11-13T12:23:40.218Z\", \"alarmRange\" : [ { \"level\" : \"WATCH\", \"minInclusive\" : 50.0 }, { \"level\" : \"WARNING\", \"minInclusive\" : 40.0 }, { \"level\" : \"DISTRESS\", \"minInclusive\" : 30.0 }, { \"level\" : \"CRITICAL\", \"minInclusive\" : 20.0 }, { \"level\" : \"SEVERE\", \"minInclusive\" : 10.0 } ] } ] } Alternative Media Types CSV Use HTTP header: Accept: text/csv Or, add this query parameter: format=csv. Status: 200 OK Content-Type: text/csv Time BatteryVoltage2 2015-11-13T12:21:55.199 157 2015-11-13T12:21:48.972 158 2015-11-13T12:21:42.750 159 Protobuf Use HTTP header: Accept: application/protobuf Response is of type: pvalue/pvalue.proto message ParameterData { repeated ParameterValue parameter = 1; } "},{"title":"List Parameter Info","url":"/docs/http/List_Parameter_Info/","body":"List all parameters defined in the Mission Database for the given Yamcs instance: GET /api/mdb/:instance/parameters Parameters Name Type Description namespace string Include parameters under the specified namespace only recurse bool If a namespace is given, specifies whether to list parameters of any nested sub systems. Default no. type array of strings The parameter types to be included in the result. Valid types are boolean, binary, enumeration, float, integer or string. Both these notations are accepted: ?type=float,integer ?type[]=float&amp;type[]=integer If unspecified, parameters of all types will be included. q string The search keywords. pos integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned parameters per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 The q parameter supports searching on namespace or name. For example: /api/mdb/simulator/parameters?q=ccsds+yss Response Status: 200 OK { \"parameter\" : [ { \"name\": \"ccsds-apid\", \"qualifiedName\" : \"/YSS/ccsds-apid\", \"alias\" : [ { \"name\" : \"YSS_ccsds-apid\", \"namespace\" : \"MDB:OPS Name\" }, { \"name\" : \"ccsds-apid\", \"namespace\" : \"/YSS\" } ], \"type\" : { \"engType\" : \"integer\", \"dataEncoding\" : \"IntegerDataEncoding(sizeInBits:11, encoding:unsigned, defaultCalibrator:null byteOrder:BIG_ENDIAN)\" }, \"dataSource\" : \"TELEMETERED\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListParameterInfoResponse { repeated mdb.ParameterInfo parameter = 1; } "},{"title":"List Processors","url":"/docs/http/List_Processors/","body":"List all processors, across all Yamcs instances: GET /api/processors List all processors for the given Yamcs instance: GET /api/processors/:instance Parameters Name Type Description type string Indicates the type of the processors to return. Can be either replay, realtime or all. Default: all Response Status: 200 OK { \"processor\" : [ { \"instance\" : \"simulator\", \"name\" : \"realtime\", \"type\" : \"realtime\", \"creator\" : \"system\", \"hasCommanding\" : true, \"state\" : \"RUNNING\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListProcessorsResponse { repeated yamcsManagement.ProcessorInfo processor = 1; } "},{"title":"List Queued Commands","url":"/docs/http/List_Queued_Commands/","body":"List all queued command entries for the given command queue: GET /api/processors/:instance/:processor/cqueues/:name/entries Response Status: 200 OK { \"entry\" : [ { \"instance\" : \"simulator\", \"processorName\" : \"realtime\", \"queueName\" : \"default\", \"cmdId\" : { \"generationTime\" : 1448782973440, \"origin\" : \"000349-WS.local\", \"sequenceNumber\" : 5, \"commandName\" : \"/YSS/SIMULATOR/SWITCH_VOLTAGE_OFF\" }, \"source\" : \"SWITCH_VOLTAGE_OFF(voltage_num: 2)\", \"binary\" : \"GGTAAAAAAAAAAABqAAAAAgI=\", \"username\" : \"anonymous\", \"generationTime\" : 1448782973440, \"uuid\" : \"3e867111-048a-4343-b195-47ba07d07093\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListCommandQueueEntries { repeated commanding.CommandQueueEntry entry = 1; } "},{"title":"List Services","url":"/docs/http/List_Services/","body":"List global services: GET /api/services/_global List all services for the given Yamcs instance: GET /api/services/:instance Response Status: 200 OK { \"service\" : [ { \"instance\" : \"simulator\", \"name\" : \"org.yamcs.tctm.DataLinkInitialiser\", \"state\" : \"RUNNING\" }, { \"instance\" : \"simulator\", \"name\" : \"org.yamcs.archive.XtceTmRecorder\", \"state\" : \"RUNNING\" }, { \"instance\" : \"simulator\", \"name\" : \"org.yamcs.archive.FSEventDecoder\", \"state\" : \"RUNNING\" }, { \"instance\" : \"simulator\", \"name\" : \"org.yamcs.archive.PpRecorder\", \"state\" : \"RUNNING\" } ... ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListServiceInfoResponse { repeated yamcsManagement.ServiceInfo service = 1; } "},{"title":"List Streams","url":"/docs/http/List_Streams/","body":"List all streams for the given instance: GET /api/archive/:instance/streams This is low-level API for those cases where access to the internal streams of Yamcs is wanted. It is recommended to use other API operations for any of the default built-in streams. Example Status: 200 OK { \"stream\" : [ { \"name\" : \"tm_realtime\", \"column\" : [ { \"name\" : \"gentime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"seqNum\", \"type\" : \"INT\" }, { \"name\" : \"rectime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"packet\", \"type\" : \"BINARY\" } ] } ] } Note that this will only list the fixed columns of the stream. Tuples may always have extra columns. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListStreamsResponse { repeated archive.StreamInfo stream = 1; } "},{"title":"List Table Data","url":"/docs/http/List_Table_Data/","body":"List the most recent data of a Yamcs table: GET /api/archive/:instance/tables/:table/data This is low-level API for those cases where access to an internal key/value table of Yamcs is wanted. It is recommended to use other API operations for any of the default built-in tables. Parameters Name Type Description cols array of strings The columns to be included in the result. Both these notations are accepted: ?cols=rectime,gentime,pname ?cols[]=rectime&amp;cols[]=gentime&amp;cols[]=pname If unspecified, all table and/or additional tuple columns will be included. start integer The zero-based row number at which to start outputting results. Default: 0 limit integer The maximum number of returned records per page. Choose this value too high and you risk hitting the maximum response size limit enforced by the server. Default: 100 order string The direction of the sort. Sorting is always done on the key of the table. Can be either asc or desc. Default: desc The start and limit allow for pagination. Keep in mind that in-between two requests extra data may have been added to the table, causing a shift of the results. This generic stateless operation does not provide a reliable mechanism against that, so address it by overlapping your start parameter with rows of the previous query. In this example we overlap by 4: ?start=0&amp;limit=50&amp;order=desc ?start=45&amp;limit=50&amp;order=desc Response Status: 200 OK { \"record\" : [ { \"column\" : [ { \"name\" : \"gentime\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1446650363464 } }, { \"name\" : \"pname\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"/YSS/SIMULATOR/FlightData\" } } ] }, { \"column\" : [ { \"name\" : \"gentime\", \"value\" : { \"type\" : \"TIMESTAMP\", \"timestampValue\" : 1446650363667 } }, { \"name\" : \"pname\", \"value\" : { \"type\" : \"STRING\", \"stringValue\" : \"/YSS/SIMULATOR/FlightData\" } } ] } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: archive/archive.proto message TableData { message TableRecord { repeated ColumnData column = 1; } repeated TableRecord record = 1; } "},{"title":"List Tables","url":"/docs/http/List_Tables/","body":"List all tables for the given instance: GET /api/archive/:instance/tables This is low-level API for those cases where access to the internal key/value tables of Yamcs is wanted. It is recommended to use other API operations for any of the default built-in tables. Example Status: 200 OK { \"table\" : [ { \"name\" : \"tm\", \"keyColumn\" : [ { \"name\" : \"gentime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"seqNum\", \"type\" : \"INT\" } ], \"valueColumn\" : [ { \"name\" : \"rectime\", \"type\" : \"TIMESTAMP\" }, { \"name\" : \"packet\", \"type\" : \"BINARY\" }, { \"name\" : \"pname\", \"type\" : \"ENUM\" } ] } ] } Note that this will only list the fixed columns of the table. Tuples may always add extra value columns. Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListTablesResponse { repeated archive.TableInfo table = 1; } "},{"title":"List Tags","url":"/docs/http/List_Tags/","body":"List all tags for the given instance: GET /api/archive/:instance/tags Example Status: 200 OK { \"tag\" : [ { \"id\" : 1, \"name\" : \"My annotation\", \"start\" : 1449128432000, \"stop\" : 1449174255000, \"description\" : \"blabla\", \"color\" : \"#ffc800\" } ] } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: rest/rest.proto message ListTagsResponse { repeated yamcs.ArchiveTag tag = 1; } "},{"title":"Load Table Data","url":"/docs/http/Load_Table_Data/","body":"Load data into a table: POST /api/archive/:instance/tables/:name/data Use HTTP header (antyhing else is not supported): Content-Type: application/protobuf The data is a stream of Rows, each Row being composed of a list of Cells. Each Row is preceded by its size in bytes varint encoded. Each row has an optional associated list of ColumnInfo messages that define the table columns conainted in the row. The message assigns an integer id for each column and the id is present in each cell belonging to that column (this is done in order to avoid sending the ColumnInfo with each Cell). The column id starts from 0 and is incremented with each new column present in the load. The ids are only valid during one single load. The table has to exist in order to load data into it. Chuncked data encoding can be used to send a large number of rows without knowing the total size in advance. table/table.proto message ColumnInfo { optional uint32 id = 1; optional string name = 2; //one of the types defined in org.yamcs.yarch.DataType //INT, STRING, DOUBLE, PROTOBUF(x.y.z), etc optional string type = 3; } message Cell { optional uint32 columnId = 1; optional bytes data = 2; } message Row { //the column info is only present for new columns in a stream of Row messages repeated ColumnInfo column = 1; repeated Cell cell = 2; } Response Response can be PROTOBUF or JSON depending on the “Accept” header of the request. Status: 200 OK table/table.proto message TableLoadResponse { optional uint32 numRowsLoaded = 1; } Status: 400 BAD_REQUEST rest/rest.proto message RestExceptionMessage { optional string type = 1; optional string msg = 2; optional uint32 numRowsLoaded = 100; } If there is an error during the load, the HTTP status will be 4xy or 5xy and the msg will contain more information about the error. One possible error could be that the table has defined a (primary) key and one of the loaded rows contains no value for one of the columns of the key. As the data is streamed to the server, if there is an error, there would have been certanly more data sent after the bad row, so the error is not about the last row sent. The numRowsLoaded response parameter can be used to know how many rows have been successfully loaded (the bad row is the numRowsLoaded+1 in the stream). Note that if the server detects an error, it will send back the error message and close the connection regardless of the Keep-Alive option in the request header. "},{"title":"Local Parameter Manager","url":"/docs/server/Local_Parameter_Manager/","body":"Manages and provides local parameters. Class Name org.yamcs.parameter.LocalParameterManager Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.parameter.LocalParameterManager "},{"title":"Logging","url":"/docs/server/Logging/","body":"Yamcs Server writes log output to the directory /opt/yamcs/log. yamcs-server.log.x Log files usually provide the best debug information. These contain log entries that are emitted by any of the Yamcs components with a fine level of detail. Log files are rotated at 20MB with a maximum of 50 files. The theoretic maximum of disk space is therefore 1GB. x is a sequence number. The lower the number, the more recent the logs. The most recent log file can always be found at /opt/yamcs/log/yamcs-server.log.0. Note that when Yamcs Server is restarted the log files will always rotate even if yamcs-server.log.0 had not yet reached 20MB. yamcs-server.out.x Out files are directly captured from the process standard output and error streams. The logging level is typically less detailed then with yamcs-server.log.x, but the files may contain stdout and stderr output which does not make use of Yamcs’ logging system. Out files are rotated over a maximum of 5 files. There is no size restriction on the file, but since the logging is not so detailed, the files do not grow very large. x is a sequence number. The lower the number, the more recent the logs. The most recent out file can always be found at /opt/yamcs/log/yamcs-server.out.0. Note that when Yamcs Server is restarted the out files will always rotate. Configuration The logging properties of Yamcs Server may be adjusted to your specific situation. This is done by modifying the file /opt/yamcs/etc/logging.yamcs-server.properties. The file structure is defined by the standard Java logging framework and requires a bit of background with Java development. There are two handlers. A FileHandler defines the properties used for logging to /opt/yamcs/log/yamcs-server.log.x. A ConsoleHandler can be used to tweak output for logging to /opt/yamcs/log/yamcs-server.out.x. The rotation of out files is not configured in this file, since this occurs at the level of the init system where the Yamcs process is managed. Yamcs comes with different log formatters that can be useful in different situations: org.yamcs.CompactFormatter outputs one line per log entry and contains detailed datetime information, thread id, severity, logger name (typically the class of the originating component), a log message and finally an optional stack trace. org.yamcs.ConsoleFormatter outputs one line per log entry and is actually more compact than CompactFormatter. It is especially suited for development of Yamcs or its extensions. Each log entry contains short time information, thread id, short class name, a log message and optionally a stack trace. Some entry fields make use of ANSI color codes for colorized display inside the developer’s terminal. "},{"title":"MDB","url":"/docs/server/MDB/","body":"The MDB module within the Yamcs web interface provides a set of views on the Mission Database. The Monitor Module is always visited for a specific Yamcs instance. The MDB for an instance aggregates the content of the entire MDB loader tree for that instance. Space Systems Space systems represent the highest conceptual entity of the MDB. Space systems act like folders and may contain other space systems, parameters, containers and others. The Space Systems view shows a flat list of all space systems in the MDB. By clicking on one of the entires, you can navigate to a detail view for the space system which shows the parameters, containers, commands and algorithms that directly belong to that space system. Parameters The Parameters view shows a filterable list of all parameters inside the MDB. If you are searching for a specific parameter but don’t remember the space system this views can help find it quickly. You can navigate to the detail page of any parameter to see a quick look at its definition, and to see the current realtime value. If the parameter has numeric values, its data can also be rendered on a chart. This chart is updated in realtime. Finally the detail page of a parameter also has a view that allows looking at the exact data points that have been received in a particular time range. This information is presented in a paged view. There is a download option available for downloading data points of the selected time range as a CSV file for offline analysis. If the parameter is a software parameter, its value can be set via a button in the toolbar. Containers The Containers view shows a filterable list of all containers inside the MDB. The detail page allows seeing the parameter or container entries for this container and offers navigation links for quick access. Commands The Commands view shows a filterable list of all commands inside the MDB. This also includes abstract commands. Non-abstract commands can be issued directly from the detail page of that command. This opens a dynamic dialog window where you can override default arguments and enter missing arguments. Algorithms The Algorithms view shows a filterable list of all algorithms inside the MDB. This detail page provides a quick navigation list of all input and output parameters and shows the script for this algorithm. "},{"title":"Management Updates","url":"/docs/http/Management_Updates/","body":"The management resource type within the WebSocket API groups general Yamcs info that does not fit under a specific other resource type. Subscribe to Management Updates Within the WebSocket request envelope use these values: request-type management request subscribe This will make your web socket connection receive updates on the following Yamcs data types (aka ProtoDataType): CLIENT_INFO Updates on a client that is or was connected to Yamcs. Directly after sending a management/subscribe request, you will also get an update for all the clients that are connected at that point. As soon as a client is disconnected, you will also get an update on that. Here’s example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData), where there are two anonymous clients connected to a non-secured deployment of Yamcs: [1,2,3] [1,4,1,{\"dt\":\"CLIENT_INFO\",\"data\":{\"instance\":\"simulator\",\"id\":1,\"username\":\"unknown\",\"applicationName\":\"Unknown\",\"processorName\":\"realtime\",\"state\":0,\"currentClient\":false}}] [1,4,2,{\"dt\":\"CLIENT_INFO\",\"data\":{\"instance\":\"simulator\",\"id\":3,\"username\":\"unknown\",\"applicationName\":\"Unknown\",\"processorName\":\"realtime\",\"state\":0,\"currentClient\":true}}] After the empty initial ACK, we receive two data messages, one for each connected client at that point. Notice the currentClient field which indicates whether this client info concerns your own web socket session. The state field indicates either CONNECTED (0) or DISCONNECTED (1). In case the other use would close its connection, we would thus get an update on that too. PROCESSOR_INFO Updates on the lifecycle of Yamcs TM/TC processors. Directly after sending a management/subscribe request, you will also get an update for all the processors at that point. Here’s an example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData), where there is just one processor realtime. [1,2,3] [1,4,0,{\"dt\":\"PROCESSOR_INFO\",\"data\":{\"instance\":\"simulator\",\"name\":\"realtime\",\"type\":\"realtime\",\"creator\":\"system\",\"hasCommanding\":true,\"state\":2}}] PROCESSING_STATISTICS General statistics on processors. For every high-level packet, shows you the the current processing time, an increasing data count, and many more info. Updates on this data type are a bit noisier than the client_info/processor_info updates, so we may decide to move this out to a different subscription request in the future. Here’s an example output in JSON (with Protobuf, there’s an applicable getter in the WebSocketSubscriptionData): [1,4,3,{\"dt\":\"PROCESSING_STATISTICS\",\"data\":{\"instance\":\"simulator\",\"yProcessorName\":\"realtime\",\"tmstats\":[{\"packetName\":\"RCS\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":12},{\"packetName\":\"FlightData\",\"receivedPackets\":73718,\"lastReceived\":1438235693321,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":15},{\"packetName\":\"ccsds-default\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":3},{\"packetName\":\"Power\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":12},{\"packetName\":\"DHS\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":9}],\"lastUpdated\":1438235657322}}] [1,4,4,{\"dt\":\"PROCESSING_STATISTICS\",\"data\":{\"instance\":\"simulator\",\"yProcessorName\":\"realtime\",\"tmstats\":[{\"packetName\":\"RCS\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":12},{\"packetName\":\"FlightData\",\"receivedPackets\":73723,\"lastReceived\":1438235694328,\"lastPacketTime\":1438235677324,\"subscribedParameterCount\":15},{\"packetName\":\"ccsds-default\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":3},{\"packetName\":\"Power\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":12},{\"packetName\":\"DHS\",\"receivedPackets\":2378,\"lastReceived\":1438235693322,\"lastPacketTime\":1438235676320,\"subscribedParameterCount\":9}],\"lastUpdated\":1438235658328}}] Get Client-Info Within the WebSocket request envelope use these values: request-type management request getClientInfo This will return you a one-time data frame containing your own client info. The format is exactly the same as for the above described subscription updates. "},{"title":"Mission Database","url":"/docs/server/Mission_Database/","body":"The Yamcs Mission Database is composed of a hierarchical structure, each node in the hierarchy being an XTCE SpaceSystem. Each SpaceSystem contains the following data: Telemetry Telecommands Parameters Algorithms For faster access, the database is cached serialized on disk in the cache directory. The cached mission database is composed of two files, one storing the data itself and the other one storing the time when the cache file has been created. These files should be considered Yamcs internal and are subject to change. Different loaders are possible for each node in the hiearchy. A loader can load a node and its subnodes (but cannot load two parallel nodes). mdb.yaml refmdb: - type: \"sheet\" spec: \"mdb/refmdb-ccsds.xls\" subLoaders: - type: \"sheet\" spec: \"mdb/refmdb-subsys1.xls\" simulator: - type: \"sheet\" spec: \"mdb/simulator-ccsds.xls\" subLoaders: - type: \"sheet\" spec: \"mdb/simulator-tmtc.xls\" "},{"title":"Mission Database","url":"/docs/http/Mission_Database/","body":" "},{"title":"Monitor","url":"/docs/server/Monitor/","body":"The Monitor module within the Yamcs web interface provides typical operational views. The Monitor Module is always visited for a specific Yamcs instance and processor. Every view has in the top right corner an indicator that shows the current processor and that shows the time for that processor. From this widget, you can choose to start a replay of past data. When that happens, you will switch to this replay processor and would see the widget reflecting the replay time. Displays Shows the displays or display resources that are known by Yamcs Server for the selected instance. The displays in this view are presented in a file browser with the usual operations to rename, move or create. Clicking on a display file opens the display. If there is incoming telemetry this will be received by the opened display file. Note that only some display types are supported by the Yamcs web interface. The following provides an overview of the current state: Extension Display type View Edit opi Yamcs Studio displays Planned No plans to support(use Yamcs Studio) uss USS displays Advanced support No plans to support(use USS Editor) par Parameter tables Full support Full support In addition there is file preview support for the following display resources: Extension Resource type View Edit png, gif, bmp, jpg, jpeg Image Full support No plans to support js Script file Full support Planned Any other file is displayed in a basic text viewer. Displays may be visualized in full screen, which helps remove distractions. This will not scale the display, so make use of the zoom in/out buttons before going full screen if you would like your display to appear larger. Layouts A layout allows to combine multiple displays in a single view. This is particularly useful if your displays are small. Layouts are personal and are linked to your user account. Create a layout via the “Create Layout” button in the toolbar. Open any number of displays via the sidebar and organize them together. Click “Save” when you want to save the changes to your layout for later use. Individual display frames can be zoomed in or out by dragging the corner in the right-bottom. A layout may be visualized in full screen, which helps remove distractions. Events This section provides a view on Yamcs events. By default only the latest events within the last hour get shown. The view offers ample filter options to change which events are shown. The table is paged to prevent overloading the browser. If you like to see beyond the current page, you can click the button ‘Load More’ at the bottom of the view. Alternatively you can choose to click the ‘Download Data’ button at the top right. This will trigger a download of the events in CSV format. The download will apply the same filter as what is shown in the view. The Events table can also monitor incoming events on the current processor. Do so by clicking the play button in the top toolbar. You may stop the live streaming at any time by clicking the pause button. The Events table has a severity filter. This filter allows defining the minimum severity of the event. Events that are more severe than the selected severity will also be shown. By default the severity filter is set to the lowest severity, Info, which means that all events will be shown. With the right privilege, it is possible to manually post an event. You can enter an arbitrary message and assign a severity. The time of the event will by default be set to the current time, but you can override this if preferred. The source of an event created this way will automatically be set to User and will contain a user attribute indicating your username. Alarms Shows an overview of the current alarms. Alarms indicate parameters that are out of limits. Commands Shows the latest issued commands. TM Archive This view allows inspecting the content of the TM Archive, as well as retrieving data as packets. Data is grouped by packet name in bands. For each band, index blocks indicate the presence of data at a particular time range. Note that a single index block does not necessarily mean that there was no gap in the data. When zooming in, more gaps may appear. The view can be panned by grabbing the canvas. For long distances you can jump to a specific location via the Jump to… button. This view shows the current mission time with a vertical locator. While the now locator follows mission time, the rendered blocks do not follow realtime. You can force a refresh by panning the canvas or refreshing your browser window. In the top toolbar there are a few actions that only become active once you make a horizontal range selection. To make such a selection you can start a selection on the timescale band. Alternatively you may also select a range by simply clicking an index block. Selecting a range allows you to start a replay for that range, or to download raw packet data. "},{"title":"Monitor Widgets","url":"/docs/studio/Monitor_Widgets/","body":"LED By default LED widgets are dark green, and light up when the connected PV is non-zero. Using the State Count the number of states can be increased to more than two. When doing so, a number of extra properties will be added in the Properties view. You then need to set explicit colors per value. Image Boolean Indicator With the Image Boolean Indicator you can render images depending on the ON or OFF state of the connected PV. The images need to be part of your workspace. Among other use cases, this widget provides a practical way to replace the default LED widget with your own custom styling. Text Update The Text Update widget shows the textual value of the connected PV. The format can be controlled using properties like Precision and Format Type. Both the background and the foreground color can be made alarm-sensitive. This will then apply the alarm colors that are defined in the color scheme. Like Labels, Text Update widgets are drawn in a bounding box which you can control on the canvas by dragging the handles, or by finetuning the properties Width and Height. Meter The Meter widget shows the numeric value of the connected PV on a meter. The exact display of this widget can be controlled using various properties, among which colors for the needle, LOLO, LO, HI and HIHI values, major tick separation, as well as various toggles for the different elements that a meter is composed of. Progress Bar A bar graph widget that shows the numeric value of the connected PV as a bar or indicator. Gauge The Gauge widget shows the numeric value of the connected PV on a gauge. The exact display of this widget can be controlled using various properties, among which colors for the needle, LOLO, LO, HI and HIHI values, major tick separation, as well as various toggles for the different elements that a gauge is composed of. Thermometer Specialised form of the Progress Bar widget that shows the numeric value of the connected PV as a thermometer. Tank Specialised form of the Progress Bar widget that shows the numeric value of the connected PV as a tank. XY Graph Advanced widget for plotting the numeric value of one or more connected PVs. By combining the different properties it supports line charts, scatter charts, bar charts, step charts and area charts. To show multiple traces in the same chart, increase the Trace Count. This will add a set of properties for every added trace. Every trace can be linked with a separate PV. Use the Show Toolbar property to toggle visiblity of a toolbar. When visible, this toolbar can be used by the operator to perform zooming operations on the plot. Intensity Graph Advanced widget for diplaying a 2D array as an image. This widget is meant to be used in combination with scripts. Further documentation pending. Byte Monitor Specialised form of the LED widget that shows the numeric long value of the connected PV as a series of LEDs, each LED lighting up if the corresponding bit is true. The rightmost or bottom bit corresponds with the least-significant bit of the PV, but this can be reversed using the Reverse Bits property. "},{"title":"Monitoring and Control Model","url":"/docs/server/Monitoring_and_Control_Model/","body":"Yamcs implements a fairly traditional Monitoring and Control Model. The remote system is represented through a set of parameters which are sampled at regular intervals. Yamcs assumes that parameters are not sent individually but in groups which usually (but not necessarily) are some sort of binary packets. Yamcs supports basic parameter types (int, long, float, double, boolean, timestamp, string, binary) but not yet aggregate types (aka structs in C language) - for example to represent an (x,y,z) position. Yamcs does preserve the association between parameters coming in the same group, which helps alleviating the problem of missing aggregates. Parameters can either be received directly from the remote device or can be computed locally by algorithms. Algorithms in Yamcs can be implemented in Javascript or Python. Other languages that have JVM (Java Virtual Machine) based implementations could also be supported without too much trouble. Following the XTCE standard, Yamcs distinguishes between telemetered parameters (= coming from remote devices), derived parameters (= computed by algorithms inside Yamcs), local parameters (= set by end-user applications) and constant parameters (which are just constant values defined in the mission database). In addition to these XTCE inspired parameter types, Yamcs defines system parameters (parameters generated by components inside Yamcs), command and command history parameters. The last two are specially scoped parameters that can be used in the context of command verifiers. The parameters have limits associated to them and when those limits are exceeded, an alarm is triggered. The limits can change depending on the context which represent the state of the remote device. The context itself is derived from the value of other parameters. An operator is informed of the triggered alarm in various ways depending on the end user application connected to Yamcs (e.g. red background in a display, audible alarm, sms, phone call, etc). After understanding the problem, the operator acknowledges the alarm, which means that it informs Yamcs that the alarm will be taken care of. This action - depending again on the remote end user application connected to Yamcs - means that other operators are not bothered anymore by the alarm. After the alarm has been acknowledged and the parameter goes back into limits, the alarm is cleared which means it is not triggered anymore. Before the alarm is acknowledged by an operator, it will stay triggered even if the parameter goes back into limits. An exception to this case is auto-acknowledging alarms which are cleared automatically when the parameter that triggered them goes back in limits. As the parameters are supposed to be sampled regularely, they also have an expiration time. After the time is exceeded, the parameters become expired - that is to say at that time the state of the remote device is considered unknown. The remote device is controlled through the use of (tele)-commands. A telecommand is made up by a name and a number of command arguments. In order for a command to be allowed to be sent, the command transmission constraints (if any) have to be met. The constraints are expressed by the state of parameters (e.g. a command can be send only if a subsystem is switched on). Some commands can have an elevated significance, which may mean that a special privilege or an extra confirmation is required to send the command. Once the command has been sent, it passes throguh a series of execution stages. XTCE pre-defines a series of stages (TransferredToRange, SentFromRange, Received, Accepted, etc). Yamcs does not enforce the use of these predefined stages, the user is free to choose any number of random stages. Each stage has associated a command verifier - this is an algorithm that will decide if the command has passed or not that stage. It is also possible to specify that the stage has been passed when a specific packet has been received. The command text (command name and argument values), the binary packet (if binary formatted) and the different stages of the execution of the command are recorded in the command history. Yamcs does not limit the information that can be added to the command history. This can be extended with and arbitrary number of (key, timestamp, value) attributes. "},{"title":"OPI Probe","url":"/docs/studio/OPI_Probe/","body":"Right-click on a widget backed by a PV, and select Process Variable &gt; OPI Probe. This opens the OPI Probe view with: In the Value tab, a meter indicating the validity range. This is however not fully implemented yet, and therefore often shows a very large range of values. In the tab Trend, a graphical evolution of this PVs value. There is currently no way to navigate to archived data. "},{"title":"OPI Schema","url":"/docs/studio/OPI_Schema/","body":"The default property values of any widget can be overriden via an OPI Schema. A schema is an OPI file like any other, but which contains a set of widgets whose properties are used as defaults. This is best illustrated with an example. Let’s say we want to modify the defaults of the LED widget. Create a new OPI file and add a LED to the canvas (anywhere). Make the LED bigger and change the colors. Save your changes. Then right-click your file and select Use as OPI Schema. Notice your schema file now shows a small decorator in the Explorer view: Whenever you add a new LED to any display, it will now by red and big by default. The same principle can be applied to any other properties of any of the available widgets. A schema may contain multiple widgets, however if there are multiple widgets of the same type, only the first occurrence is considered. This is the widget that appears the highest in the Outline view . Only one OPI Schema can be active at a time. To unset the active schema, Right-click it in the Explorer view and untick Use as OPI Schema. This will return Display Builder to its default behaviour. "},{"title":"Other Widgets","url":"/docs/studio/Other_Widgets/","body":"Table Advanced widget for structuring tabular data. Does not connect to PVs by itself. Its main use comes when combined with scripts. Web Browser The Web Browser widget allows incorporating a web browser inside a display. This may be useful in managed environments, but in general we would recommend using a standalone web browser. The option is there though. Choose the start page with the URL property. Array Container widget that repeats another widget. First create an Array instance, than drag another widget on top of it and release. The widget will be repeated for the defined Array Length. Modifying the property of any child modifies it for all the other children as well. The Array widget must be connected to a an array PV. Grouping Container You can group widgets together using a Grouping Container. Drag any widget on top of it to make it part of the group. Being widgets themselves, grouping containers can have their own backgrounds and borders. To remove a widget out of a group, select it and drag it out of its container. To remove a group, right-click on it and select Ungroup. To add existing widgets to a new group, select them, and then choose Group from the right-click menu. To prevent nested widgets from being individually selectable, set the Lock Children property of the group to yes. Linking Container Displays can include other displays, or groups of other displays. This is particularly useful to avoid duplication when creating shared components, such as top bars or side bars. Define the included OPI file with the OPI File property, then optionally define the group with the Group Name property. If you don’t specify a group the entire display is embedded. Tweak properties such as the Resize Behaviour to get your desired outcome. Tabbed Container Creates a stack of tabs. Define the number of tabs with the Tab Count property. Sash Container Use the Sash Container to create resizable split panes. Grid Layout This is a special type of widget that is meant to be attached to a container or to the display itself. At runtime it reorganizes the children of that container in a grid. This usually works best with similarly sized widgets. Create a Grid Layout by selecting it from the Palette, and clicking on top of the targeted container. You’ll notice a grid decoration element in the top left of the container. For example, while editing it may look like this: But at runtime, with 3 columns, it renders like this: The order of the container’s children is important for this layout, and can be modified in the Outline view. "},{"title":"Outline","url":"/docs/studio/Outline/","body":"The Outline view, available from the Display Builder window, gives a hierarchical breakdown of the widgets contained in the currently active OPI. Some widgets are containers for other widget types, and will be shown as a node in the tree with a sub-node for every child. Widgets can be named in the Properties view to make them stand out in the Outline. "},{"title":"Overview","url":"/docs/studio/Overview/","body":"Yamcs Studio Yamcs Studio is a TM/TC front-end for Yamcs. It contains an editor for building synoptic operator displays and supports basic telecommanding. License Yamcs Studio follows a similar licensing scheme as Yamcs Server. The core of Yamcs Studio is open-source and licensed under the Eclipse Public License. Mission-specific extensions can be developed on a case-by-case basis and under custom licenses. "},{"title":"PP Loaders","url":"/docs/server/PP_Loaders/","body":"Processed Parameters represent parameters that are processed by systems outside Yamcs. Currently, the only such system supported is DaSS. Yamcs simply has to know the name of parameter and does not do any extra check (like out of limits, validity, etc). In addition, each parameter can be part of a group (which is just a string). The parameters part of the same group are stored together. Excel Spreadsheet This the Yamcs Excel spreadsheets loader, which can define a full MDB based on the XTCE components: Telemetry, Telecommand, Process Parameters and Algorithms. MDB PP Loader The MDB PP loader scans a configured CD-MCS MDB (using direct Oracle connection) for all the end items of type UMI_MAPPING_TABLE. The first part of the Opsname (string before the underscore) is used as group name. Flat-file PP Loader The flat-file PP loader reads list of parameter names, groups and opsnames from a tab-separated file. "},{"title":"PV Info","url":"/docs/studio/PV_Info/","body":"Right-click on a widget backed by a PV, and select PV Info. This opens a window where you get extra information on the PVs in that widget. If there are multiple PVs for that widget, select the PV of your interest using the top dropdown selector. For Yamcs parameters, you will see various properties that were defined in the Mission Database. Currently the displayed information is mostly static. Features which we plan to add include: showing continuously updated information on the latest value, and its alarm info. showing which context is applicable based on the latest value, for context-dependent Mission Database definitions (e.g. alarm rule x only applies in contingency mode). "},{"title":"PV List","url":"/docs/studio/PV_List/","body":"Right-click anywhere in a display, and choose Dump PV List, you will see a window listing the unique PVs that are defined inside any widget of that display. This can be useful for quick-fixing runtime issues. "},{"title":"Packet Telemetry","url":"/docs/server/Packet_Telemetry/","body":"The Yamcs Server implements a subset of the XTCE (XML Telemetric and Command Exchange) for telemetry processing. Only the concepts defined by the standard are supported. For information about XTCE, please refer to http://www.xtce.org. These sections detail only the XTCE types implemented in Yamcs. Sequence Containers Sequence containers are the equivalent of packets in the usual terminology, or ADU in the MDB terminology. A sequence container employs two mechanism to avoid the limitation of traditional “packet with parameters” approach. These mechanisms are aggregation and inheritance. Container aggregation A sequence container contains sequence entries which can be of two types: Parameter Entries - these point to normal parameters. Container Entries - these point to other containers which are then included in the big container. Special attention must be given to the specification of positions of entries in the container. For performance reasons, it is preferable that all positions are absolute (i.e. relative to the beginning of the container) rather than relative to the previous entry. The Excel spreadsheet loader tries to transform the relative positions specified in the spreadsheet into absolute positions. However, due to entries which can be of variable size, the situation cannot always be avoided. When an entry whose position is relative to the previous entry is subscribed, Yamcs adds to the subscription all the previous entries until it finds one whose position is absolute. If an entry’s position depends on another entry (it can be the same in case the entry repeats itself) which is a Container Entry (i.e. makes reference to a container), and the referenced container doesn’t have the size in bits specified, then all the entries of the referenced container plus all the inheriting containers and their entries recursively are added to the subscription. Thus, the processing of this entry will imply the extraction of all parameters from the referenced container and from the inheriting containers. The maximum position reached when extracting entries from the referenced and inheriting containers is considered the end of this entry and used as the beginning of the following one. Container inheritance Sequence containers can point to another sequence container through the baseContainer property, meaning that the baseContainer is extended with additional sequence entries. The inheritance is based on a condition put on the parameters from the baseContainer (e.g. a EDR_HK packet is a CCSDS packet which has the apid=943 and the packetid=0x1300abcd). Little Endian Parameter Encoding Yamcs does not currently support the XTCE way of describing byte ordering for parameter encoding. The only alternative byte order supported is little endian. For parameters occupying entire bytes, there is no doubt on what this means. However, for parameters which occupy only part of bytes the following algorithm is applied to extract the parameter from the packet: Based on the location of the first bit and on the size in bits of the parameter, find the sequence of bytes that contains the parameter. Only parameters that occupy at most 4 bytes are supported. Read the bytes in reverse order in a 4 bytes int variable. Apply the mask and the shift required to bring the parameter to the rightmost bit. For example, assuming that on an x86 CPU we have the following structure in C: struct { unsigned int parameter1:4; unsigned int parameter2:16; unsigned int parameter3:12; } x; x.a=0x1; x.b=0x2345; x.c=0x678; Would result, when converted to network order, in the sequence of hex bytes 51 34 82 67. Thus, the definition of this packet should look like: Parameter Location Size parameter1 4 4 parameter2 4 16 parameter3 16 12 "},{"title":"Packet Updates","url":"/docs/http/Packet_Updates/","body":"The packets resource type within the WebSocket API allows subscribing to telemetry packets (containers) updates. Subscribe to packets received on a given stream: [ 1, 1, :seq, { \"packets\": \"subscribe &lt;stream_name&gt;\" } ] Note: currently the subscription is performed at stream level. It is not possible to subscribe to the telemetry of a processor (but most of the time the telemetry in a processor will be coming from a stream). Once the possibility to subscribe to a processor will be provided, there will be more operations like subscribing only to a specific container. It is only possible to subscribe to one stream at a time. Example Subscribe to tm_realtime stream: [ 1, 1, 789, { \"packets\": \"subscribe tm_realtime\" } ] Response You first get an empty reply message confirming the positive receipt of your request: [ 1, 2, 789 ] Further messages will be marked as type TM_PACKET. The data of the provided packets will be in TmPacketData format: The response is a stream of self-standing VarInt delimited messages of type: yamcs.proto message TmPacketData { required int64 receptionTime = 1; required bytes packet = 2; optional int64 generationTime = 3; optional int32 sequenceNumber = 4; optional NamedObjectId id = 5; } Note: as the messages are received from a stream, the NamedObjectId (which is the identifier of the packet) will not be filled in. The future processor subscriptions may provide the packet identifiers. Unsubscribe Unsubscribe from all currently subscribed packet: [ 1, 1, 790, { \"packets\": \"unsubscribe\" } ] This will be confirmed with an empty reply message: [ 1, 2, 790 ] "},{"title":"Packets","url":"/docs/http/Packets/","body":" "},{"title":"Palette","url":"/docs/studio/Palette/","body":"The Palette is a fold-out zone of the Editor Area that contains the widgets bundled with your version of Yamcs Studio, which may contain less or more widgets than the default widgets documented below. Widgets come in all different kinds, and are grouped in four different categories. Graphics Arc Rectangle Label Polyline Rounded Rectangle Image Polygon Ellipse Monitors LED Progress Bar XY Graph Image Boolean Indicator Gauge Intensity Graph Text Update Thermometer Byte Monitor Meter Tank Controls Action Button Knob Image Boolean Button Menu Button Scrollbar Check Box Text Input Thumb Wheel Radio Box Spinner Boolean Switch Choice Button Scaled Slider Boolean Button Combo Others Table Grouping Container Sash Container Web Browser Linking Container Grid Layout Array Tabbed Container "},{"title":"Parameter Archive","url":"/docs/server/Parameter_Archive/","body":"The parameter archive stores for each parameter tuples of (ti, evi, rvi, psi) where: ti - is the “generation” timestamp of the value. The “reception” timestamp is not stored in the Parameter Archive. evi - is the engineering value of the parameter at the given time. rvi - is the engineering value of the parameter at the given time. psi - is the parameter status of the parameter at the given time. The parameter status includes things like out of limits (alarms), processing status, etc. XTCE provides a mechanism through which a parameter can change its alarm ranges depending on the context. For this reason we store in the parameter status also the applicable alarm ranges at the given time. In order to speed up the retrieval, the parameter archive stores data in segments of approximately 70 minutes. That means that all engineering values for one parameter for the 70 minutes are stored together; same for raw values, parameter status and timestamps. More detail about the parameter archive organization can be found in the Parameter Archive Internals. Having all the data inside one segment of the same type offers possibility for good compression especially if the values don’t change much or at all (as it is often the case). While this structure is good for fast retrieval, it doesn’t allow updating data very efficiently and in any case not in realtime (like the stream archive does). This is why the parameter archive is filled in batch mode - data is accumulated in memory and flushed to disk periodically. The sections below explain the different filling strategies implemented. Archive filling There are two fillers that can be used to populate parameter archive: Realtime filling - the RealtimeFillerTask will subscribe to a realtime processor and write the parameter values to the archive. Backfilling - the ArchiveFillerTask will create from time to time replays from the stream archive and write the generated parameters to the archive. Due to the fact that data is stored in segments, one segment being a value in the (key,value) RocksDB, it is not efficient to write one “row” (data corresponding to one timestamp) at a time. It is much more efficient to collect data and write entire or at least partial segments at a time. The realtime filler will write the partial segments to the archive at each configurable interval. When retrieving data from the parameter archive, the latest (near realtime) data will be missing from the archive. That’s why Yamcs uses the processor parameter cache to retrieve the near-realtime values. The backFiller is by default enabled and it can also be used to issue rebuild requests over HTTP. The realtimeFiller has to be enabled in the configuration and the flushInterval (how often to flush the data in the archive) has to be specified. The flushInterval has to be smaller than the duration configured in the parameter cache. The backFiller is configured with a so called warmupTime (by default 60 seconds) which means that when it performs a replay, it starts the replay earlier by the specified warmupTime amount. The reason is tha if there are any algorithms that depend on some parameters in the past for computing the current value, this should give them the chance to warmup. The data generated during the warmup is not stored in the archive (because it is part of the previous segment). "},{"title":"Parameter Archive","url":"/docs/http/Parameter_Archive/","body":" "},{"title":"Parameter Archive Internals","url":"/docs/server/Parameter_Archive_Internals/","body":"Why not store the values on change only? As explained here, the parameter archive stores for each parameter tuples (ti, evi, rvi, psi). In Yamcs the timestamp is an 8 bytes long, the raw and engineering values are of usual types (signed/unsigend 32/64 integer, 32/64 floating point, string, boolean, binary) and the parameter status is a protobuf message. We can notice that in a typical space data stream there are many parameters that do not change very often (like an device ON/OFF status). For these, the space required to store the timestamp can greatly exceed in size the space required for storing the value (if simple compression is used). In fact since the timestamps are 8 bytes long, they equal or execed in size the parameter values almost in all cases, even for parameters that do change. To reduce the size of the archive, some parameter archives only store the values when they change with respect to the previous value. Often, like in the above “device ON/OFF” example, the exact timestamps of the non-changing parameter values, received in between actual (but rare) value changes are not very important. One has to take care that gaps in the data are not mistaken for non-changing parameter values. Storing the values on change only will reduce the space required not only for the value but also (and more importantly) for the timestamp. However, we know that more often than not parameters are not sampled individually but in packets or frames, and many (if not all) the parameters from one packet share the same timestamp. Usually some of the parameters in these packets will be counters or other things that do change with each sampling of the value. It follows that at least for storing those ever changing parameter values, one has to store the timestamps anyway. This is why, in Yamcs we do not adopt the “store on change only” strategy but a different one: we store the timestamps in one record and make reference to that record from all the parameters sharing those same timestamps. Of course it wouldn’t make any sense to reference one singe timestamp value, instead we store multiple values in a segment and reference the time segment from all value segments that are related to it. Archive structure We have established that the Yamcs parameter archive stores rows of data of shape: (t, pv0, pv1, pv2,…, pvn) Where pv0, pv1, pv2..pvn are parameter values (for different parameters) all sharing the same timestamp t. One advantage of seeing the data this way is that we do keep together parameters extracted from the same packet (and having the same timestamp). It is sometimes useful for operators to know a specific parameter from which packet has been extracted (e.g. which APID, packet ID in a CCSDS packet structure). The parameter archive partitions the data at two levels: time partitioned in partitions of 2^31 milliseconds duration (=~ 25 days). Each partition is stored in its own ColumnDataFamily in RocksDB (which means separate files and the possibility to remove an entire partition at a time). Inside each partition, data is segmented in segments of 2^22 miliseconds (=~ 70 minutes) duration. One data segment contains all the engineering values or raw values or parameter status for one parameter. A time segment contains all the corresponding timestamps. This means that each parameter requires each ~70 minutes three segments for storing the raw, engineering and status plus a segment containing the timestamps. The timestamp segment is shared with other parameters. In order to be able to efficiently compress and work with the data, one segment stores data of one type only. Each (parameter_fqn, eng_type, raw_type) combination is given an unique 4 bytes parameter_id (fqn= fully qualified name). We do this in order to be able to accomodate changes in parameter definitions in subsequent versions of the mission database (Xtce db). The parameter_id=0 is reserved for the timestamp. A ParameterGroup - represents a list of parameter_id which share the same timestamp. Each ParameterGroup is given a ParameterGroup_id Column Families for storing metadata we have 2 CFs: meta_p2pid: contains the mapping between parameter fully qualified name and parameter_id and type meta_pgid2pg: contains the mapping between ParameterGroup_id and parameter_id For storing parameter values and timestamps we have 1CF per partition: data_. partition_id is basetimestamp (i.e. the start timetamp of the 2^31 long partitions) in hexadecimal (without 0x in front) Inside the data partitions we store (key,value) records where: key: parameter_id, ParameterGroup_id, type, segment_start_time (the type=0,1 or 2 for the eng value, raw value or parameter status) value: ValueSegment or TimeSegment (if parameter_id =0) We can notice from this organization, that inside one partition, the segments containing data for one parameter follows in the rockdsdb files in sequence of engvaluesegment_1,rawvaluesegment_1,parameterstatussegment_1, engvaluesegment_2. rawvaluesegment_2… Segment encoding The segments are compressed in different ways depending on their types. SortedTimeSegment - stores the timestamps as uitn32 deltas from the beginning of the segment. The data is first encoded into deltas of deltas, then it’s zigzag encoded (such that it becomes positive) and then it’s encoded with FastPFOR and VarInt. FastPFOR encodes blocks of 128 bytes so VarInt encoding is used for the remaining data. Storing timestamps as deltas of deltas helps if the data is sampled at regular intervals (especially by a real-time sytem). In this case the encoded deltas of deltas become very close to 0 and that compresse very well. Description of the VarInt and zigzag encoding can be found in Protocol Buffer docs. Description and implementation of the FastPFOR algorithm can be found here. IntSegment - stores int32 or uint32 encoded same way as the time segment. FloatSegment - stores 32 bits floating point numbers encoded using the algorithm (very slightly modified to work on 32 bits) described in the Facebook Gorilla paper ParameterStatusSegment, StringSegment and BinarySegment are all stored either raw, as an enumeration, or run-length encoded, depeending on which results in smaller compressed size. DoubleSegment and LongSegment are only stored as raw for the moment - compression is still to be implemented. For DoubleSegment we can employ the same approach like for 32 bits (since the original approach is in fact designed for compressing 64 bits floating point numbers). Future work Segment Compression Compression for DoubleSegment and the LongSegment. DoubleSegment is straightforward, for the LongSegment one has to dig into the FastPFOR algorithm to understand how to change it for 64 bits. Archive filling It would be desirable to backfill only parts of the archive. Indeed, some ground generated data may not suffer necessarily of gaps and could be just realtime filled. Currently there is no possibility to specify what parts of the archive to be back-filled. This may be implemented in a future version. Another useful feature would be to trigger the back filling automatically when gaps are filled in the stream archive. This will hopefully also be implemented in a future version (contributions welcome!). "},{"title":"Parameter Archive Rebuild","url":"/docs/http/Parameter_Archive_Rebuild/","body":"Rebuild (backfill) parts of the parameter archive: POST /api/archive/:instance/parameterArchive/rebuild The back filler has to be enabled for this purpose, the configuration of the back filler is described in the Parameter Archive section. The back filling process does not remove data but just overwrites it. That means that if the parameter replay returns less parameters than originally stored in the archive, the old parameters will still be found in the archive. It also means that if a replay returns the parameter of a different type than originally stored, the old ones will still be stored. This is because the parameter archive treats parameter with the same name but different type as different parameters. Each of them is given an id and the id is stored in the archive. If you want to remove data from the archive, use the Delete Partitions call. Currently this can be done only for entire partitions. A partition is approximatively 25 days (231 milliseconds). Parameters Name Type Description start string Start rebuilding from here. Specify a date string in ISO 8601 format. stop string Rebuild until here. Specify a date string in ISO 8601 format. Note that the archive is build in segments of approximatively 70 minutes, therefore the real start will be before the specified start and the real stop will be after the specified stop. Response Status: 200 OK "},{"title":"Parameter Archive Service","url":"/docs/server/Parameter_Archive_Service/","body":"The Parameter Archive stores time ordered parameter values. The parameter archive is column-oriented and is optimized for accessing a (relatively small) number of parameters over longer periods of time. Class Name org.yamcs.parameterarchive.ParameterArchive Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.parameterarchive.ParameterArchive args: realtimeFiller: enabled: true flushInterval: 300 #seconds backFiller: #warmupTime: 60 seconds default warmupTime enabled: true schedule: [{startSegment: 10, numSegments: 3}] This configuration enables the realtime filler flushing the data to the archive each 5 minutes, and in addition the backFiller fills the archive 10 segments (approx 700 minutes) in the past, 3 segments at a time. yamcs.simulator.yaml services: - class: org.yamcs.parameterarchive.ParameterArchive args: realtimeFiller: enabled: false backFiller: enabled: true warmupTime: 120 schedule: - {startSegment: 10, numSegments: 3} - {startSegment: 2, numSegments: 2, interval: 600} This configuration does not use the realtime filler, but instead performs regular (each 600 seconds) back-fillings of the last two segments. It is the configuration used in the ISS ground segment where due to regular(each 20-30min) LOS (loss of signal), the archive is very fragmented and the only way to obtain continuous data is to perform replays. "},{"title":"Parameter Recorder","url":"/docs/server/Parameter_Recorder/","body":"Records parameters. This service stores the data coming from one or more streams into a table pp. The term pp stands for processed parameter. These are parameters that typically are processed by an external system before being recorded in Yamcs. It is also used to store system parameters that are generated by Yamcs itself. Parameters extracted from packets are usually not stored in pp. Instead Yamcs provides a different service called the Parameter Archive which is specially optimized for data retrieval. Class Name org.yamcs.archive.ParameterRecorder Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.ParameterRecorder streamConfig: param: - pp_realtime - sys_param With this configuration both system parameters and processed parameters coming from the pp_realtime stream are stored into the table pp. Configuration Options Name Type Description streams list of strings The streams to record. When unspecified, all param streams defined in streamConfig are recorded. "},{"title":"Parameter Updates","url":"/docs/http/Parameter_Updates/","body":"Subscribe to parameter updates: [ 1, 1, :seq, { \"parameter\": \"subscribe\", \"data\": { \"id\": [ { \"namespace\": \":namespace\", \"name\": \":name\" } ], \"updateOnExpiration\": false, \"abortOnInvalid\": false, \"sendFromCache\": true, \"subscriptionId\": -1 } } ] Options that can be used for parameter subscription: updateOnExpiration if set to true (the default is false), will cause parameter updates to be sent when parameters expire. The update sent when the parameter expires will have the same value and timestamp like the previous sent one, but the acquisition status will be set to EXPIRED (instead of ACQUIRED). abortOnInvalid if set to false (default), then no error will be raised if some of the specified parameters are invalid. Instead the valid ones will be subscribed and the response will return the list of invalid parameters. If set to true and some parameters are invalid, an exception will be returned and no subscription will be made. sendFromCache if set to true (default), the existing values of the parameters from the cache (if any) will be sent immediately. Otherwise the values will only be sent when the parameters update. subscriptionId is used to have multiple independent subscriptions. Each subscription is given a numeric id which can be used to add or remove parameters to/from the subscription. How to use multiple subscriptions: each request will return the subcriptionId where the parameter have been added. Note that if abortOnInvalid is false and all the parameters are invalid, the request will return subscriptionId=-1 and no subscription will be made. Each parameter message (containing parameter data) will also contain the subscriptionId. the subscriptionId can be specified in the request to add parameters to an existing subcription. if subscriptionId=-1 is specified in the request, then a new subscription will be created and its subscriptionId will be returned. for compatibility with the old API, if the subscriptionId is not specified in the subscribe/unsubscribe request, then the parameters will be added or removed to/from the first subscription created. Example Subscribe to BatteryVoltage1 through a qualified name, and BatteryVoltage2 using an OPS name: [ 1, 1, 789, { \"parameter\": \"subscribe\", \"data\": { \"id\": [ { \"name\": \"/YSS/SIMULATOR/BatteryVoltage1\" }, { \"namespace\": \"MDB:OPS Name\", \"name\": \"SIMULATOR_BatteryVoltage2\" } ] } } ] Response You first get an reply message confirming the positive receipt of your request and the generated subscriptionId: [1, 2, 3, {\"type\":\"ParameterSubscriptionResponse\", \"data\":{ \"subscriptionId\": 6 }}] Further messages will be marked as type PARAMETER_DATA. Directly after you subscribe, you will receive the latest cached values if the option sendFromCache has been set. Note that all parameters are returned with the same identification they have been subscribed to. [1, 4, 2, { \"dt\": \"PARAMETER\", \"data\": { \"parameter\": [{ \"id\": { \"name\": \"/YSS/SIMULATOR/BatteryVoltage1\" }, \"rawValue\": { \"type\": \"UINT32\", \"uint32Value\": 10 }, \"engValue\": { \"type\": \"UINT32\", \"uint32Value\": 10 }, \"acquisitionTime\": 1514993937058, \"generationTime\": 1514993932468, \"acquisitionStatus\": \"ACQUIRED\", \"processingStatus\": true, \"monitoringResult\": \"IN_LIMITS\", \"acquisitionTimeUTC\": \"2018-01-03T15:38:20.058Z\", \"generationTimeUTC\": \"2018-01-03T15:38:15.468Z\", \"expirationTime\": 1514993950358, \"expirationTimeUTC\": \"2018-01-03T15:38:33.358Z\", \"alarmRange\": [{ \"level\": \"CRITICAL\", \"minInclusive\": 9.0, \"maxInclusive\": 15.0 }], \"expireMillis\": 13300 }, { \"id\": { \"name\": \"SIMULATOR_BatteryVoltage2\", \"namespace\": \"MDB:OPS Name\" }, \"rawValue\": { \"type\": \"UINT32\", \"uint32Value\": 192 }, \"engValue\": { \"type\": \"UINT32\", \"uint32Value\": 192 }, \"acquisitionTime\": 1514993937058, \"generationTime\": 1514993932468, \"acquisitionStatus\": \"ACQUIRED\", \"processingStatus\": true, \"monitoringResult\": \"CRITICAL\", \"rangeCondition\": \"HIGH\", \"acquisitionTimeUTC\": \"2018-01-03T15:38:20.058Z\", \"generationTimeUTC\": \"2018-01-03T15:38:15.468Z\", \"expirationTime\": 1514993950358, \"expirationTimeUTC\": \"2018-01-03T15:38:33.358Z\", \"alarmRange\": [{ \"level\": \"CRITICAL\", \"minInclusive\": 2.0, \"maxInclusive\": 15.0 }], \"expireMillis\": 13300 }], \"subscriptionId\": 6 } }] Unsubscribe Unsubscribe from selected parameter updates: [ 1, 1, 790, { \"parameter\": \"unsubscribe\" \"data\": { \"id\": [ { \"name\": \"/YSS/SIMULATOR/BatteryVoltage1\" }, { \"namespace\": \"MDB:OPS Name\", \"name\": \"SIMULATOR_BatteryVoltage2\" } ], \"subscriptionId\": 6 }} ] This will be confirmed with an empty reply message: [ 1, 2, 790 ] Note that if subcriptionId is not specified , the parameters will be removed from the first subscription created. Unsubscribe all Unsubscribe from all parameter updates for a given subscription: [ 1, 1, 790, { \"parameter\": \"unsubscribeAll\" \"subscriptionId\": 6 } ] This will be confirmed with an empty reply message: [ 1, 2, 790 ] After this call has been invoked, it is not possible anymore to reuse the subscriptionId; Instead a new one can be created by using subscriptionId = -1 in the request. "},{"title":"Parameter Values","url":"/docs/http/Parameter_Values/","body":" "},{"title":"Preference Defaults","url":"/docs/studio/Preference_Defaults/","body":"Most user preferences are linked to the workspace and saved to a folder .metadata. Whenever a user creates a new workspace, the workspace starts with the default preferences. These default preferences can be modified by adding or modifiying the Yamcs Studio.ini file in the installation directory of Yamcs Studio. This is often done to ensure that different workstations use similar site-specific configuration. Some of the more common preferences are documented below. org.csstudio.opibuilder/colors.list List of named colors. Entries are separated by semicolons. Each entry is composed as NAME@R,G,B. For example: Major@255,0,0;Minor@255,128,0. You can choose any name, but note that the names Major, Minor, Invalid and Disconnected have a special meaning in Yamcs Studio. They are used for common decorations such as out-of-limit indicators. org.csstudio.opibuilder/fonts.list List of named fonts. Entries are separated by semicolons. Each entry is composed as NAME@FONT-STYLE-SIZE. For example: Header 1@Arial-bold-19;Header 2@Arial-bold-15. The font should be availabe on the system. Only 'Liberation Sans' (which is the default) is dynamically loaded when it is missing from the system, this is to ensure that the default font settings produce identical displays on all platforms. Note that font size is expressed in points, not pixels. org.csstudio.opibuilder/hidden_widgets Hide the specified widgets from the palette. Widgets are mentioned by their id. and separated by the vertical bar character. org.csstudio.opibuilder/schema_opi Workspace reference to the active Schema OPI. For example: /My Project/schema.opi org.yamcs.studio.core.ui/singleConnectionMode org.yamcs.studio.core.ui/connectionString When singleConnectionMode is set to true, Yamcs Studio will not open the Connection Manager window, but will only allow connections to a single Yamcs server defined in the connectionString "},{"title":"Process Runner","url":"/docs/server/Process_Runner/","body":"Runs an external process. If this process goes down, a new process instance is started. Class Name org.yamcs.server.ProcessRunner Configuration This is a global service defined in etc/yamcs.yaml. Example from a typical deployment: yamcs.yaml services: - class: org.yamcs.server.ProcessRunner args: command: \"bin/simulator.sh\" Configuration Options Name Type Description command string or string[] Required. Command (and optional arguments) to run. directory string Set the working directory of the started subprocess. If unspecified, this defaults to the cwd of Yamcs. logLevel string Level at which to log stdout/stderr output. One of INFO, DEBUG, TRACE, WARN, ERROR. Default: INFO logPrefix string Prefix to prepend to all logged process output. If unspecified this defaults to '[COMMAND] '. "},{"title":"Processed Variables","url":"/docs/studio/Processed_Variables/","body":"Processed Variable or ‘PV’ is a term used by Yamcs Studio that covers the different types of data sources that a widget can be connected to. It is a more general term than parameter, which is a Yamcs Server notion. PVs are uniquely identified by a PV Name. If multiple widgets have dependencies on the same PV, only one instance will be created and shared between these widgets. The term PV is used to indicate both the name of a specific data source definition, as well as any instances of that definition. Context usually makes it apparent which of the two is meant. A PV is considered connected if the data source is available, and at least one widget within Yamcs Studio is subscribing to it. As soon as no more widgets are connected to a PV, the PV gets disconnected. A side effect of this last property, is that widgets with memory, such as chart widgets, lose their history when closing and reopening the display. We are aware of this, and are taking care of this shortcoming. There are different types of PVs: Local PVs Parameters Software Parameters Simulated Values Formulas Local PVs Local PVs are read and written entirely in a running Yamcs Studio instance. They are never communicated to Yamcs, nor to any other copies of Yamcs Studio. Local PVs are typically used by the display author as a means to store information that needs to be communicated from one widget to another. They also form a powerful building block when scripting advanced displays due to their ability to store runtime state. This makes it possible to script logic based on a historical window of values. Local PVs are transient, and are reset when Yamcs Studio is restarted. Local PVs do not need to be specially created. They are automatically instantiated when needed. Example PV Names: loc://foo loc://my-favourite-local-pv loc://anything-you-want-really You can assign an initial value to a local PV by adding it after its name. For instance: loc://foo(1) loc://bar(“abc”) Parameters Parameter PVs represent a read-only value that is provided by Yamcs. Typically this denotes telemetry. The PV Name for parameters is the fully qualified XTCE name as specified in the Yamcs Mission Database. Example PV Names: para:///YSS/SIMULATOR/BatteryVoltage1 para:///YSS/SIMULATOR/BatteryTemperature1 Or simply: /YSS/SIMULATOR/BatteryVoltage1 /YSS/SIMULATOR/BatteryTemperature1 In these examples YSS is the name of the root space system. SIMULATOR is the name of the space system directly below, which defines both measurements BatteryVoltage1 and BatteryTemperature1. Software Parameters Same concept as a Parameter, but has additional support for writing values from the client to the server. In this regard they can be used as a means of communicating information from one client to another using Yamcs Server as the medium. Remark that software parameters are not currently archived by Yamcs Server, and will therefore be reset when Yamcs is restarted. Example PV Name: sw:///YSS/SIMULATOR/some-software-param Simulated Values Locally generated simulation data. Mainly useful during testing, or in combination with other PVs using formulas. Full documentation is upcoming. For now please have a look at the example operator displays in the YSS projects. Example PV Names: sim://ramp(0,1,1,0.5) sim://const(4) sim://noise sim://sine Formulas PVs can be combined with mathematical expressions. Formulas always start with = followed by a formula expression. Note that any referenced PVs must be wrapped with single quotes. Example PV Names: =3*‘loc://foo(2)’ =3.14 =log(‘loc://foo(2)’) Supported formulas include: abs(a) acos(a) asin(a) atan(a) ceil(a) cos(a) cosh(a) exp(a) expm1(a) floor(a) log(a) log10(a) round(a) sin(a) sinh(a) sqrt(a) tan(a) tanh(a) toDegrees(a) toRadians(a) atan2(a, b) hypot(a, b) pow(a, b) min(a, b, c, d, e) max(a, b, c, d, e) "},{"title":"Processor Configuration","url":"/docs/server/Processor_Configuration/","body":"Processors can be of different types which are configured in processor.yaml. Usually there is a type called “realtime” which configures the processor with the same name. processor.yaml realtime: telemetryProvider: class: org.yamcs.tctm.YarchTmPacketProvider args: stream: \"tm_realtime\" commandReleaser: class: org.yamcs.tctm.YarchTcCommandReleaser args: stream: \"tc_realtime\" parameterProviders: # - class: org.yamcs.tctm.YarchPpProvider # args: # stream: \"pp_realtime\" # implements XTCE algorithms - class: org.yamcs.algorithms.AlgorithmManager # implements provider of parameters from sys_var stream (these are collected and sent on this stream by SystemParametersCollector service) - class: org.yamcs.parameter.SystemParametersProvider config: #check alarms and also enable the alarm server (that keeps track of unacknoledged alarms) alarm: check: true server: enabled parameterCache: enabled: true cacheAll: true Parameter Cache The parameterCache options can be used to enable or disable the cache. For a realtime channel the cache is a good idea. For a retrieval channel, the cache is usually disabled for attaining better performance (because only some parameters have to be extracted from packets). If the cacheAll option is set to false, the Parameter Cache will only contain the values for the subscribed parameters. If a parameter is not subscribed, trying to retrieve a value from cache will return nothing. When cacheAll is set to true, Yamcs will decode and cache all parameters. "},{"title":"Processor Creator Service","url":"/docs/server/Processor_Creator_Service/","body":"Creates persistent processors owned by the system user. Class Name org.yamcs.ProcessorCreatorService Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.ProcessorCreatorService args: name: realtime type: realtime Configuration Options Name Type Description name string Required. The name of the processor type string Required. The type of the processor config string Configuration string to pass to the processor "},{"title":"Processor Services","url":"/docs/server/Processor_Services/","body":" "},{"title":"Processors","url":"/docs/http/Processors/","body":" "},{"title":"Programs","url":"/docs/server/Programs/","body":" "},{"title":"Properties","url":"/docs/studio/Properties/","body":"The Properties view is used in the Display Builder window to edit properties of your display, or to edit properties of a widget.s Select a widget to see its properties in the Properties view. The contents of this view adapts to your selection. Click in the Value column to edit a specific property, depending on the type of property this will trigger different behaviour. For example, if the property is just a numeric value, you can edit it in-place (confirm with Enter). If the property represents multiline text or a list of items you will typically have more advanced editing controls in a popup dialog. Changes are not saved automatically. Remember to select File &gt; Save All before you refresh a runtime OPI. Depending on the types of involved widgets, it may be possible to batch-edit some properties by selecting multiple different widgets. Widget Properties Different widgets have different properties, but many of those properties are shared among them. These include: Name A name that identifies this widget in the Outline view. There is no constraint on uniqueness, but when not specified by the user, Yamcs Studio will try to determine a unique name by concatenating the widget type with a sequential number. XYWidthHeight Widgets are contained in a bounding box which is controlled by these properties. X and Y indicate the pixel position of the widget within the display. The origin is located at the top left of the Editor Area. The X and Y position of the widget also indicates the top left of its bounding box. Width and Height indicate the size of the bounding box. Many widgets support automatic scaling within the available bounding box. PV Name The unique name of a PV that will be backing this widget. At runtime the value of this PV will be used to control the intrinsic value of the widget, or to decorate it in case of off-nominal state. If the PV concerns a Yamcs parameter, and Yamcs Studio is connected to Yamcs, you will get autocompletion support on parameter names based on the contents of the Mission Database. Alarm Sensitive Toggles whether or not the bounding box of this widget will be decorated during runtime based on off-nominal values of its connected PV. Border ColorBorder StyleBorder Width Allows drawing the contours of the widget's bounding box using a wide variety of different styles. OPI Properties The OPI itself is also a special kind of container widget with editable properties. Click on an empty region of your Editor Area to see these. Specific properties include: Show RulerShow GridGrid ColorGrid Space Configure the ruler or the grid. Notice that these properties are tied to a specific OPI. The visibility can also be toggled using the toolbar. If the grid is toggled on, the grid lines will work as magnets when positioning widgets. Snap to Geometry When enabled, Yamcs Studio snaps your widgets magnetically in place based on the position of neighbouring widgets. Auto Zoom to Fit All Controls whether the display as a whole should be zoomed in at runtime such that it fits its available space "},{"title":"Replay Server","url":"/docs/server/Replay_Server/","body":"This service handles replay requests of archived data. Each replay runs with a separate processor that runs in parallel to the realtime processing. Class Name org.yamcs.archive.ReplayServer Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.ReplayServer "},{"title":"Replay Service","url":"/docs/server/Replay_Service/","body":"Provides telemetry packets and processed parameters from the archive. Class Name org.yamcs.tctm.ReplayService Configuration This service is defined in etc/processor.yaml. Example: processor.yaml Archive: services: - class: org.yamcs.tctm.ReplayService Configuration Options Name Type Description excludeParameterGroups list of strings Parameter groups to exclude from being replayed. "},{"title":"RocksDB","url":"/docs/http/RocksDB/","body":" "},{"title":"RocksDB List","url":"/docs/http/RocksDB_List/","body":"List all RocksDB databases: GET /api/archive/:instance/rocksdb/list Example GET /api/archive/yops/rocksdb/list Response The response is a list of directory names where the RocksDB databases are stored: /storage/yamcs-data/yops/events-histo /storage/yamcs-data/yops/ParameterArchive /storage/yamcs-data/yops/pp-histo /storage/yamcs-data/yops/cmdhist-histo /storage/yamcs-data/yops/2016/pp /storage/yamcs-data/yops/tm-histo "},{"title":"RocksDB Properties","url":"/docs/http/RocksDB_Properties/","body":"Get the properties of an open RocksDB database: GET /api/archive/:instance/rocksdb/properties/:dbpath* dbpath is the absolute path of the database on disk. This operation can be used to debug the inner workings of RocksDB database. For example the property rocksdb.estimate-table-readers-mem will provide an estimation of how much memory is used by the index and filter cache of RocksDB (note that the memory used by RocksDB is outside the java heap space). A description of various RocksDB properties can be found here. Example GET /api/archive/:instance/rocksdb/properties//storage/yamcs-data/yops/ParameterArchive Response ============== Column Family: data_14380000000======== rocksdb.num-immutable-mem-table: 0 rocksdb.num-immutable-mem-table-flushed: 0 rocksdb.mem-table-flush-pending: 0 rocksdb.num-running-flushes: 0 rocksdb.compaction-pending: 0 rocksdb.num-running-compactions: 0 rocksdb.background-errors: 0 rocksdb.cur-size-active-mem-table: 192 rocksdb.cur-size-all-mem-tables: 192 rocksdb.size-all-mem-tables: 192 rocksdb.num-entries-active-mem-table: 0 rocksdb.num-entries-imm-mem-tables: 0 rocksdb.num-deletes-active-mem-table: 0 rocksdb.num-deletes-imm-mem-tables: 0 rocksdb.estimate-num-keys: 1408482 rocksdb.estimate-table-readers-mem: 591656 rocksdb.is-file-deletions-enabled: 0 rocksdb.num-snapshots: 0 rocksdb.oldest-snapshot-time: 0 rocksdb.num-live-versions: 1 rocksdb.current-super-version-number: 1 rocksdb.estimate-live-data-size: 254043195 rocksdb.base-level: 1 ---------- rocksdb.stats---------------- ** Compaction Stats [data_14380000000] ** Level Files Size(MB) Score Read(GB) Rn(GB) Rnp1(GB) Write(GB) Wnew(GB) Moved(GB) W-Amp Rd(MB/s) Wr(MB/s) Comp(sec) Comp(cnt) Avg(sec) KeyIn KeyDrop --------------------------------------------------------------------------------------------------------------------------------------------------------------------- L0 3/0 2.74 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0.000 0 0 L1 4/0 242.27 0.9 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0.000 0 0 Sum 7/0 245.02 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0.000 0 0 Int 0/0 0.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0.000 0 0 .... Note, that the response in text format is quite large, it contains a dump of various rocksdb properties for each column family. The single value properties are presented in a name: value list. The multiline properties are preceded by a line including the property name between dashes (like the rocksdb.stats in the example above). "},{"title":"Rules & Scripts","url":"/docs/studio/Rules_&_Scripts/","body":"Making OPI displays is flexible using the Palette and the Properties, but the resulting displays are still fairly static. But what if we want to make the position of a widget dynamic based on a PV? Or if we want to dynamically change widget colors? Rules You may have noticed that every widget has a Rules property. Rules are a user-friendly way for adding dynamic behaviour to widgets. They are most often used for changing the widget’s properties at runtime. Example This is best explained with an example. Suppose we have the bright idea to make an LED square when it is off, and round when it is on. The static properties would not allow for such a scenario, we therefore add a rule. Edit the Rules property to pop up this dialog. Clicking the plus icon gives you this dialog: The first thing to choose is the rule’s target Property. So select Square LED. In the right Input PVs table add your input PV. In this example we chose to generate an alternating 0/1 value using a simulated PV. Notice the sequential number in the # column. The first PV is numbered 0. Make sure to check the Trigger checkbox as this will then trigger the execution of the rule whenever the PV’s value is updated. Now in the Expressions table, fill in your conditions in the Boolean Expression column, and add the desired value of the rule’s property in the Output Value column. The double value of the top-most right PV is available as the variable pv0. The next PV in the list (if applicable) is available as the variable pv1, etc. Confirm your dialogs, save your display and refresh a runtime view of it. You should see the LED’s shape now alternating between square and ground. One can see that this example could be made arbitrarily complex by adding more rules and/or expressions. Boolean Expression This input field needs to be expressed in JavaScript. The Input PVs are available in different formats: Type Example Double Value pv0 == 2.2 String Value pvStr0 != 'abc' Integer Value pvInt0 &gt;= 2 In addition, you can access the numeric alarm state of an input PV. Alarm Example Invalid pvSev0 == -1 No Alarm pvSev0 == 0 Minor Alarm pvSev0 == 1 Major Alarm pvSev0 == 2 If you wish to set a property value that always applies, use true (or 1==1) as the Boolean Expression. Output Value The exact form that the Output Value column adopts depends on the type of the property. Some properties are colors, so you would see a color picker, other properties expect text, and the above example was a boolean yes/no, so we got a checkbox. Scripts For more advanced dynamic runtime behaviour, we can write scripts (actually Rules are a thin layer on top of scripts). With scripts we can write arbitrary logic that can dynamically manipulate just about any combination of properties for a widget. Yamcs Studio supports two dynamic languages: JavaScript and Python. Both languages can be used to the same effect, and are available without any external dependencies. As of now, there is no advanced editor support bundled with Yamcs Studio though, so scripts are edited with a plain text editor. "},{"title":"SCOS2K Loader","url":"/docs/server/SCOS2K_Loader/","body":"The SCOS2K loader loads MIB definitions as defined by SCOS-2000. To use it, you need to compile the project yamcs-scos2k and copy the jar into the yamcs lib/ext directory. Then you can add the following in the mdb.yaml: scos-mib: - type: \"org.yamcs.scos2k.MibLoader\" args: path: \"/path/to/ASCII/\" # byte offset from beginning of the packet where the type and subType are read from typeOffset: 7 subTypeOffset: 8 epoch: \"UNIX\" Known problems and limitations The SCOS-2K loader has been implemented as a proof of concept and only subjected to limited testing by loading a TERMA TSC test database and comparing the TM/TC decoding/encoding with the TSC. A number of known limitations are documented below. To be fixed as soon as someone shows some interest in this project (please submit an issue if you want this fixed): the loader does not detect when the files have changed and does not reload the database. This is because it looks at the date of the ASCII directory. As a workaround you can either remove the serialized MDB from ~/.yamcs or /opt/yamcs/cache or run “touch ASCII” to change the date of the directory. command verifiers are currently not loaded Probably not immediate priority: delta monitoring checks (OCP_TYPE=D) not supported event generation (OCP_TYPE=E) not supported status consistency checks (OCP_TYPE=C, PCF_USCON=Y) not supported arguments of type “Command Id” (CPC_CATEG=A) are not supported. These can be used to insert one command inside another one. Instead a binary command argument is being used. SCOS 2K allows multiple command arguments with the same name. This is not supported in Yamcs (and in XTCE) so duplicate arguments are renamed arg_ with n increasing for each argument. no command stack support. "},{"title":"SPNEGO AuthModule","url":"/docs/server/SPNEGO_AuthModule/","body":"The SPNEGO AuthModule supports authentication of users via an external Kerberos server. It does not support authorization and must therefore be stacked together with another AuthModule. Class Name org.yamcs.security.SpnegoAuthModule Configuration Options Name Type Description krbRealm string Accept only users from this realm stripRealm boolean Whether to strip the realm from the username (e.g. 'user@REALM' becomes just 'user'). Use this only when krbRealm is also set. Default: false krb5.conf string Absolute path to the applicable krb5.conf file. jaas.conf string Absolute path to the applicable jaas.conf file. The jaas.conf file must contain login modules called UserAuth and Yamcs. Details are beyond the scope of this manual. "},{"title":"Security","url":"/docs/server/Security/","body":"Yamcs includes a security subsystem which allows authenticating and authorizing users. Authentication is the act of identifying the user, whereas authorization involves determining what privileges this user has. Once authorized, the user may be assigned one or more privileges that determine what actions the user can perform. Yamcs distinguishes between system privileges and object privileges. System Privileges A system privilege is the right to perform a particular action or to perform an action on any object of a particular type. ControlProcessor Allows to control any processor ModifyCommandHistory Allows to modify command history ControlCommandQueue Allows to manage command queues Command Allows to issue any command GetMissionDatabase Allows to read the entire MDB ControlArchiving Allows to manage archiving properties of Yamcs ControlLinks Allows to control the lifecycle of any data link ControlServices Allows to manage the lifecycle of services ManageAnyBucket Provides full control over any bucket (including user buckets) ReadEvents Allows to read any event WriteEvents Allows to manually post events WriteTables Allows to manually add records to tables ReadTables Allows to read tables Yamcs extensions may support additional system privileges. Object Privileges An object privilege is the right to perform a particular action on an object. The object is assumed to be identifiable by a single string. The object may also be expressed as a regular expression, in which case Yamcs will perform pattern matching when doing authorization checks. Command Allows to issue a particular command CommandHistory Allows access to the command history of a particular command InsertCommandQueue Allows to insert commands to a particular queue ManageBucket Allow control over a specific bucket ReadPacket Allows to read a particular packet ReadParameter Allows to read a particular parameter Stream Allow to read and emit to a specific stream WriteParameter Allows to set the value of a particular parameter Yamcs extensions may support additional object privileges. Superuser A user may have the attribute superuser. Such a user is not subject to privilege checking. Any check of any kind will automatically pass. An example of such a user is the System user which is used internally by Yamcs on some actions that cannot be tied to a specific user. The superuser attribute may also be assigned to end users if the AuthModule supports it. AuthModules The security subsystem is modular by design and allows combining different AuthModules together. This allows for scenarios where for example you want to authenticate via LDAP, but determine privileges via YAML files. The default set of AuthModules include: YAML AuthModule Reads Yaml files to verify the credentials of the user, or assign privileges. LDAP AuthModule Attempts to bind to LDAP with the provided credentials. Also capable of reading privileges for the user. SPNEGO AuthModule Supports authenticating against a Kerberos server. This module includes extra support for Single-Sign-On via Yamcs web interface. AuthModules have an order. When a login attempt is made, AuthModules are iterated a first time in this order. Each AuthModule is asked if it can authenticate with the provided credentials. The first matching AuthModule contributes the user principal. A second iteration is done to then contribute privileges to the identified user. During both iterations, AuthModules reserve the right to halt the global login process for any reason. A special note on roles. Yamcs itself does not require roles nor does it keep track of roles on the User object. Permissions are always verified via user privileges. Specific AuthModules may however introduce roles as a convenience to group sets of privileges together. Configuration Example from a typical deployment: security.yaml enabled: true # Implicit user when security is _not_ enabled unauthenticatedUser: username: admin superuser: true authModules: - class: org.yamcs.security.YamlAuthModule config: hasher: org.yamcs.security.PBKDF2PasswordHasher These options are supported: enabled Whether security is enabled. If false then Yamcs will not require users to login and will assume that everybody shares a single account defined under the unauthenticatedUser property. unauthenticatedUser Configures the user details of the default user. This property is only considered when enabled is set to false authModules List of AuthModules that particpate in the login process. Each AuthModule may support custom configuration options which can be defined under the config key. "},{"title":"Services","url":"/docs/http/Services/","body":" "},{"title":"Set Parameter Value","url":"/docs/http/Set_Parameter_Value/","body":"Parameters are usually read-only. But software parameters can be updated: PUT /api/processors/:instance/:processor/parameters/:namespace/:name Example { \"type\" : \"UINT32\", \"uint32Value\" : 123 } Multi-set To update multiple parameters at once, send a request to this address: POST /api/processors/:instance/:processor/parameters/mset { \"request\" : [ { \"id\": { \"name\": \"/YSS/SIMULATOR/AllowCriticalTC1\" }, \"value\": { \"type\" : \"BOOLEAN\", \"booleanValue\" : true } } ] } Alternative Media Types Protobuf Use these HTTP headers: Content-Type: application/protobuf Accept: application/protobuf Request is of type: yamcs.proto message Value { enum Type { FLOAT = 0; DOUBLE = 1; UINT32 = 2; SINT32 = 3; BINARY = 4; STRING = 5; TIMESTAMP = 6; UINT64 = 7; SINT64 = 8; BOOLEAN = 9; } required Type type = 1; optional float floatValue = 2; optional double doubleValue = 3; optional sint32 sint32Value = 4; optional uint32 uint32Value = 5; optional bytes binaryValue = 6; optional string stringValue = 7; optional int64 timestampValue = 8; optional uint64 uint64Value = 9; optional sint64 sint64Value = 10; optional bool booleanValue = 11; } Bulk request is of type: rest/rest.proto message BulkSetParameterValueRequest { message SetParameterValueRequest { optional yamcs.NamedObjectId id = 1; optional yamcs.Value value = 2; } repeated SetParameterValueRequest request = 1; } "},{"title":"Simulated Parameter Data Link","url":"/docs/server/Simulated_Parameter_Data_Link/","body":"Some tests require parameter data to be simulated without using a packet source. This can be achieved by using the SimulationPpProvider. The SimulationPpProvider takes as input scenarios that are defined in XML files. The XML scenario file allows to describe the parameters sent, their generation time, reception time, engineering value and monitoring value. Parameters are organized in a sequence that can be repeated to allow more complex scenarios. The speed of the simulation can be defined by setting the duration of a simulation step. Class Name org.yamcs.simulation.SimulationPpProvider Configuration Options Name Type Description stream string Required. The stream where data is emitted simulationDataPath string Required. Path to the XML file containing further configuration "},{"title":"Spreadsheet Loader","url":"/docs/server/Spreadsheet_Loader/","body":"The spreadsheet loader loads mission database definitions from excel spreadsheet. Only excel prior to Excel 2007 are supported (.xls files not .xlsx). Multiple Space Systems support Conventions Rules for parameter/conainer reference lookup General Sheet Containers Sheet Parameters Sheet Encoding and Raw Types Engineering Types Calibration Sheet Java Expressions Algorithms Sheet JavaScript algorithms Python algorithms Java algorithms Command verifier algorithms Data Decoding algorithms Example Definition Example Definition for a command verifier algorithm Alarms Sheet Example Definition Commands Sheet Encoding and Raw Types for command arguments Command Options Sheet Command Verification Sheet Change Log Sheet Multiple Space Systems support Since version 5.4, the spreadsheet definition supports loading from one Excel file a hierarchy composed of multiple space systems. Until version 5.3 this was only possible by defining multiple Excel files (one per subsystem) and defining the hierarchy in etc/mdb.yaml. Also until version 5.3 the loader forced some sheets to always be present (e.g. Containers). From version 5.4 only the General sheet has to be present, all the other ones are optional. To define the space system hierarchy, the convention is that all the sheets that do not have a prefix contain data for the main space system whose name is defined in the General sheet. To define data in subsystems, a syntax like SYSTEM1|SYSTEM2|Containers can be used. This definition will create a SYSTEM1 as part of the main space system and a child SYSTEM2 of SYSTEM1. Then the containers will be loaded in SYSTEM2. The spreadsheet loader scans and creates the subsystem hierarchy and then it loads the data inside the systems traversing the hierarchy in a depht-first order. Conventions All numeric values can be entered as decimals or as hexadecimals (with prefix 0x) Although column names are used for reference below, columns must not be reordered A number of mandatory named sheets are described as part of this specification, though authors may add their own sheets and still use the spreadsheet file as the reference MDB. Rules for parameter/conainer reference lookup Each time a name reference is mentioned in the spreadsheet, the following rules apply: The reference can use UNIX like directory access expressions (../a/b). If the name is not found as a qualified parameter, and the option enableAliasReferences is configured for the SpreadsheetLoader, the parameter is looked up through all the aliases of the parent systems. The exact result of the lookup depends of course on the exact tree configuration in mdb.yaml” General Sheet This sheet must be named “General”, and the columns described must not be reordered. format version Used by the loader to ensure a compatible spreadsheet structure name Name of the MDB document version Used by the author to track versions in an arbitrary manner Containers Sheet This sheet must be named “Containers”, and the columns described must not be reordered. The sheet contains description of the content of the container (packet). As per XTCE, a container is a structure describing a binary chunk of data composed of multiple entries. A container can inherit from other container - meaning that it takes all entries from the parent and it adds some more. It can have two types of entries: parameters other containers (this is called aggregation) General conventions: first line with a new ‘container name’ starts a new packet second line after a new ‘container name’ should contain the first measurement empty lines are only allowed between two packets Comment lines starting with “#” on the first column can appear everywhere and are ignored. container name The relative name of the packet inside the space system parent Parent container and position in bits where the subcontainer starts, for example PARENT_CONTAINER:64. If position in bits is not specified, the default position is to start from the last parameter in the parent. If parent is not specified, either the container is the root, or it can be used as part of another container in aggregation. condition Inheritance condition, usually specifies a switch within the parent which activates this child, for example `MID=0x101` There are currently three forms supported: Simple condition: Parameter==value Condition list: Parameter==value;Parameter2==value2 - all conditions must be true Boolean condition: op(epx1;exp2;...;expn) op is '&amp;' (AND) or '|' (OR) expi is a boolean expression or a simple condition Currently the only supported conditions are on the parameters of the parent container. This cover the usual case where the parent defines a header and the inheritance condition is based on paraemters from the header. Parameters Sheet This sheet must be named ending with “Parameters”, and the columns described must not be reordered. The sheet contains parameter (sometimes called measurements) information. Any number of sheets ending with “Parameters” can be present and they all have the same structure. Each parameter has a so called “DataSource” (as per XTCE) which is not immediately configured. However by historical convention: DerivedParameters contains all parameter whose data source is set to \"DERIVED\" - these are usually results of algorithm computations. LocalParameters contains all parameters whose data source is set to \"LOCAL\" - these are parameters that can be set by the user using the Yamcs API All other parameter sheets contain parameters whose data source is set to \"TELEMETERED\" - these are parameters received from remote devices A parameter when extracted from a binary packet has two forms: a raw value and an engineering value. The extraction from the raw packet is performed according to the encoding, whereas the conversion from raw to engineering value is performed by a calibrator. This sheet can also be used to specify parameters without encoding - if they are received already extracted, Yamcs can do only their calibration. Or it can be that a parameter is already calibrated, it can still be specified here to be able to associate alarms. Empty lines can appear everywhere and are ignored. Comment lines starting with “#” on the first column can appear everywhere and are ignored. name The name of the parameter in the namespace. encoding Description on how to extract the raw type from the binary packet. See below for all supported encodings. raw type See below for all supported raw types eng type See Engineering Types eng unit Free-form textual description of unit(s). E.g. degC, W, V, A, s, us calibration Name of a calibration described in the Calibration sheet, leave empty if no calibration is applied description Optional human-readable text namespace:&lt;NS-NAME&gt; If present, these columns can be used to assign additional names to the parameters in the namespace NS-NAME. Any number of columns can be present to give additional names in different namespaces. Encoding and Raw Types Raw types describe how the parameter is encoded in the raw packet. All types are case-insensitive. Raw Type Encoding Description uint unsigned(&lt;n&amp;gt,&lt;BE|LE&gt;) Unsigned integer. n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for unsigned(&lt;n&gt;,BE) int twosComplement(&lt;n&gt;, &lt;BE|LE&gt;) two's complement encoding n is size in bits. LE = little endian, BE = big endian. signMagnitude(&lt;n&gt;, &lt;BE|LE&gt;) sign magnitude encoding - first (or last for LE) bit is the sign, the remaining bits represent the magnitude (absolute value). n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for twosComplement(&lt;n&gt;,BE) float ieee754_1985(&lt;n&gt;, &lt;BE|LE&gt;) IEE754_1985 encoding n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for iee754_1985(&lt;n&gt;,BE) boolean &lt;empty&gt; the encoding has to be empty - 1 bit is assumed. string fixed(&lt;n&gt;, &lt;charset&gt;) fixed size string n is the size in bits of the string. Only multiple of 8 supported. charset is one of the charsets supported by java (UTF-8, ISO-8859-1, etc). If not specified, it is by default UTF-8 The string has to start at a byte boundary inside the container. PrependedSize(&lt;x&gt;, &lt;charset&gt;) The size of string in bytes is specified in first x bits of string - the size itself will not be part of the string. x is the size in bits of the size tag charset is as defined above. Note that while x can be any number of bits&lt;=32, the string has to start at a byte boundary. terminated(&lt;0xBB&gt;, &lt;charset&gt;) terminated string - pay attention to the parameters following this one; if the terminator is not found all the buffer will be consumed; 0xBB specifies a byte that is the string terminator charset is as defined above. binary fixed(&lt;n&gt;) fixed size byte array. n size of the array in bits. It has to be multiple of 8 and the parameter has to start at a byte boundary. PrependedSize(&lt;x&gt;) byte array whose size in bytes is specified in the first x bits of the array - the size itself will not be part of the raw value. x is the size in bits of the size tag Note that while x can be any number of bits&lt;=32, the byte array has to start at a byte boundary. &lt;n&gt; shortcut for fixed(&lt;n&gt;) &lt;any of the above&gt; custom(&lt;n&gt;,algorithm) The decoding will be performed by a user defined algorithm. &lt;n&gt; is optional and may be used to specify the size in bits of the entry in the container (in case the size is fixed) - it will use for optimizing the access to the parameters following this one. algorithm the name of the algorithm - it has to be defined in the algorithm sheet Engineering Types Engineering types describe a parameter in its processed form (i.e. after any calibrations). All types are case-insensitive. Depending on the combination of raw and engineering type, automatic conversion is applicable. For more advanced use cases, define and refer to a Calibrator in the Calibration Sheet Type Description Automatic Raw Conversion uint Unsigned 32 bit integer - it corresponds to int in java and uint32 in protobuf From int, uint or string uint64 Unsigned 64 bit integer - it corresponds to long in java and uint64 in protobuf From int, uint or string int Signed 32 bit integer - it corresponds to int in java and int32 in protobuf From int, uint or string int64 Signed 64 bit integer - it corresponds to long in java and int64 in protobuf From int, uint or string string Character string - it corresponds to String in java and string in protobuf From string float 32 bit floating point number - it corresponds to float in java and protobuf From float, int, uint or string double 62 bit floating point number - it corresponds to double in java and protobuf From float, int, uint or string enumerated A kind of string that can only be one out of a fixed set of predefined state values. It corrersponds to String in java and string in protobuf. From int or uint. A Calibrator is required. boolean A binary true/false value - it corresponds to 'boolean' in java and 'bool' in protobuf From any raw type Values equal to zero, all-zero bytes or an empty string are considered false binary Byte array - it corresponds to byte[] in java and bytes in protobuf. From bytestream only Calibration Sheet This sheet must be named “Calibration”, and the columns described must not be reordered. The sheet contains calibration data including enumerations. calibrator name Name of the calibration - it has to match the calibration column in the Parameter sheet. type One of the following: polynomial for polynomial calibration. Note that the polynomial calibration is performed with double precision floating point numbers even though the input and/or output may be 32 bit. spline for linear spline(pointpair) interpolation. As for the polynomial, the computation is performed with double precision numbers. enumeration for mapping enumeration states java-expression for writing more complex functions calib1 If the type is polynomial: it list the coefficients, one per row starting with the constant and up to the highest grade. There is no limit in the number of coefficients (i.e. order of polynomial). If the type is spline: start point (x from (x,y) pair) If the type is enumeration: numeric value If the type is java-expression: the textual formula to be executed (see below) calib2 If the type is polynomial: leave empty If the type is spline: stop point (y) corresponding to the start point(x) in calib1 If the type is enumeration: text state corresponding to the numeric value in calib1 If the type is java-expression: leave empty Java Expressions This is intended as a catch-all case. XTCE specifies a MathOperationCalibration calibrator that is not implemented in Yamcs. However these expressions can be used for the same purpose. They can be used for float or integer calibrations. The expression appearing in the calib1 column will be enclosed and compiled into a class like this: package org.yamcs.xtceproc.jecf; public class Expression665372494 implements org.yamcs.xtceproc.CalibratorProc { public double calibrate(double rv) { return &lt;expression&gt;; } } The expression has usually to return a double; but java will convert implicitly any other primitive type to a double. Java statements cannot be used but the conditional operator “? :” can be used; for example this expression would compile fine: rv&gt;0?rv+5:rv-5 Static functions can be also referenced. In addition to the usual Java ones (e.g. Math.sin, Math.log, etc) user own functions (that can be found as part of a jar on the server in the lib/ext directory) can be referenced by specifying the full class name: my.very.complicated.calibrator.Execute(rv) Algorithms Sheet This sheet must be named “Algorithms”, and the columns described must not be reordered. The sheet contains arbitrarily complex user algorithms that can set (derived) output parameters based on any number of input parameters. Comment lines starting with “#” on the first column can appear everywhere and are ignored. Empty lines are used to separate algorithms and cannot be used inside the specification of one algorithm. algorithm name The identifying name of the algorithm. algorithm language The programming language of the algorithm. Currently supported values are: JavaScript python - note that this requires the presence of jython.jar in the Yamcs lib or lib/ext directory (it is not delivered together with Yamcs). Java text The code of the algorithm (see below for how this is interpreted). trigger Optionally specify when the algorithm should trigger: OnParameterUpdate('/some-param', 'some-other-param')Execute the algorithm whenever any of the specified parameters are updated OnInputParameterUpdateThis is the same as above for all input parameters (i.e. execute whenever any input parameter is updated). OnPeriodicRate(&lt;fireRate&gt;)Execute the algorithm every fireRate milliseconds noneThe algorithm doesn't trigger automatically but can be called upon from other parts of the system (like the command verifier) The default is none. in/out Whether a parameter is inputted to, or outputted from the algorithm. Parameters are defined, one per line, following the line defining the algorithm name parameter reference Reference name of a parameter. See above on how this reference is resolved. Algorithms can be interdependent, meaning that the output parameters of one algorithm could be used as input parameters of another algorithm. instance Allows inputting a specific instance of a parameter. At this stage, only values smaller than or equal to zero are allowed. A negative value, means going back in time. Zero is the default and means the actual value. This functionality allows for time-based window operations over multiple packets. Algorithms with windowed parameters will only trigger as soon as all of those parameters have all instances defined (i.e. when the windows are full). Note that this column should be left empty for output parameters. name used in the algorithm An optional friendlier name for use in the algorithm. By default the parameter name will be used, which may lead to runtime errors depending on the naming conventions of the applicable script language. Note that a unique name will be required in this column, when multiple instances of the same parameter are inputted. JavaScript algorithms A full function body is expected. The body will be encapsulated in a javascript function like function algorithm_name(in_1, in_2, ..., out_1, out_2...) { &lt;algorithm-text&gt; } The in_n and outX are to be names given in the spreadsheet column name used in the algorithm. The method can make use of the input variables and assign out_x.value (this is the engineering value) or out_x.rawValue (this is the raw value) and out_x.updated for each output variable. The .updated can be set to false to indicate that the output value has not to be further processed even if the algorithm has run. By default it is true - meaning that each time the algorithm is run, it is assumed that it updates all the output variables. If out_x.rawValue is set and out_x.value is not, then Yamcs will run a calibration to compute the engineering value. Note that for some algorithms (e.g. command verifiers) need to return a value (rather Python algorithms This works very similarly with the JavaScript algorithms, The thing to pay attention is the indentation. The algorithm text wihch is specified in the spreadsheet will be automatically indeted with 4 characters. function algorithm_name(in_1, in_2, ..., out_1, out_2...) { &lt;algorithm-text&gt; } Java algorithms The algorithm text is a class name with optionally parantheses enclosed string that is parsed into an object by an yaml parser. Yamcs will try to locate the given class who must be implementing the org.yamcs.algorithms.AlgorithmExecutor interface and will create an object with a constructor with three paramethers: &lt;Constructor&gt;(Algorithm, AlgorithmExecutionContext, Object arg) where arg is the argument parsed from the yaml. If the optional argument is not present in the algorithm text definition, then the class constructor should only have two parameters. The abstract class org.yamcs.algorithms.AbstractAlgorithmExecutor offers some helper methods and can be used as base class for implementation of such algorithm. If the algorithm is used for data decoding, it has to implement the org.yamcs.xtceproc.DataDecoder interface instead (see below). Command verifier algorithms Command verifier algorithms are special algorithms associated to the command verifiers. Multiple instances of the same algorithm may execute in parallel if there are multiple pending commands executed in parallel. These algorithms are special as they can use as input variables not only parameters but also command arguments and command history events. These are specified by using “/yamcs/cmd/arg/” and “/yamcs/cmdHist” prefix respectively. In addition these algorithms may return a boolean value (whereas the normal algorithms only have to write to output variables). The returned value is used to indicate if the verifier has succeeded or failed. No return value will mean that the verifier is still pending. Data Decoding algorithms The Data Decoding algorithms are used to extract a raw value from a binary buffer. These algorithms do not produce any output and are triggered whenever the parameter has to be extracted from a container. These algorithms work differently from the other ones and have are some limitations: only Java is supported as a language not possible to specify input parameters These algorithms have to implement the interface org.yamcs.xtceproc.DataDecoder. Example Definition algo name language text trigger in/out param name instance friendlyname my_avg JavaScript r.value = (a.value + b.value + c.value) / 3; OnInputParameterUpdate in /MY_SS/some_temperature -2 a in /MY_SS/some_temperature -1 b in /MY_SS/some_temperature 0 c out /MY_SS/avg_out r Example Definition for a command verifier algorithm algo name language text trigger in/out param name instance friendlyname alg_verif_completed JavaScript if((receivedCmdId.value==sentCmdId.value) &amp;&amp; (receivedSeqNum.value==sentSeqNum.value) &amp;&amp; (stage.value==2) ) { if(result.value==0) return true; else return false;} in /yamcs/cmd/arg/packet-id sentCmdId in /yamcs/cmdHist/ccsds-seqcount sentSeqNum in avc_command_seq receivedSeqNum in avc_command_id receivedCmdId in avc_command_execution_stage stage in avc_command_result result Alarms Sheet This sheet must be named “Alarms”, and the columns described must not be reordered. The sheet defines how the monitoring results of a parameter should be derived. E.g. if a parameter exceeds some pre-defined value, this parameter’s state changes to CRITICAL. parameter name The reference name of the parameter for which this alarm definition applies context A condition under which the defined triggers apply. This can be used to define multiple different sets of triggers for one and the same parameter, that apply depending on some other condition (typically a state of some kind). When left blank, the defined set of conditions are assumed to be part of the default context. Contextual alarms are evaluated from top to bottom, until a match is found. If no context conditions apply, the default context applies. report When alarms under the given context should be reported. Should be one of OnSeverityChange or OnValueChange. With OnSeverityChange being the default. The condition OnValueChange will check value changes based on the engineering values. It can also be applied to a parameter without any defined severity levels, in which case an event will be generated with every change in value. minimum violations Number of successive instances that meet any of the alarm conditions under the given context before the alarm event triggers (defaults to 1). This field affects when an event is generated (i.e. only after X violations). It does not affect the monitoring result associated with each parameter. That would still be out of limits, even after a first violation. watch: trigger type One of low, high or state. For each context of a numeric parameter, you can have both a low and a high trigger that lead to the WATCH state. For each context of an enumerated parameter, you can have multiple state triggers that lead to the WATCH state. watch: trigger value If the trigger type is low or high: a numeric value indicating the low resp. high limit value. The value is considered inclusive with respect to its nominal range. For example, a low limit of 20, will have a WATCH alarm if and only if its value is smaller than 20. If the trigger value is state: a state that would bring the given parameter in its WATCH state. warning: trigger typewarning: trigger value Analogous to watch condition distress: trigger typedistress: trigger value Analogous to watch condition critical: trigger typecritical: trigger value Analogous to watch condition severe: trigger typesevere: trigger value Analogous to watch condition Example Definition param name context rep min.v watch warning distress critical severe type val type val type val type val type val int_para low -11 low -22 low -33 high 30 high 40 high 50 high 60 high 70 &nbsp; other_para = 4 3 high 40 high 50 high 70 &nbsp; enum_para state ST1 state ST2 state ST4 state ST3 Commands Sheet This sheet must be named “Commands”, and the columns described must not be reordered. The sheet contains commands description, including arguments. General convention: First line with a new ‘Command name’ starts a new command Second line after a new ‘Command name’ should contain the first command arguments Empty lines are only allowed between two commands. Command name The name of the command. Any entry starting with `#` is treated as a comment row parent name of the parent command if any. Can be specified starting with / for an absolute reference or with ../ for pointing to parent SpaceSystem :x means that the arguments in this container start at position x (in bits) relative to the topmost container. Currently there is a problem for containers that have no argument: the bit position does not apply to children and has to be repeated. argAssignment name1=value1;name2=value2.. where name1,name2.. are the names of arguments which are assigned when the inheritance takes place flags For commands: A=abstract. For arguments: L = little endian argument name From this column on, most of the cells are valid for arguments only. These have to be defined on a new row after the command. The exceptions are: description, aliases relpos Relative position to the previous argument default is 0 encoding How to convert the raw value to binary. The supported encodings are listed in the table below. eng type Dngineering type; can be one of: uint, int, float, string, binary, enumerated, boolean or FixedValue. FixedValue is like binary but is not considered an argument but just a value to fill in the packet. raw type Raw type: one of the types defined in the table below. (default) value Default value. If eng type is FixedValue, this has to contain the value in hexadecimal. Note that when the size of the argument is not an integer number of bytes (which is how hexadecimal binary strings are specified), the most significant bits are ignored. eng unit calibration Point to a calibration from the Calibration sheet range low The value of the argument cannot be smaller than this. For strings and binary arguments this means the minimum length in characters, respectively bytes. range high The value of the argument cannot be higher than this. Only applies to numbers. For strings and binary arguments this means the minimum length in characters, respectively bytes. description Optional free text description Encoding and Raw Types for command arguments The raw type and encoding describe how the argument is encoded in the binary packet. All types are case-insensitive. Raw Type Encoding Description uint unsigned(&lt;n&amp;gt,&lt;BE|LE&gt;) Unsigned integer. n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for unsigned(&lt;n&gt;,BE) int twosComplement(&lt;n&gt;, &lt;BE|LE&gt;) two's complement encoding n is size in bits. LE = little endian, BE = big endian. signMagnitude(&lt;n&gt;, &lt;BE|LE&gt;) sign magnitude encoding - first (or last for LE) bit is the sign, the remaining bits represent the magnitude (absolute value). n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for twosComplement(&lt;n&gt;,BE) float ieee754_1985(&lt;n&gt;, &lt;BE|LE&gt;) IEE754_1985 encoding n is size in bits. LE = little endian, BE = big endian. &lt;n&gt; shortcut for iee754_1985(&lt;n&gt;,BE) boolean &lt;empty&gt; the encoding has to be empty - 1 bit is assumed. string fixed(&lt;n&gt;, &lt;charset&gt;) fixed size string n is the size in bits of the string. Only multiple of 8 supported. charset is one of the charsets supported by java (UTF-8, ISO-8859-1, etc). If not specified, it is by default UTF-8 PrependedSize(&lt;x&gt;, &lt;charset&gt;&lt;m;&amp;gt) The size of string in bytes is specified in first x bits of string - the size itself will not be part of the string. x is the size in bits of the size tag charset is as defined above. m if specified, it is the minimum size in bits of the encoded value. Note that the prepended size reflects the real size of the string even if smaller than this minimum size. This option has been added for compatibility with the Airbus CGS system but its usage is discouraged since it is not compliant with XTCE. &lt;n&gt; shortcut for fixed(&lt;n&gt;) terminated(&lt;0xBB&gt;, &lt;charset&gt;&lt;m;&amp;gt) terminated string; 0xBB specifies a byte that is the string terminator charset is as defined above. m if specified is the minimum size in bits of the encoded value. Note that the termination character reflects the real size of the string even if smaller than this minimum size. This option has been added for compatibility with the Airbus CGS system but its usage is discouraged since it is not compliant with XTCE. binary fixed(&lt;n&gt;) fixed size byte array. n size of the array in bits. It has to be multiple of 8 and the argument has to start at a byte boundary. PrependedSize(&lt;x&gt;) byte array whose size in bytes is specified in the first x bits of the array - the size itself will not be part of the raw value. x is the size in bits of the size tag Note that while x can be any number of bits&lt;=32, the byte array has to start at a byte boundary. &lt;n&gt; shortcut for fixed(&lt;n&gt;) Command Options Sheet This sheet must be named “CommandOptions”, and the columns described must not be reordered. This sheet defines two types of options for commands: transmission constraints - these are conditions that have to be met in order for the command to be sent. command significance - this is meant to flag commands that have a certain significance. Currently the significance is only used by the end user applications (e.g. Yamcs Studio) to raise the awarness of the operator when sending such command. Command nameThe name of the command. Any entry starting with `#` is treated as a comment row Transmission ConstraintsConstrains can be specified on multiple lines. All of them have to be met for the command to be allowed for transmission. Constraint TimeoutThis refers to the left column. A command stays in the queue for that many milliseconds. If the constraint is not met, the command is rejected. 0 means that the command is rejected even before being added to the queue, if the constraint is not met. Command SignificanceSignificance level for commands. Depending on the configuration, an extra confirmation or certain privileges may be required to send commands of high significance. one of: - none - watch - warning - distress - critical - severe Significance ReasonA message that will be presented to the user explaining why the command is significant. Command Verification Sheet The Command verification sheets defines how a command shall be verified once it has been sent for execution. The transmission/execution of a command usual goes through multiple stages and a verifier can be associated to each stage. Each verifier runs within a defined time window which can be relative to the release of the command or to the completion of the previous verifier. The verifiers have three possible outcomes: OK = the stage has been passed successfully. NOK = the stage verification has failed (for example there was an error on-board when executing the command, or the uplink was not activated). timeout - the condition could not be verified within the defined time interval. For each verifier it has to be defined what happens for each of the three outputs. Command name The command relative name as defined in the Command sheet. Referencing commands from other subsystems is not supported. CmdVerifier Stage Any name for a stage is accepted but XTCE defines the following ones: TransferredToRange SentFromRange Received Accepted Queued Execution Complete Failed Yamcs interprets these as strings without any special semantics. If special actions (like declaring the command as completed) are required for Complete or Failed, they have to be configured in OnuSccess/OnFail/OnTimeout columns. By default command history events with the name Verification_&lt;stage&gt; are generated.\" CmdVerifier Type Supported types are: container – the command is considered verified when the container is received. Note that this cannot generate a Fail (NOK) condition - it's either OK if the container is received in the timewindow or timeout if the container is not received. algorithm – the result of the algorithm run is used as the output of the verifier. If the algorithm is not run (because it gets no inputs) or returns null, then the timeout condition applies CmdVerifier Text Depending on the type: container: is the name of the container from the Containers sheet. Reference to containers from other space systems is not supported. algorithm: is the name of the algorithm from the Algorithms sheet. Reference to algorithms from other space systems is not supported. Time Check Window start,stop in milliseconds defines when the verifier starts checking the command and when it stops. checkWindow is relative to LastVerifier (default) – the start,stop in the window definition are relative to the end of the previous verifier. If there is no previous verifier, the start,stop are relative to the command release time. If the previous verifier ends with timeout, this verifier will also timeout without checking anything. CommandRelease - the start,stop in the window definition are relative to the command release. OnSuccess Defines what happens when the verification returns true. It has to be one of: SUCCESS: command considered completed successful (CommandComplete event is generated) FAIL: CommandFailed event is generated none (default) – only a Verification_stage event is generated without an effect on the final execution status of the command. OnFail Same like OnSuccess but the evnet is generated in case the verifier returns false. OnTimeout Same as OnSuccess but the event is generated in case the verifier times out. Change Log Sheet This sheet must be named “ChangeLog”, and the columns described must not be reordered. This sheet contains the list of the revision made to the MDB. "},{"title":"Stream Archive","url":"/docs/server/Stream_Archive/","body":"Yamcs uses streams to transfer tuples of data. A tuple has a variable number of columns, each of predefined type. The Yamcs stream archive is composed of tables that store data passing through streams. Like streams, the tables have a variable number of columns of predefined types. In addition to that, the tables have also a primary key composed of one or more columns. The primary key columns are mandatory, a tuple that doesn’t have them will not be stored in the table. The primary key is used to sort the data in the table. Yamcs uses a (key,value) storage engine (currently RocksDB) for storing the data. Both key and value are byte arrays. Yamcs uses the serialized primary key of the table as the key in RocksDb and the remaining columns serialized as the value. Although not enforced by Yamcs, it is usual to have the time as part of the primary key. On the basic stream archive structure, Yamcs pre-defines a few table types for storing data at higher level of abstractions. These are Packet telemetry, Events, Command history, Alarms and Parameters and are described in the next sections. Packet telemetry The below definition (created inside the XtceTmRecorder service) will create a table that uses the generation time and sequence number as primary key. That means that if a packet has the same time and sequence number as another packet already in the archive, it will not be stored (considered duplicate). CREATE TABLE tm( gentime TIMESTAMP, seqNum INT, packet BINARY, pname ENUM, PRIMARY KEY( gentime, seqNum ) ) HISTOGRAM(pname) PARTITION BY TIME_AND_VALUE(gentime, pname) TABLE_FORMAT=compressed; Following is a short description of the columns used: gentime - is the generation time of the packet. seqNum - is an increasing sequence number. packet - is the binary packet. pname - is the XTCE fully qualified name of the container. In the XTCE container hierarchy, one has to configure which containers are used as partitions. This can be done by setting a flag in the spreadsheet. The HISTOGRAM(pname) clause means that Yamcs will build an overview that can be used to quickly see when data for the given packet name is available in the archive. The PARTITION BY TIME_AND_VALUE clause means that data will be partition in different RocksDB databases and column families based on the time and container name. Currently the time partitioning schema used is “YYYY/MM” which means there will be one RocksDB database per year,month. Inside that database there will be one column family for each container that is used for partitioning. Parittioning the data based on time, ensures that old data will be “frozen” and not disturbed by new data coming in. Partitioning by container has benefits when retrieving data for one specific container for a time interval. If this is not desired, one can set the partitioning flag only on the root container (in fact it is automatically set) so all packets will be stored in the same partition. Events The below definition (created by the EventRecorder service) will create a table that uses the generation time, source and sequence number as primary key. CREATE TABLE events( gentime TIMESTAMP, source ENUM, seqNum INT, body PROTOBUF('org.yamcs.protobuf.Yamcs$Event'), PRIMARY KEY( gentime, source, seqNum ) ) HISTOGRAM(source) partition by time(gentime) table_format=compressed; Following is a short description of the columns used: gentime - is the generation time of the command set by the originator source - is a string representing the source of the events seqNum - is a sequence number provided by the event source. Each source is supposed to keep an independent sequence count for the events it generates. Command history The below definition (created by the CommandHistoryRecorder service) will create a table that uses the generation time, origin and sequence number as primary key: CREATE TABLE cmdhist( gentime TIMESTAMP, origin STRING, seqNum INT, cmdName STRING, binary BINARY, PRIMARY KEY( gentime, origin, seqNum ) ) HISTOGRAM(cmdName) PARTITION BY TIME(gentime) table_format=compressed; Following is a short description of the columns used: gentime - is the generation time of the command set by the originator origin - is a string representing the originator of the command seqNum - is a sequence number provided by the originator. Each command originator is supposed to keep an independent sequence count for the commands it sends. cmdName - is the XTCE fully qualified name of the command. binary - the binary packet contents. In addition to these columns, there will be numerous dynamic columns set by the command verifiers, command releasers,etc. Recording data into this table is setup with the following statements: INSERT_APPEND INTO cmdhist SELECT * FROM cmdhist_realtime; INSERT_APPEND INTO cmdhist SELECT * FROM cmdhist_dump; The INSERT_APPEND says that if a tuple with the new key is received on one of the cmdhist_realtime or cmdhist_dump streams, it will be just inserted into the cmdhist table. If however, a tuple with a key that already exists in the table is received, the columns that are new in the newly received tuple are appended to the already existing columns in the table. Alarms The below definition (created by the AlarmRecorder service) will create a table that uses the trigger time, parameter name and sequence number as primary key: CREATE TABLE alarms( triggerTime TIMESTAMP, parameter STRING, seqNum INT, PRIMARY KEY( triggerTime, parameter, seqNum ) ) table_format=compressed; Following is a short description of the columns used: triggerTime - is the time when the alarm has been triggered. Until an alarm is acknowledged, there will not be a new alarm generated for that parameter (even though it goes back in limits in the meanwhile) parameter - the fully qualified XTCE name of the parameter for which the alarm has been triggered. seqNum - a sequence number increasing with each new triggered alarm. The sequence number will reset to 0 at Yamcs restart. Parameters The below definition (created by the ParameterRecorder service) will create a table that uses the generation time and sequence number as primary key: CREATE TABLE pp( gentime TIMESTAMP, ppgroup ENUM, seqNum INT, rectime TIMESTAMP, primary key( gentime, seqNum ) ) histogram(ppgroup) PARTITION BY TIME_AND_VALUE(gentime,ppgroup) table_format=compressed; Following is a short description of the columns used: gentime - is the generation time of the command set by the originator. ppgroup - is a string used to group parameters. The parameters sharing the same group and the same timestamp are stored together. seqNum - is a sequence number supposed to be increasing independently for each group. rectime - is the time when the parameters have been received by Yamcs. In addition to these columns that are statically created, the pp table will store columns with the name of the parameter and the type PROTOBUF(org.yamcs.protobuf.Pvalue$ParameterValue). Note that because partitioning by ppgroup is specified, this is also implicitly part of the primary key (but not stored as such in the RocksDB key). "},{"title":"Stream Parameter Provider","url":"/docs/server/Stream_Parameter_Provider/","body":"Provides parameters received from the configured param stream. Class Name org.yamcs.tctm.StreamParameterProvider Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.tctm.StreamParameterProvider args: stream: \"pp_realtime\" Configuration Options Name Type Description streams list of strings Required. The streams to read. "},{"title":"Stream TC Command Releaser","url":"/docs/server/Stream_TC_Command_Releaser/","body":"Sends commands to the configured tc stream. Class Name org.yamcs.StreamTcCommandReleaser Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.StreamTcCommandReleaser args: stream: \"tc_realtime\" Configuration Options Name Type Description stream string Required. The stream to send commands to. "},{"title":"Stream TM Packet Provider","url":"/docs/server/Stream_TM_Packet_Provider/","body":"Receives packets from tm streams and sends them to the processor for extraction of parameters. This respects the root container defined as part of the streamConfig in yamcs.yaml. Class Name org.yamcs.StreamTmPacketProvider Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.StreamTmPacketProvider args: streams: [\"tm_realtime\", \"tm_dump\"] Configuration Options Name Type Description streams list of strings Required. The streams to read. "},{"title":"Stream Updates","url":"/docs/http/Stream_Updates/","body":"The stream resource type within the WebSocket API groups low-level subscribe operations on Yamcs Streams. The documented operations work on one of the built-in streams (like tm, tm_realtime, tm_dump, pp_realtime, cmdhist_realtime, etc). Or, if your Yamcs deployment defines any other streams, they would work as well. Subscribe to a Stream Within the WebSocket request envelope use these values: request-type stream request subscribe data With Protobuf: an object of type Yamcs.StreamSubscribeRequest where at least the stream name is filled in. With JSON: an object literal where at least the stream key is set. Here’s a full request example in JSON-notation [1,1,3,{\"stream\": \"subscribe\", \"data\": {\"stream\": \"tm_realtime\"}}] As a result of the above call you will get updates whenever anybody publishes data to the specified stream. With Protobuf, the data can be fetched with the getStreamData()-method on in the WebSocketSubscriptionData object. With JSON, you might see something like this example output: [1,2,3] [1,4,0,{\"dt\":\"STREAM_DATA\",\"data\":{\"stream\":\"tm_realtime\",\"columnValue\":[{\"columnName\":\"gentime\",\"value\":{\"type\":6,\"timestampValue\":1438608491320}},{\"columnName\":\"seqNum\",\"value\":{\"type\":3,\"sint32Value\":134283264}},{\"columnName\":\"rectime\",\"value\":{\"type\":6,\"timestampValue\":1438608508323}},{\"columnName\":\"packet\",\"value\":{\"type\":4,\"binaryValue\":\"CAEAAAAPQuou2FJFAAAABOcAAAAAAA==\"}}]}}] [1,4,1,{\"dt\":\"STREAM_DATA\",\"data\":{\"stream\":\"tm_realtime\",\"columnValue\":[{\"columnName\":\"gentime\",\"value\":{\"type\":6,\"timestampValue\":1438608491320}},{\"columnName\":\"seqNum\",\"value\":{\"type\":3,\"sint32Value\":134283264}},{\"columnName\":\"rectime\",\"value\":{\"type\":6,\"timestampValue\":1438608508323}},{\"columnName\":\"packet\",\"value\":{\"type\":4,\"binaryValue\":\"CAEAAAAPQuou2FJFAAAABOcAAAAAAA==\"}}]}}] In the case we were receiving some simulated data from the tm_realtime stream, this is a built-in stream with columns gentime, rectime, seqNum and packet. This last column is of binary format (it’s the raw TM packet), which is why it is Base64-encoded in the JSON output. Other streams would have different columns. "},{"title":"Streams","url":"/docs/http/Streams/","body":" "},{"title":"System","url":"/docs/server/System/","body":"The System module within the Yamcs web interface provides a set of administrative views on Yamcs. The System Module is always visited for a specific Yamcs instance, although some of the information may be global to Yamcs. Dashboard This provides a quick glance at the running system. It shows a quick graph of JVM system parameters and provides some basic server information such as the version number of Yamcs. Links Shows a live view of the data links for this instance. Link can be managed directly from this page. Services Shows the services for this instance. The lifecycle of these services can be managed directly from this page. Processors Shows a live view of the processors for this instance. This includes both persistent and non-persistent processors. Each processor has a detail page that allows seeing some statistics on the incoming packets, and that provides management controls over the command queues for this processor. Clients Shows the clients connected to this instance. Tables Shows the archive tables for this instance. Each table has a detail page that shows details about its structure and SQL options and that provides a quick view at the raw data records. Streams Shows the streams for this instance. Each stream has a detail page that shows details about its SQL definition. "},{"title":"System Parameter Provider","url":"/docs/server/System_Parameter_Provider/","body":"Provides parameters received from the sys_param stream. Class Name org.yamcs.parameter.SystemParametersProvider Configuration This service is defined in etc/processor.yaml. Example: processor.yaml realtime: services: - class: org.yamcs.parameter.SystemParametersProvider "},{"title":"System Parameters Collector","url":"/docs/server/System_Parameters_Collector/","body":"Collects system parameters from any Yamcs component at a frequency of 1Hz. Parameter values are emitted to the sys_var stream. Class Name org.yamcs.parameter.SystemParametersCollector Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.parameter.SystemParametersCollector args: provideJvmVariables: true Configuration Options Name Type Description provideJvmVariables boolean When set to true this service will create a few system parameters that allows monitoring basic JVM properties such as memory usage and thread count. Default: false "},{"title":"TCP TC Data Link","url":"/docs/server/TCP_TC_Data_Link/","body":"Sends telecommands via TCP. Class Name org.yamcs.tctm.TcpTcDataLink Configuration Options Name Type Description stream string Required. The stream where command instructions are received host string Required. The host of the TC provider port integer Required. The TCP port to connect to tcQueueSize integer Limit the size of the queue. Default: unlimited tcMaxRate integer Ensure that on overage no more than tcMaxRate commands are issued during any given second. Default: unspecified commandPostprocessorClassName string Class name of a CommandPostprocessor implementation. Default is org.yamcs.tctm.IssCommandPostProcessor which applies ISS conventions. commandPostprocessorArgs map Optional args of arbitrary complexity to pass to the CommandPostprocessor. Each CommandPostprocessor may support different options. "},{"title":"TCP TM Data Link","url":"/docs/server/TCP_TM_Data_Link/","body":"Provides packets received via plain TCP sockets. In case the TCP connection with the telemetry server cannot be opened or is broken, it retries to connect each 10 seconds. Class Name org.yamcs.tctm.TcpTmDataLink Configuration Options Name Type Description host string Required. The host of the TM provider port integer Required. The TCP port to connect to stream string Required. The stream where data is emitted packetInputStreamClassName string Class name of a PacketInputStream implementation. Default is org.yamcs.tctm.CcsdsPacketInputStream which reads CCSDS Packets. packetInputStreamArgs map Optional args of arbitrary complexity to pass to the PacketInputStream. Each PacketInputStream may support different options. packetPreprocessorClassName string Class name of a PacketPreprocessor implementation. Default is org.yamcs.tctm.IssPacketPreprocessor which applies ISS conventions. packetPreprocessorArgs map Optional args of arbitrary complexity to pass to the PacketPreprocessor. Each PacketPreprocessor may support different options. "},{"title":"TC Loaders","url":"/docs/server/TC_Loaders/","body":"Excel Spreadsheet This the Yamcs Excel spreadsheets loader, which can define a full MDB based on the XTCE components: Telemetry, Telecommand, Process Parameters and Algorithms. CD-MCS MDB The CD-MCS MDB reads data directly from the CD-MCS Oracle. "},{"title":"TM Loaders","url":"/docs/server/TM_Loaders/","body":"Excel Spreadsheet This loader constructs the MDB using containers and parameters defined in one or more Yamcs Excel spreadsheets. The loader is configured in etc/mdb.yaml. Specify the ‘type’ as sheet, and provide the location of the spreadsheet file in the spec attribute. Additional spreadsheets may be specified in a subLoaders list, using the type and spec attributes for each additional spreadsheet. XTCE files This loader reads an MDB saved in XML format compliant with the XTCE specification. For more information about XTCE, see http://www.xtce.org. The loader is configured inetc/mdb.yaml. Specify the ‘type’ as xtce, and provide the location of the XML file in the spec attribute. CD-MCS MDB This loader loads the telemetry definition directly from the Oracle using the oracle jdbc driver. The relevant configuration file is etc/cdmcs-mdb.yaml. This configuration file contains, next to the username/password used to connect to the database, the path and the version of the CCU that will be loaded and also the testConfiguration (an end item of type EGSE_TEST_CONFIGURATION). Based on the CCU parameters and on the opsname of the testConfiguration (the test configuration can only be specified through its opsname, so the opsname must exist and be unique.), Yamcs can determine the following three attributes which are used as attributes of the XTCE header: CCU Internal Version - this is a number uniquely identifying the CCU and the CCU version Test Configuration SID - this is a number uniquely identifying the test configuration Consistency Date - this is the time when the configured CCU has been last modified. Please refer to Telemetry Processing and to Commanding for details on the loading of the MDB end items and on the mapping to Yamcs structures. The configuration parameter checkForUpdatedMdb configures Yamcs to check or not the Oracle database for modified versions of the MDB. If the MDB cannot be loaded from the serialized file, the Oracle database is checked nevertheless. This option is useful for working offline. However if it is set to false, Yamcs will never read new versions of the database, and if the database is modified and SCOE files generated, MCS Tools will refuse to load the SCOE files (it will want old ones corresponding to the saved Yamcs database). The packet description in CD-MCS MDB is spread over different structures. When read into Yamcs, they are converted into the XTCE structures as follows: A generic sequence container named “ccsds” is created. This will be the root of the hierarchy. Three parameters are added to this sequence container: CCSDS_APID the APID in the CCSDS primary header CCSDS_SH_PACKETTYPE the packet type in the CCSDS secondary header CCSDS_PACKETID the packet type in the CCSDS secondary header A generic sequence container named CCSDS_RESPONSE_PACKET inheriting from the “CCSDS” container is created. The inheritance condition is CCSDS_SH_PACKETTYPE=12(Response_packet). This packet can be used by the CIS clients which want to subscribe to all the CCSDS response packets (for example the cmd-history). All the command responses (CCSDS_ADU_DESCRIPTION which have CCSDS Secondary Header set to CCSDS_RESPONSE_PACKET) are set to inherit the CCSDS_RESPONSE_PACKET container defined above. The inheritance condition is set on the CCSDS_APID, CCSDS_PACKETID parameters. All others CCSDS_ADU_DESCRIPTION are set to inherit directly the root container CCSDS. The inheritance condition is set also on the CCSDS_APID and CCSDS_PACKETID parameters. For each CCSDS_ADU_DESCRIPTION that contains a “Reference To a Structure ID or Table” pointing to an end item of type MEASUREMENT_LIST_TABLE, an additional integer parameter is created containing the definition of the “Flexible ID” as defined in this aggregate. Then for each end item of type PUS_STRUCTURE_ID referred in the MEASUREMENT_LIST_TABLE, a sequence container is created in Yamcs, set to inherit the original CCSDS_ADU_DESCRIPTION with the inheritance condition on the Flexible ID as defined in the MEASUREMENT_LIST_TABLE. "},{"title":"TSE Commander","url":"/docs/server/TSE_Commander/","body":"This service allows dispatching commands to Test Support Equipment (TSE). The instrument must have a remote control interface (Serial, TCP/IP) and should support a text-based command protocol such as SCPI. Class Name org.yamcs.tse.TseCommander Configuration This is a global service defined in etc/yamcs.yaml. Example from a typical deployment: yamcs.yaml services: - class: org.yamcs.tse.TseCommander Configuration Options Name Type Description telnet map Required. Configure Telnet properties.Example: { port: 8023 } tc map Required. Configure properties of the TC link.Example: { port: 8135 } tm map Required. Configure properties of the TM link.Example: { host: localhost, port: 31002 } This service reads further configuration options from a file etc/tse.yaml. This file defines all the instruments that can be commanded. Example: tse.yaml instruments: - name: tenma class: org.yamcs.tse.SerialPortDriver args: path: /dev/tty.usbmodem14141 # Note: this instrument does not terminate responses. # Use a very short timeout to compensate (still within spec) # responseTermination: \"\\n\" responseTimeout: 100 - name: simulator class: org.yamcs.tse.TcpIpDriver args: host: localhost port: 10023 responseTermination: \"\\r\\n\" - name: rigol class: org.yamcs.tse.TcpIpDriver args: host: 192.168.88.185 port: 5555 responseTermination: \"\\n\" There are two types of drivers. Both drivers support these base arguments: Name Type Description responseTermination string The character(s) by which the instrument delimits distinct responses. Typicall \\n or \\r\\n. This may be left unspecified if the instrument does not delimit responses. commandSeparation string The character(s) that indicates when the command will generate multiple distinct responses (delimited by responseTermination). For most instruments this should be left unspecified. responseTimeout integer Timeout in milliseconds for a response to arrive. Default: 3000 In addition each driver supports driver-specific arguments: TCP/IP Name Type Description host string Required. The host of the instrument. port integer Required. The TCP port to connect to. Serial Port Name Type Description path string Required. Path to the device. baudrate number The baud rate for this serial port. Default: 9600 dataBits number The number of data bits per word. Default: 8 parity string The parity error-detection scheme. One of odd or even. By default parity is not set. Mission Database The definition of TSE string commands is done in XTCE space systems resorting under /TSE. The /TSE node is added by defining org.yamcs.xtce.TseLoader in the MDB loader tree. Example: yamcs.simulator.yaml mdb: - type: org.yamcs.xtce.TseLoader subLoaders: - type: sheet spec: mdb/tse/simulator.xls The instrument name in etc/tse.yaml should match with the name of the a sub space system of /TSE. The definition of commands and their arguments follows the same approach as non-TSE commands but with some particularities: Each command should have either QUERY or COMMAND as its parent. These abstract commands are defined by the org.yamcs.xtce.TseLoader. QUERY commands send a text command to the remote instrument and expect a text response. The argument assignments command and response must both be set to a string template that matches what the instrument expects and returns. COMMAND commands send a text command to the remote instrument, but no response is expected (or it is simply ignored). Only the argument assignment command must be set to a string template matching what the instrument expects. Each TSE command may define additional arguments needed for the specific command. In the definition of the command and response string templates you can refer to the value of these arguments by enclosing the argument name in angle brackets. Example: an argument n can be dynamically substituted in the string command by referring to it as &lt;n&gt;. Additionally you can instruct Yamcs to extract one or more parameter values out of instrument response for a particular command by referring to the parameter name enclosed with backticks. This parameter should be defined in the same space system as the command and use the non-qualified name. The raw type of these parameters should be string. To illustrate these concepts with an example, consider this query command defined in the space system /TSE/simulator: Command name Parent Assignments Arguments get_identification QUERY command=*IDN? response=`identification` When issued, this command will send the string *IDN? to the instrument named simulator. A string response is expected and is read in its entirity as a value of the parameter /TSE/simulator/identification. The next example shows the definition of a TSE command that uses a dynamic argument in both the command and the response string templates: Command name Parent Assignments Arguments get_battery_voltage QUERY command=:BATTERY&lt;n&gt;:VOLTAGE? response=`battery_voltage&lt;n&gt;` n (range 1-3) When issued with the argument 2, Yamcs will send the string :BATTERY2:VOLTAGE? to the remote instrument and read back the response into the parameter /TSE/simulator/battery_voltage2. In this simple case you could alternatively have defined three distinct commands without arguments (one for each battery). When using the option commandSeparation, the response argument of the command template should use the same separator between the expected responses. For example a query of :DATE?;:TIME? with command separator ; may be matched in the MDB using the pattern: `date_param`;`time_param` (regardless of the termination character). Telnet Interface For debugging purposes, this service starts a telnet server that allows to directly relay text-based commands to the configured instruments. This bypasses the TM/TC processing chain. Access this interface with an interactive TCP client such as telnet or netcat. The server adds additional SCPI-like commands which allow to switch to any of the configured instruments in a single session. This is best explained via an example: $ nc localhost 8023 :tse:instrument rigol *IDN? RIGOL TECHNOLOGIES,DS2302A,DS2D155201382,00.03.00 :cal:date?;time? 2018,09,14;21,33,41 :tse:instrument tenma *IDN? TENMA72-2540V2.0 VOUT1? 00.00 :tse:output:mode hex VOUT1? 30302E3030 In this session we interacted with two different instruments (named rigol and tenma). The commands starting with :tse were directly interpreted by the TSE Commander, everything else was sent to the selected instrument. "},{"title":"TSE Data Link","url":"/docs/server/TSE_Data_Link/","body":"Sends telecommands to a configured TSE Commander and reads back output as processed parameters. Class Name org.yamcs.tctm.TseDataLink Configuration Options Name Type Description host string Required. The host of the TSE Commander. port integer Required. The TCP port of the TSE Commander tcStream string Stream where command instructions are received. Default: tc_tse ppStream string Stream where to emit received parameters. Default: pp_tse "},{"title":"Tables","url":"/docs/http/Tables/","body":" "},{"title":"Tags","url":"/docs/http/Tags/","body":" "},{"title":"Telemetry Processing","url":"/docs/server/Telemetry_Processing/","body":" "},{"title":"Tuning","url":"/docs/studio/Tuning/","body":" "},{"title":"UDP Parameter Data Link","url":"/docs/server/UDP_Parameter_Data_Link/","body":"Listens on a UDP port for datagrams containing Protobuf encoded messages. One datagram is equivalent to a message of type org.yamcs.protobuf.Pvalue.ParameterData Class Name org.yamcs.tctm.UdpParameterDataLink Configuration Options Name Type Description stream string Required. The stream where data is emitted port integer Required. The UDP port to listen on "},{"title":"UDP TM Data Link","url":"/docs/server/UDP_TM_Data_Link/","body":"Listens on a UDP port for datagrams containing CCSDS packets. One datagram is equivalent to one packet. Class Name org.yamcs.tctm.UdpTmDataLink Configuration Options Name Type Description stream string Required. The stream where data is emitted port integer Required. The UDP port to listen on maxLength integer The maximum length of the packets received. If a larger datagram is received, the data will be truncated. Default: 1500 bytes packetPreprocessorClassName string Class name of a PacketPreprocessor implementation. Default is org.yamcs.tctm.IssPacketPreprocessor which applies ISS conventions. packetPreprocessorArgs map Optional args of arbitrary complexity to pass to the PacketPreprocessor. Each PacketPreprocessor may support different options. "},{"title":"Understanding the User Interface","url":"/docs/studio/Understanding_the_User_Interface/","body":"Yamcs Studio is composed out of multiple views that are arranged together in windows. The user has great flexibility in modifying the default arrangement. Views Windows Views Views all share the same user interface organization. On the left you see a tab with the view icon, followed by a title, and then a close icon. On the outer right there are actions to Minimize or Maximize the view. Some views (such as the one in the screenshot) also have a third pull-down icon with view-specific actions in it. Most views, though, add dedicated colored icons next to the standard icons. The pull-down menu is used to hide less-often used actions. To reopen a view which you closed earlier, or to open another view choose Window &gt; Show View. Views can be resized, moved and stacked. This allows you to customize your workspace to your own personal preference. For example, let’s say we want to put the Archive view in its own dedicated location. Click on the tab title, and while holding the mouse down, drag towards the right. If you move far enough, you will notice an outline suggesting the view’s new position (this may look slightly different on your platform). Release the mouse to confirm this view’s new position. Let’s say we want to move the Data Links view to the right as well. Again, click its title and drag your mouse next to the Archive tab. You will see a green bar suggesting this tab’s new placement. Release the mouse to confirm this view’s new position. As you try dragging to different locations, you will notice that Yamcs Studio has several hot spots where you can attach your views. For example, you can detach windows by dragging them outside of your application window. This provides additional screen space if your workstation supports multiple monitors. When you close Yamcs Studio and later reopen it, your last view and window arrangement will be restored. Yamcs Studio stores the information about your view arrangement in a .metadata folder inside your workspace. This is how it knows how to restore this information through restarts. If you share your workspace with other users through a version control system, you should consider not committing this .metadata folder. This way everybody can have his own preferred arrangement without colliding with each other. Windows Yamcs Studio uses two special windows that serve a different purpose: Display Builder Display Runner On a new workspace, Yamcs Studio will by default open the Display Builder window. The Display Builder includes a default set of views that allow creating or editing operator displays. In the top toolbar, you can see a play button which allows you to open the Display Runner window. This window includes a different set of windows that put the focus on operations. In this window, displays open in runtime mode. In the top toolbar of the Display Runner there is a pickaxe button which allows you to open or bring to the front the Display Builder window. If at any time you want to reset your window to the defaults, select Window &gt; Reset Window Layout…. "},{"title":"Upload Object","url":"/docs/http/Upload_Object/","body":"Upload an object POST /api/archive/:instance/:bucketName/:objectName POST /api/archive/:instance/:bucketName _global can be used as instance name to upload to a bucket at the global level. If the bucketName is user.username then a bucket will be created automatically if it does not exist. Otherwise the bucket must exist before being used. Simple Upload In case of simple upload, the objectName has to be specified as part of the URL and the Content-Type header has to be set to the type of the object. The body of the request is the object data. Form upload The form based upload can be used to upload an object from an HTML form. In this case the Content-Type of the request is set to multipart/form-data, and the body will contain at least one part which is the object data. This part includes a filename which is used as the object name as well as a Content-Type header. The name attribute for the file part is ignored. Additional parts (which do not specify a filename) will be used as metadata: the name is specified as part of the Content-Disposition and the value is the body of the part. This can be tested using the curl with the -F option. Example POST /api/buckets/_global/my_bucket HTTP/1.1 Host: localhost:8090 User-Agent: curl/7.58.0 Accept: */* Content-Length: 1090 Content-Type: multipart/form-data; boundary=------------------------7109c709802f7ae4 --------------------------7109c709802f7ae4 Content-Disposition: form-data; name=\"file\"; filename=\"object/name\" Content-Type: text/plain [object data] --------------------------7109c709802f7ae4 Content-Disposition: form-data; name=\"name1\" value1 --------------------------7109c709802f7ae4 Content-Disposition: form-data; name=\"name2\" value2 --------------------------7109c709802f7ae4-- This will create an object named “object/name” with two metadata properties: { \"name1\": \"value1\", \"name2\": \"value2\" } "},{"title":"User","url":"/docs/http/User/","body":"Get information on the authenticated user: GET /api/user Response Status: 200 OK { \"login\": \"admin\", \"superuser\": true } Alternative Media Types Protobuf Use HTTP header: Accept: application/protobuf Response is of type: yamcsManagement/yamcsManagement.proto message UserInfo { optional string login = 1; repeated ClientInfo clientInfo = 2; repeated string systemPrivilege = 11; repeated ObjectPrivilegeInfo objectPrivilege = 12; optional bool superuser = 13; } "},{"title":"Views","url":"/docs/studio/Views/","body":" "},{"title":"WebSocket","url":"/docs/http/WebSocket/","body":"Yamcs provides a WebSocket API for data subscriptions. A typical use case would be a display tool subscribing to parameter updates. The WebSocket supports two subprotocols: Textual WebSocket frames encoded in JSON Binary WebSocket frames encoded in Google Protocol Buffers To select one or the other specify this header on your WebSocket upgrade request: Sec-WebSocket-Protocol: protobuf or Sec-WebSocket-Protocol: json When unspecified, the server defaults to JSON. Wrapper WebSocket calls should be directed to a URL of the form: http://localhost:8090/_websocket/:instance Replace :instance with your Yamcs instance name. The frame must contain a text array like so: [x,y,z,{\"&lt;request-type&gt;\":\"&lt;request&gt;\"}] Where: x the version of the protocol (currently fixed at 1) y the message type. One of: 1 Request 2 Reply 3 Exception 4 Data z a sequence counter. Enables clients to couple a response with the original request The request-type and request criteria vary for every type of resource, and are each time indicated in further pages. "},{"title":"Web Interface","url":"/docs/server/Web_Interface/","body":"Yamcs includes a web interface which provides quick access and control over many of its features. The web interface runs on port 8090 and integrates with the security system of Yamcs. The web interface is separated in three different modules: Monitor provides typical monitoring capabilities (displays, events, …) MDB provides an overview of the Mission Database (parameters, containers, …) System provides administrative controls over Yamcs (tables, services, …). All modules are aware of the privileges of the logged in user and will hide user interface elements that the user has no permission for. For normal operations access to the Monitor and MDB section should be sufficient. Most pages (the homepage excluding) show data specific to a particular Yamcs instance. The current instance is always indicated in the top bar. To switch to a different location either return to the homepage, or use the quick-switch dialog in the top bar. When switching instances the user is always redirect to the default page for that instance (i.e. the Display overview). "},{"title":"Widgets","url":"/docs/studio/Widgets/","body":"A display is a container for widgets. Most widgets are backed by a PV. Some widgets (e.g. widgets used for layout) are typically not connected to a PV. Other widgets (e.g. charts) can be backed by more than one PV. Catalogue of Widgets The default widgets in Yamcs Studio are listed below. Their runtime behaviour should be fairly straightforward. The various properties are detailed when we address the Display Builder. Graphics Arc Rectangle Label Polyline Rounded Rectangle Image Polygon Ellipse Monitors LED Progress Bar XY Graph&#185; Image Boolean Indicator Gauge Intensity Graph Text Update Thermometer Byte Monitor Meter Tank ¹ Clear the view on this widget by right-clicking on it and selecting Clear Graph. If you want advanced controls, like zooming, activate the toolbar by right-clicking on your widget and selecting Show/Hide Graph Toolbar. Controls Action Button&#178; Knob Image Boolean Button Menu Button Scrollbar Check Box Text Input Thumb Wheel Radio Box Spinner Boolean Switch Choice Button Scaled Slider Boolean Button Combo ² Action Buttons are often used to open other displays. Whether this opens in a new tab or in the same tab depends on how the display author constructed the display. Override the default by right-clicking the Action Button. Others Table Grouping Container Sash Container Web Browser Linking Container Grid Layout Array Tabbed Container Color Decorations When a widget is backed by a PV, it will be decorated according to its runtime state. The specific colors of these decorations can vary since the default colors can be overridden (or disabled) by the display author. State Decoration Connected No decorations Connected, but no value (yet) Dashed pink border around the widget Disconnected Solid pink border around the widget and the label 'Disconnected' in the top left corner (space-permitting) Expired Blinking solid pink border around the widget Minor Alarm Solid orange border around the widget Major Alarm Solid red border around the widget Note that the color information for alarms is currently not as rich as it could be. Yamcs parameters support five different levels of alarms, as well as a range of special monitoring values. This information has for now been transformed using the following mapping: Yamcs Server Yamcs Studio WATCH MINOR WARNING DISTRESS CRITICAL MAJOR SEVERE "},{"title":"XTCE Loader","url":"/docs/server/XTCE_Loader/","body":"This loader reads an MDB saved in XML format compliant with the XTCE specification. For more information about XTCE, see http://www.xtce.org. The loader is configured in etc/mdb.yaml or in the instance configuration by specifying the ‘type’ as xtce, and providing the location of the XML file in the spec attribute. General Yamcs uses XTCE data structures internally as much as possible, following the XTCE v1.2. Since the version 1.2 of XTCE is not yet (as of June-2018) available, the implementation has been based on various drafts found on the Internet, notably on the xtcetools project (whose author is one of the main contributors to the standard). However not all parts of the standard are supported. This chapter presents an overview of the not supported features and details when the implementation might differ from the standard. All the features that are not mentioned in this chapter should be supported; if you encounter a problem please submit an issue. Note that when reading the XML XTCE file Yamcs is on purpose tolerant, it ignores the tags it does not know and it also strives to be backward compatibible with XTCE 1.0 and 1.1. Thus the fact that an XML file loads in Yamcs does not mean that is 100% valid. Please use a generic XML validation tool or the xtcetools project mentioned above to validate your XML file. The following concepts are not supported at all: Stream - data is assumed to be injected into Yamcs as packets (see Data Links), any stream processing has to be done as part of the data link definition and is not based on XTCE. Message ParameterSegmentRefEntry ContainerSegmentRefEntry BooleanExpression DiscreteLookupList ErrorDetectCorrectType. Note that error detection/correction is implemented directly into the Yamcs data links. ContextSignificanceList ParameterToSetList ParameterToSuspendAlarmsOnSet RestrictionCriteria/NextContainer CommandVerifierType/(Comparison, BooleanExpression,ComparisonList) - soon to be implemented CommandVerifierType/ParameterValueChange - soon to be implemented The other elements are supported one way or another, exceptions or changes from the specs are given in the sections below. Header Only the version and date are supported. AuthorSet and NoteSet are ignored. Data Encodings changeThreshold changeThreshold is not supported. FromBinaryTransformAlgorithm In XTCE the FromBinaryTransformAlgorithm can be specified for the BinaryDataEncoding. It is not clear how exactly that is supposed to work. In Yamcs the FromBinaryTransformAlgorithm can be specified on any XyzDataEncoding and is used to convert from binary to the raw value which is supposed to be of type Xyz. ToBinaryTransformAlgorithm not supported for any data encoding FloatDataEncoding Yamcs supports IEEE754_1985, MILSTD_1750A and STRING encoding. STRING is not part of XTCE - if used, a StringDataEncoding can be attached to the FloatDataEncoding and the string will be extracted according to the StringDataEncoding and then parsed into a float or double according to the sizeInBits of FloatDataEncoding. DEC, IBM and TI encoding are not supported. StringDataEncoding For variable size strings whose size is encoded in front of the string, Yamcs allows to specify only for command arguments sizeInBitsOfSizeTag = 0. This means that the value of the argument will be inserted without providing the information about its size. The receiver has to know how to derive the size. This has been implemented for compatibility with other sysstems (e.g. SCOS-2k) which allows this - however it is not allowed by XTCE which enforces sizeInBitsOfSizeTag &gt; 0. Data Types ValidRange Not supported for any parameter type. BooleanDataType In XTCE, each BooleanDataType has a string representation. In Yamcs the value is mapped to a org.yacms.parameter.BooleanValue or the protobuf equivalnet that is a wrapper for a boolean (either true or false in all sane programming languages). The string value is neverhteless supported in comparisons and mathalgorithms but they are converted internally to the boolean value. If you want to get to the string representation from the client, use an EnumeratedParameterType. RelativeTimeDataType not supported. Monitoring ParameterSetType parameterRef is not supported. According to XTCE doc this is “Used to include a Parameter defined in another sub-system in this sub-system”. It is not clear what it means “to include”. Parameters from other space systems can be referenced using a fully qualified name or a relative name. ParameterProperties PhysicalAddressSet is not supported. SystemName is not supported. TimeAssociation is not supported. Containers BinaryEncoding not supported in the container definitions. StringParameterType Alarms are not supported. Commanding Aggregates and Arrays are not supported for commands (they are for telemetry). ArgumentRefEntry IncludeCondition is not supported RepeatEntry is not supported "},{"title":"XTCE TM Recorder","url":"/docs/server/XTCE_TM_Recorder/","body":"Records XTCE TM sequence containers. This service stores the data coming from one or more streams into a table tm. Class Name org.yamcs.archive.XtceTmRecorder Configuration This service is defined in etc/yamcs.(instance).yaml. Example from a typical deployment: yamcs.simulator.yaml services: - class: org.yamcs.archive.XtceTmRecorder streamConfig: tm: - tm_realtime - tm_dump With this configuration containers coming from both the tm_realtime and tm_dump streams are stored into the table tm. Configuration Options Name Type Description streams list of strings The streams to record. When unspecified, all tm streams defined in streamConfig are recorded. "},{"title":"YAML AuthModule","url":"/docs/server/YAML_AuthModule/","body":"The YAML AuthModule supports authentication and authorization of users via YAML files available directly in the etc/ folder. Class Name org.yamcs.security.YamlAuthModule Configuration Options Name Type Description hasher string Hasher class that can be used to verify if a password is correct without actually storing the password. When omitted, passwords in users.yaml should be defined in clear text. Possible values are: org.yamcs.security.PBKDF2PasswordHasher required boolean When set to true the YAML AuthModule will veto the login process if it does not know the user. This may be of interest in situations where the YAML AuthModule does not authenticate the user, yet still some control is required via configuration files over which users can login. Default is false. The YAML AuthModule reads further configuration from two additional YAML files: users.yaml and roles.yaml. users.yaml This file defines users, passwords and user roles. Note that Yamcs itself does not use roles, it is however used as a convenience in the YAML AuthModule to reduce the verbosity of user-specific privilege assignments. users.yaml admin: password: somepassword superuser: true someuser: password: somepassword roles: [ Operator ] The password key may be omitted if the YAML AuthModule is not used for authentication. If you do use YAML AuthModule for authentication, consider hashing the passwords for better security. Password hashes can be obtained via the command line: yamcs password-hash This command prompts for the password and outputs a randomly salted PBKDF2 hash. This output can be assigned to the password key, replacing the clear password. roles.yaml This file defines which privileges belong to which roles. roles.yaml Operator: ReadParameter: [\".*\"] WriteParameter: [] ReadPacket: [\".*\"] Command: [\".*\"] InsertCommandQueue: [\"ops\"] System: - ControlProcessor - ModifyCommandHistory - ControlCommandQueue - Command - GetMissionDatabase - ControlArchiving This example specifies one role Operator. It also demonstrates the use of regular expressions to grant a set of object privileges. System privileges must be defined under the key System. System privileges may not use regular expressions. All keys are optional so the simplest role definition is simply: roles.yaml EmptyRole: "},{"title":"Yamcs Clients","url":"/docs/studio/Yamcs_Clients/","body":"The Yamcs Clients view is a read-only view that shows you all the clients that are connected to the same Yamcs Server that you are connected to. The displayed information includes: ID The client ID assigned by Yamcs Server. Useful for debugging. User The name of the connected user, or unknown if Yamcs was not secured Application The name of the application that the user is using to connect to Yamcs. Instance The instance this user is connected to Processor The processor this user is connected to "},{"title":"Yamcs Server Updates","url":"/updates/Yamcs_Server/","body":" Yamcs 4.9.0&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Feb 19, 19 added support for CCSDS TM frame protocols (TM, AOS and USLP frames) various improvements in yamcs-web Yamcs 4.8.1&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Jan 28, 19 allow multiple TSE commands in one telecommand various bugfixes Yamcs 4.8.0&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Jan 28, 19 allow to create instances on the fly from templates added a generic packet input stream (for spiting tcp stream into packets) added a generic packet preprocessor that reads timestamps in UNIX millisec format and sequence count from user defined offsets Yamcs 4.7.3&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Nov 26, 18 allow to online (i.e. without modifying the MDB) change calibrations and alarms for parameters part of a running processor various bugfixes Yamcs 4.7.2&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Oct 30, 18 various bug fixes Yamcs 4.7.1&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Oct 12, 18 small bug fixes Yamcs 4.7&nbsp;&nbsp;[.tar.gz]&nbsp;&nbsp;[.rpm] Sep 28, 18 implemented interface to Test Support Equipment (power supplies, osciloscopes, …) several changes in instance state - allow offline instances implemented step by step replay allow same DataLink to be IN and OUT added some options in the simulator to allow performance testing create a new rpm for yamcs-client containing the java swing clients. Most of the functionality is already available in the Yamcs Web so this package will be discontinued in the future. Yamcs 4.6.3&nbsp;&nbsp;[.rpm] Aug 28, 18 limit the number of parameters that can be stored in one segment of the parameter arhchive to avoid OOM errors various small bugfixes Yamcs 4.6.2&nbsp;&nbsp;[.rpm] Jul 25, 18 implemented better cleanup after instance shutdown and restart store CCSDS TM Index also in the tablespace (rahter than in a separate rocksdb database) Yamcs 4.6.1&nbsp;&nbsp;[.rpm] Jul 18, 18 added support for XTCE IndirectParameterRefEntry added EXTERNAL data sources to better support writable parameters not managed by yamcs Yamcs 4.6.0&nbsp;&nbsp;[.rpm] Jul 11, 18 introduced aggregate and array data types (not yet fully working with the parameter archive) introduced a V7 spreadsheet loader that makes a distinction between parameters/arguments and their data types added support for MIL-STD-1750A floating point encoding (32 and 48 bits) added a ECSS/PUS packet preprocessor added a CCSDS Unsegmented Time Code decoder config: Deprecate webConfig in favour of args under HttpServer archive: Add File System-based bucket implementation web: Add file browser for quickly accessing displays in standalone mode web: Add full-screen support for both displays and layouts web: Add parameter table viewer Yamcs 4.5.0&nbsp;&nbsp;[.rpm] Jun 26, 18 added a simple object storage API (buckets) security improvements - it is possible now to stack multiple AuthModules to provide authentication/authorization from diferent sources. added a Kerberos/Spnego authModule Introduced YamcsService as a required interface for global and instance services Show contextual calibrators in web interface Added various CLI commands (for buckets, processors, clients) General clean-up of Yaml configuration files to match closer to the upcoming Server manual added a last value cache that is present all the time. Yamcs 4.4.2&nbsp;&nbsp;[.rpm] May 23, 18 yamcs-web: support multiple series plots TmLink: added the posibility to specify the checksum type in the Columbus pre-processor and added an option to drop corrupted packets. Yamcs 4.4.1&nbsp;&nbsp;[.rpm] May 14, 18 added the possibility to exclude parameter groups from replays yamcs-web: added a view for the archive index yamcs-web: support replays fixed the retrieval of static files when zeroCopy was disabled bugfix: in /api/instances do not reload the XtceDb from disk, instead provide information about the db already loaded bugfix: when an instance fails to init - force it to the FAILED state (rather than NEW), also do not store the instances that failed to init in the instance list Yamcs 4.4.0&nbsp;&nbsp;[.rpm] May 07, 18 added support for context calibrators added support for XTCE MathOperationCalibrator fixed the names in the spreadsheet such that additional columns can be inserted without loosing compatibility. added support for XTCE MathOperation algorithms various XTCE parser fixes Yamcs 4.3.1&nbsp;&nbsp;[.rpm] Apr 25, 18 parameter archive: fixed encoding of boolean segments XTCE parser: fixed parsing container references in command definition yamcs-web: allow to set software parameters and display information about time parameters Yamcs 4.3.0&nbsp;&nbsp;[.rpm] Apr 23, 18 implemented IncludeCondition for container and parameter entries as per XTCE spec server support for access token generation based on password credentials updates to yamcs-web to support authentication and privilege checking (using access tokens) fixed the parameter archive for boolean parameters fixed the processing of XTCE absolute time parameters Yamcs 4.2.2&nbsp;&nbsp;[.rpm] Apr 17, 18 partially fixed the parameter archive for boolean parameters Yamcs 4.2.1&nbsp;&nbsp;[.rpm] Apr 17, 18 send events when an algorithm execution fails read commands from XTCE XML files compatible with CCSDS green book Yamcs 4.2.0&nbsp;&nbsp;[.rpm] Apr 06, 18 various web improvements - alarm detail, plots improvement, event downloads… added parameter ranges API allow to filter stream data on protobuf message properties better enforcements of privileges on table/stream downloads/uploads and other REST calls "},{"title":"Yamcs Server Updates (v3.x.x)","url":"/updates/Yamcs_Server_(v3.x.x)/","body":" Yamcs 3.4.7&nbsp;&nbsp;[.rpm] Oct 25, 18 Fix for issue #277: Event Viewer: sorting makes it open the wrong “event details” Yamcs 3.4.6&nbsp;&nbsp;[.rpm] Oct 01, 18 added a workaround for a bug where the data is not garbage collected after a parameter archive refill happens Yamcs 3.4.5&nbsp;&nbsp;[.rpm] Jul 11, 18 fixed the replay service to always take into account the parameter group exclusion option implemented in 3.4.4 Yamcs 3.4.4&nbsp;&nbsp;[.rpm] May 09, 18 added the possibility to exclude parameter groups from replays Yamcs 3.4.3&nbsp;&nbsp;[.rpm] Mar 28, 18 fixed the replay not starting at the correct time change the serialized XTCEDB filename to limit its length (use SHA-1 of the old name) Yamcs 3.4.2&nbsp;&nbsp;[.rpm] Feb 12, 18 fixed Artemis data links the parameter select dialog from the Archive Browser will show now also parameters that are not part of containers Yamcs 3.4.0&nbsp;&nbsp;[.rpm] Dec 06, 17 moved artemis into a separate source project which yamcs-core does not depend on. Allow to connect to an external Artemis server by specifying artemisUrl: “tcp://…” into yamcs..yaml or yamcs.yaml added the possibility to restart instances and send information about current connected instance/processor via websocket added command history cascading via Artemis TcpTcDataLink: added an option to limit the rate of commands sent make an rpm for yamcs-simulation which can be used together with the yamcs rpm to get a yamcs sistem runing. Yamcs 3.3.1&nbsp;&nbsp;[.rpm] Nov 13, 17 Moved the MulticastTmDataLink out of the yamcs-core (into yamcs-dass) because it’s DaSS specific Added a new UdpTmDataLink to replace the removed multiacst functionality. Contrary to the multicast service, the UDP one receives packets as CCSDS packets without any extra header Yamcs 3.3.0&nbsp;&nbsp;[.rpm] Oct 24, 17 Support index requests with request parameters encoded in the HTTP request body in order to allow a large number of packets to be specified (otherwise, the request would exceed maximum URI size). Allow alias parameter name references in the MDB SpreadSheets (including in the Alarm sheet which didn’t allow any reference at all) Fixed the reading of ranges (inclusive vs exclusive) from XTCE XML files Added two options to websocket parameter subscription: send an update when parameters are expiring (by default false) send the first value from cache if available (by default true) Change the expirationTime (absolute time) to expireMillis (relative time) in the ParameterValue. Implemented parameter expiration in the USS web displays Allow to specify custom decoders to be used in container(packet) processing Added binary data encoding with leading size specified (similar to string) Changed the spreadsheet to make clearer the difference between raw value, encoding (how to decode the raw value from the binary) and engineering value (raw value passed through a calibration function) For standalone parameters (i.e. not extracted from XTCE packets) coming without an engineering value, calibrate (raw-&gt;eng value) them inside the processor rather than before being injected in the stream. This means the parameters are stored in the stream archive also in the initial form (could be raw+eng, only raw or only eng) and they are calibrated (using the current MDB) for each replay Of course ParameterArchive will store them calibrated. Added a command “yamcs confcheck” to check a complete yamcs configuration by loading the services without starting them Yamcs 3.2.2&nbsp;&nbsp;[.rpm] May 17, 17 Fixed tag handling in Yamcs Monitor/Archive Browser Yamcs 3.2.1&nbsp;&nbsp;[.rpm] May 15, 17 Added an option to “yamcs rocksdb compact” to specify the target file size and changed the default size from 64MB to 256MB Java expressions can be used for raw-&gt;engineering value calibration (in addition to polynomial and spline). This allow to use mathematical expressions such as logarithms and trigonometric functions. fixed seek in replays Fix in Yamcs Monitor: remove closed processors from the list RocksDB: set by default the table block cache to 8MB (previously it was disabled) Yamcs 3.2.0&nbsp;&nbsp;[.rpm] Apr 18, 17 Improved the yamcs command line with several new sub-commands (xtcedb, parchive) Removed Artemis based replays and management (control processors) Added a new yatch(table/stream) data type PARAMETER_VALUE to replace PROTOBUF(ParameterValue) for more flexibility Yamcs 3.1.1&nbsp;&nbsp;[.rpm] Mar 14, 17 fixed a bug in the RestClient causing the Swing client tools (Yamcs Monitor &amp;co) to NPE when doing File -&gt; Connect to Yamcs (connection by specifying the http url in the command line still worked) Yamcs 3.1.0&nbsp;&nbsp;[.rpm] Mar 14, 17 Changelog MDB: allow parameters without raw types if they are not part of a container REST Api: add option to get the details of parameters in ‘list parameter’ Ease extension of the FilePollingTmDatalink and TmFileReader. if processor -&gt; cacheall is disabled, retrieve at least all parameters that have alarms associated allow algorithm manager to be usable in replays Improved XTCE XML parsing support: - read alarms - read string parameters - read multiple space systems Removed the name from the DataEncoding classes (in XTCE DataEncodings are not named) allow to remove a parameter from the XtceDB (to be used in a controlled way only) Changed the order of starting the services: All global services are created All instance services are created All global services are started All instance services are started Used to be 1,3,(2,4)+ - and this makes for example the HttpServer to be started before the instances are created and some methods (like subscribe event,time,etc) will fail at first because the processor is not available. updated to RocksDB 5.1.2 Yamcs 3.0.0&nbsp;&nbsp;[.rpm] Jan 12, 17 This is the first non-zero (0.x.y) release of Yamcs after almost 10 years of development and 4 years after making it open-source. We call it 3.0 instead of 1.0 because internally at Space Applications we have already defined Yamcs 1 and 2 for the versions used in actual Control Centres. Changelog there is no difference between version 3.0 and 0.30.0 except the version number. "},{"title":"Yamcs Studio Updates","url":"/updates/Yamcs_Studio/","body":" Yamcs Studio 1.2.1&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Jan 09, 19 Fix importPackage-related leak Make importPackage calls optional in user scripts Fix event log not clearing Yamcs Studio 1.2.0&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Oct 01, 18 New The looks of the Event Log can be changed using custom rules An OPI file can be marked as the active ‘schema’. Properties of this schema’s widgets become defaults while editing other displays. Named OPI fonts/colors are now stored to user preferences. The initial list of named colors is less opinionated. Liberation Sans is the new default font. Yamcs Studio no longer auto-creates an example project. Instead examples can be manually added to your workspace via File &gt; New &gt; Example... Replay options have been extended to support range limiting, step-by-step replay and arbitrary speed factors. Application logs are now automatically persisted to ~/.config/yamcs-studio/logs (rotated) Column changes in Command History and Event Log are saved to user preferences. When opening Yamcs Studio, the last used workspace is reopened. The Links view now indicates IN and OUT data counters in different columns, as introduced in Yamcs v4.7. Bug fixes Fix importPackage support in Action scripts Yamcs Studio 1.1.0&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Jul 20, 18 New Parameter with datasource EXTERNAL1-3 support writes Boolean widgets of type Enum compare string value of On/Off State property to determine state Bug fixes Fix issue with wrong workspace selection Fixes automatic opening of Displays to always open in Display Runner window Loads parameters over multiple requests for large MDBs "},{"title":"Yamcs Studio Updates (v1.0.x)","url":"/updates/Yamcs_Studio_(v1.0.x)/","body":" v1.0.x releases should only be used to run against legacy versions of Yamcs Server (v3.x.x). Yamcs Studio 1.0.5&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Jan 09, 19 Fix importPackage support in Action scripts Fix importPackage-related leak Make importPackage calls optional in user scripts Yamcs Studio 1.0.4&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Jul 20, 18 New Add transitional support for deprecated sw:// PVs Bug fixes Fix issue with wrong workspace selection Fix -workspace flag Fixes connectivity with Yamcs v3 (uses yamcs-client v3.4.5) Fixes automatic opening of Displays to always open in Display Runner window Yamcs Studio 1.0.3&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Jun 26, 18 New Add support for Yamcs timestamp datatype #54 Add static entries in Window menu for directly opening Display Builder or Display Runner Use qualified names in command tree Use nashorn instead of rhino for JavaScript execution (under review) Improved consistency in the formatting of timestamps Bug fixes Fixes an issue with writing to Yamcs local parameters Print error causes directly in studio log (no stacktrace) Fix issue where a runner window could end up being duplicated Fix issue with assigning argument of parent command containers By default, hide default command arguments Yamcs Studio 1.0.2&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Apr 04, 18 Restores script access to org.csstudio.swt.* Fixes an issue where dropdown boxes did not keep their selection on Windows and OSX Yamcs Studio 1.0.1&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Mar 28, 18 Improve compatibility with older Yamcs instances Allow running with Java 9 or 10 (in addition to Java 8) Yamcs Studio 1.0.0&nbsp;&nbsp;[Windows x64]&nbsp;&nbsp;[Linux x64]&nbsp;&nbsp;[macOS] Mar 26, 18 Compatible with both Yamcs v3.4.x and v4.x By default, Yamcs Studio wil now open in Editor mode (on a new or reset workspace) The perspective switcher in the top-right toolbar was removed. Instead the Editor and the Runtime operate in distinct windows. Switching between the two types of windows can be done via a new button in the main toolbar. The ‘Navigator’ tree view was replaced with an identical looking ‘Explorer’ view. This Explorer view has better default open actions. In a Runtime window, double clicking will open an OPI file in runtime mode. In an Editor window, double clicking will open an OPI file in editor mode. Plot series max count was increased from 20 to 30. An issue was fixed where plots with formulas would not show data when replaying past data. The right-click “Show PV Info” popup was updated to show raw parameter values The right-click “Show PV Info” popup will now update its content as new parameter values are incoming (note that for non-parameter PVs the data will not currently update). The Probe popup (also available via the right-click menu of any PV widget) was refactored and now uses the MDB static alarm ranges (where applicable) to show a more meaningful meter. Yamcs Studio will now attempt auto-reconnection when connection to Yamcs is lost. Logging was refactored. Only INFO or worse are visible directly inside Yamcs Studio via the Console view. Debug logging (including stacktraces) are available via stdout/err. PV autocomplete suggestions will now also include yamcs-‘local’ parameters, such as system parameters. The event log uses different icons to be compatible with a recent change in Yamcs. The 3 old levels INFO, WARNING and ERROR are replaced by the new levels INFO, WATCH, WARNING, DISTRESS, CRITICAL and SEVERE. The ERROR state is matched to SEVERE. "},{"title":"About Yamcs","url":"/about/","body":"Yamcs is being used on a day-to-day basis by several entities for realtime operations, and specifically during International Space Station missions. Its main stakeholders are: Space Applications Services N.V./S.A. – an independent Belgian space technology company whose aim is to develop innovative systems, solutions and products for the aerospace markets as well as related industries. Space Applications Services plays an active role in the development of Yamcs. B.USOC – the Belgian User Support and Operation Centre from ESA. B.USOC’s role is to be the interface between the science teams and the space operational world. B.USOC operators are responsible for implementing and running European payloads on the ISS. In this context they use Yamcs, for the control and monitoring of various missions, such as SOLAR and PCDF. Commercial Interest If you are interested in Yamcs and would consider using Yamcs in your project or mission, please contact Space Applications using the details available at https://www.spaceapplications.com/contact. &nbsp; &nbsp; "},{"title":"content","url":"/docs/server/pdf/content/","body":" "},{"title":"content","url":"/docs/studio/pdf/content/","body":" "},{"title":"Get Involved","url":"/get-involved/","body":"Discuss If you would like to join the discussion, please visit the public forum at https://groups.google.com/forum/#!forum/yamcs &nbsp; Contribute We have open-sourced a significant chunk of two of our products: Yamcs Server and Yamcs Studio. If you feel like contributing to any of these, you are welcome to do so. We use GitHub for all of our open-source developments (code, issues, pull-requests). Yamcs Server The GitHub repository is at https://github.com/yamcs/yamcs. for small patches, just a pull request is enough. for bigger contributions, we kindly ask you to sign the Yamcs Contributor Agreement. Yamcs Studio The GitHub repository is at https://github.com/yamcs/yamcs-studio. &nbsp; Commercial If you are interested in Yamcs and would consider using Yamcs in your project or mission, please contact Space Applications using the details available at https://www.spaceapplications.com/contact. "},{"title":"index","url":"/","body":"In mission control centers, a major part of the ground segment is the front-end and back-end software which is used to assist payload and system operators in their daily tasks. Yamcs (short for Yet another mission control system) is a software package that positions itself as a lightweight alternative to traditional heavyweight Mission Control Systems. Yamcs is a cost-efficient suite of tools for spacecraft, payload and ground segment operations preparation, execution and spacecraft AIT. For development purposes, all the software can run on a developer’s computer or laptop. For more information on the Yamcs suite of tools, head over to the Yamcs Docs. Sponsored by Space Applications Services Space Applications Services develops and operates control centres for spacecraft, Unmanned Aerial Vehicles, Unmanned Ground Vehicles as well as Unmanned Sea Vehicles. The control centres are used for Earth observation, human spaceflight, Urban Search and Rescue, Maritime Search and Rescue, as well as operating ROVs on off-shore rigs. If you are interested in Yamcs and would consider using Yamcs in your project or mission, please contact Space Applications using the details available at https://www.spaceapplications.com/contact. Featured Customers Belgian User Operations and Support Centre (B.USOC) Centre d’aide au développement des activités en micro-pesanteur et des opérations spatiales (CADMOS) Dutch User Operations and Support Centre (Erasmus) European Robotic Arm (ERA) Support Centre Atomic Clock Ensemble in Space (ACES) Ground Segment &nbsp; "},{"title":"pagefooter","url":"/docs/server/pdf/pagefooter/","body":" "},{"title":"pagefooter","url":"/docs/studio/pdf/pagefooter/","body":" "},{"title":"titlefooter","url":"/docs/server/pdf/titlefooter/","body":""},{"title":"titlefooter","url":"/docs/studio/pdf/titlefooter/","body":""},{"title":"Yamcs Server Manual","url":"/docs/server/pdf/titleinner/","body":""},{"title":"Yamcs Studio User Guide","url":"/docs/studio/pdf/titleinner/","body":""},{"title":"Yamcs Server Manual","url":"/docs/server/pdf/titlepage/","body":""},{"title":"Yamcs Studio User Guide","url":"/docs/studio/pdf/titlepage/","body":""},{"title":"yamcs-server init script","url":"/docs/server/yamcs-server_init_script/","body":"Yamcs distributions include an init script for starting and stopping Yamcs Server in System V-style. This script is located at /etc/init.d/yamcs-server and should not be run directly but instead via your system's service manager. This will perform proper stepdown to the yamcs user. For example: systemd start|stop|restart|status yamcs-server Or alternatively: service yamcs-server start|stop|restart|status The init script accepts these commands: start Starts Yamcs Server and stores the PID of the yamcsd process to /var/run/yamcs-server.pid stop Stops the Yamcs Server process based on the PID found in /var/run/yamcs-server.pid restart Stops Yamcs Server if it is running, then starts it again. status Checks if Yamcs Server is currently running. This does a PID check and will not detect a Yamcs Server runtime that has been started on the system without use of this init script. "},{"title":"yamcs algorithms","url":"/docs/cli/yamcs_algorithms/","body":"NAME yamcs algorithms &ndash; Read algorithms SYNOPSIS yamcs algorithms COMMAND COMMANDS list List algorithms describe Describe an algorithm "},{"title":"yamcs algorithms describe","url":"/docs/cli/yamcs_algorithms_describe/","body":"NAME yamcs algorithms describe &ndash; Describe an algorithm SYNOPSIS yamcs algorithms describe ALGORITHM POSITIONAL ARGUMENTS ALGORITHM The algorithm to describe. "},{"title":"yamcs algorithms list","url":"/docs/cli/yamcs_algorithms_list/","body":"NAME yamcs algorithms list &ndash; List algorithms SYNOPSIS yamcs algorithms list "},{"title":"yamcs clients","url":"/docs/cli/yamcs_clients/","body":"NAME yamcs clients &ndash; Read client info SYNOPSIS yamcs clients COMMAND COMMANDS list List clients "},{"title":"yamcs clients list","url":"/docs/cli/yamcs_clients_list/","body":"NAME yamcs clients list &ndash; List clients SYNOPSIS yamcs clients list "},{"title":"yamcs commands","url":"/docs/cli/yamcs_commands/","body":"NAME yamcs commands &ndash; Read commands SYNOPSIS yamcs commands COMMAND COMMANDS list List commands describe Describe a command "},{"title":"yamcs commands describe","url":"/docs/cli/yamcs_commands_describe/","body":"NAME yamcs commands describe &ndash; Describe a command SYNOPSIS yamcs commands describe COMMAND POSITIONAL ARGUMENTS COMMAND The command to describe. "},{"title":"yamcs commands list","url":"/docs/cli/yamcs_commands_list/","body":"NAME yamcs commands list &ndash; List commands SYNOPSIS yamcs commands list "},{"title":"yamcs config","url":"/docs/cli/yamcs_config/","body":"NAME yamcs config &ndash; Manage Yamcs client properties SYNOPSIS yamcs config COMMAND COMMANDS get Get value of client property list List client properties set Set client property unset Unset client property "},{"title":"yamcs config get","url":"/docs/cli/yamcs_config_get/","body":"NAME yamcs config get &ndash; Get value of client property SYNOPSIS yamcs config get PROPERTY POSITIONAL ARGUMENTS PROPERTY The property to retrieve. "},{"title":"yamcs config list","url":"/docs/cli/yamcs_config_list/","body":"NAME yamcs config list &ndash; List client properties SYNOPSIS yamcs config list "},{"title":"yamcs config set","url":"/docs/cli/yamcs_config_set/","body":"NAME yamcs config set &ndash; Set client property SYNOPSIS yamcs config set PROPERTY VALUE POSITIONAL ARGUMENTS PROPERTY The property to set. VALUE The new value of the property. "},{"title":"yamcs config unset","url":"/docs/cli/yamcs_config_unset/","body":"NAME yamcs config unset &ndash; Unset client property SYNOPSIS yamcs config unset PROPERTY POSITIONAL ARGUMENTS PROPERTY The property to unset. "},{"title":"yamcs containers","url":"/docs/cli/yamcs_containers/","body":"NAME yamcs containers &ndash; Read containers SYNOPSIS yamcs containers COMMAND COMMANDS list List containers describe Describe a container "},{"title":"yamcs containers describe","url":"/docs/cli/yamcs_containers_describe/","body":"NAME yamcs containers describe &ndash; Describe a container SYNOPSIS yamcs containers describe CONTAINER POSITIONAL ARGUMENTS CONTAINER The container to describe. "},{"title":"yamcs containers list","url":"/docs/cli/yamcs_containers_list/","body":"NAME yamcs containers list &ndash; List containers SYNOPSIS yamcs containers list "},{"title":"yamcs dbshell","url":"/docs/cli/yamcs_dbshell/","body":"NAME yamcs dbshell &ndash; Launch Yarch DB Shell SYNOPSIS yamcs dbshell [-c COMMAND, --command COMMAND] OPTIONS -c COMMAND, --command COMMAND Run a single SQL command string. "},{"title":"yamcs instances","url":"/docs/cli/yamcs_instances/","body":"NAME yamcs instances &ndash; Read Yamcs instances SYNOPSIS yamcs instances COMMAND COMMANDS list List instances start Start an instance stop Stop an instance "},{"title":"yamcs instances list","url":"/docs/cli/yamcs_instances_list/","body":"NAME yamcs instances list &ndash; List instances SYNOPSIS yamcs instances list "},{"title":"yamcs instances start","url":"/docs/cli/yamcs_instances_start/","body":"NAME yamcs instances start &ndash; Start an instance SYNOPSIS yamcs instances start INSTANCE ... POSITIONAL ARGUMENTS INSTANCE ... The instances to start. "},{"title":"yamcs instances stop","url":"/docs/cli/yamcs_instances_stop/","body":"NAME yamcs instances stop &ndash; Stop an instance SYNOPSIS yamcs instances stop INSTANCE ... POSITIONAL ARGUMENTS INSTANCE ... The instances to stop. "},{"title":"yamcs links","url":"/docs/cli/yamcs_links/","body":"NAME yamcs links &ndash; Read and manipulate data links SYNOPSIS yamcs links COMMAND COMMANDS list List links enable Enable a link disable Disable a link describe Describe a link "},{"title":"yamcs links describe","url":"/docs/cli/yamcs_links_describe/","body":"NAME yamcs links describe &ndash; Describe a data link SYNOPSIS yamcs links describe LINK POSITIONAL ARGUMENTS LINK The link to describe. "},{"title":"yamcs links disable","url":"/docs/cli/yamcs_links_disable/","body":"NAME yamcs links disable &ndash; Disable a data link SYNOPSIS yamcs links disable LINK ... POSITIONAL ARGUMENTS LINK ... The links to disable. "},{"title":"yamcs links enable","url":"/docs/cli/yamcs_links_enable/","body":"NAME yamcs links enable &ndash; Enable a data link SYNOPSIS yamcs links enable LINK ... POSITIONAL ARGUMENTS LINK ... The links to enable. "},{"title":"yamcs links list","url":"/docs/cli/yamcs_links_list/","body":"NAME yamcs links list &ndash; List links SYNOPSIS yamcs links list "},{"title":"yamcs login","url":"/docs/cli/yamcs_login/","body":"NAME yamcs login &ndash; Login to a Yamcs server SYNOPSIS yamcs login [HOST[:PORT]] POSITIONAL ARGUMENTS [HOST[:PORT]] The server address. Example: localhost:8090 "},{"title":"yamcs logout","url":"/docs/cli/yamcs_logout/","body":"NAME yamcs logout &ndash; Logout of a Yamcs server SYNOPSIS yamcs logout "},{"title":"yamcs parameters","url":"/docs/cli/yamcs_parameters/","body":"NAME yamcs parameters &ndash; Read parameters SYNOPSIS yamcs parameters COMMAND COMMANDS list List parameters describe Describe a parameter "},{"title":"yamcs parameters describe","url":"/docs/cli/yamcs_parameters_describe/","body":"NAME yamcs parameters describe &ndash; Describe a parameter SYNOPSIS yamcs parameters describe PARAMETER POSITIONAL ARGUMENTS PARAMETER The parameter to describe. "},{"title":"yamcs parameters list","url":"/docs/cli/yamcs_parameters_list/","body":"NAME yamcs parameters list &ndash; List parameters SYNOPSIS yamcs parameters list "},{"title":"yamcs processors","url":"/docs/cli/yamcs_processors/","body":"NAME yamcs processors &ndash; Read processors SYNOPSIS yamcs processors COMMAND COMMANDS list List processors "},{"title":"yamcs processors list","url":"/docs/cli/yamcs_processors_list/","body":"NAME yamcs processors list &ndash; List processors SYNOPSIS yamcs processors list "},{"title":"yamcs services","url":"/docs/cli/yamcs_services/","body":"NAME yamcs services &ndash; Read and manipulate services SYNOPSIS yamcs services COMMAND COMMANDS list List services start Start a service stop Stop a service "},{"title":"yamcs services list","url":"/docs/cli/yamcs_services_list/","body":"NAME yamcs services list &ndash; List services SYNOPSIS yamcs services list "},{"title":"yamcs services start","url":"/docs/cli/yamcs_services_start/","body":"NAME yamcs services start &ndash; Start a service SYNOPSIS yamcs services start SERVICE ... POSITIONAL ARGUMENTS SERVICE ... Services to start. "},{"title":"yamcs services stop","url":"/docs/cli/yamcs_services_stop/","body":"NAME yamcs services stop &ndash; Stop a service SYNOPSIS yamcs services stop SERVICE ... POSITIONAL ARGUMENTS SERVICE ... Services to stop. "},{"title":"yamcs space-systems","url":"/docs/cli/yamcs_space-systems/","body":"NAME yamcs space-systems &ndash; Read space systems SYNOPSIS yamcs space-systems COMMAND COMMANDS list List space systems describe Describe a space system "},{"title":"yamcs space-systems describe","url":"/docs/cli/yamcs_space-systems_describe/","body":"NAME yamcs space-systems describe &ndash; Describe a space system SYNOPSIS yamcs space-systems describe SPACESYSTEM POSITIONAL ARGUMENTS SPACESYSTEM The space system to describe. "},{"title":"yamcs space-systems list","url":"/docs/cli/yamcs_space-systems_list/","body":"NAME yamcs space-systems list &ndash; List space systems SYNOPSIS yamcs space-systems list "},{"title":"yamcs storage","url":"/docs/cli/yamcs_storage/","body":"NAME yamcs storage &ndash; Manage object storage SYNOPSIS yamcs storage COMMAND COMMANDS ls List buckets or objects Synonym: list mb Make buckets rb Remove buckets cat Concatenate object content to stdout cp Copy a file or object mv Move a file or object "},{"title":"yamcs storage cat","url":"/docs/cli/yamcs_storage_cat/","body":"NAME yamcs storage cat &ndash; Concatenate object content to stdout SYNOPSIS yamcs storage cat OBJECT ... POSITIONAL ARGUMENTS OBJECT ... The objects to fetch. "},{"title":"yamcs storage cp","url":"/docs/cli/yamcs_storage_cp/","body":"NAME yamcs storage cp &ndash; Copy a file or object SYNOPSIS yamcs storage cp SRC DST POSITIONAL ARGUMENTS SRC local file or an object in the format BUCKET://OBJECT. DST local file or an object in the format BUCKET://OBJECT. "},{"title":"yamcs storage ls","url":"/docs/cli/yamcs_storage_ls/","body":"NAME yamcs storage ls &ndash; List buckets or objects SYNOPSIS yamcs storage ls [-l] [-r, -R] [BUCKET] POSITIONAL ARGUMENTS [BUCKET] Bucket or object. OPTIONS -l List in long format. -r, -R List recursively. "},{"title":"yamcs storage mb","url":"/docs/cli/yamcs_storage_mb/","body":"NAME yamcs storage mb &ndash; Make buckets SYNOPSIS yamcs storage mb BUCKET ... POSITIONAL ARGUMENTS BUCKET ... A bucket to create. "},{"title":"yamcs storage mv","url":"/docs/cli/yamcs_storage_mv/","body":"NAME yamcs storage mv &ndash; Move a file or object SYNOPSIS yamcs storage mv SRC DST POSITIONAL ARGUMENTS SRC local file or an object in the format BUCKET://OBJECT. DST local file, local directory or an object in the format BUCKET://OBJECT. "},{"title":"yamcs storage rb","url":"/docs/cli/yamcs_storage_rb/","body":"NAME yamcs storage rb &ndash; Remove buckets SYNOPSIS yamcs storage rb BUCKET ... POSITIONAL ARGUMENTS BUCKET ... A bucket to remove. "},{"title":"yamcs storage rm","url":"/docs/cli/yamcs_storage_rm/","body":"NAME yamcs storage rm &ndash; Remove objects SYNOPSIS yamcs storage rm OBJECT ... POSITIONAL ARGUMENTS OBJECT ... An object to remove. "},{"title":"yamcs streams","url":"/docs/cli/yamcs_streams/","body":"NAME yamcs streams &ndash; Read and manipulate streams SYNOPSIS yamcs streams COMMAND COMMANDS list List streams describe Describe a stream subscribe Subscribe to a stream "},{"title":"yamcs streams describe","url":"/docs/cli/yamcs_streams_describe/","body":"NAME yamcs streams describe &ndash; Describe a stream SYNOPSIS yamcs streams describe STREAM POSITIONAL ARGUMENTS STREAM The stream to describe. "},{"title":"yamcs streams list","url":"/docs/cli/yamcs_streams_list/","body":"NAME yamcs streams list &ndash; List streams SYNOPSIS yamcs streams list "},{"title":"yamcs streams subscribe","url":"/docs/cli/yamcs_streams_subscribe/","body":"NAME yamcs streams subscribe &ndash; Subscribe to a stream SYNOPSIS yamcs streams subscribe STREAM POSITIONAL ARGUMENTS STREAM The stream to describe. "},{"title":"yamcs tables","url":"/docs/cli/yamcs_tables/","body":"NAME yamcs tables &ndash; Read and manipulate tables SYNOPSIS yamcs tables COMMAND COMMANDS list List tables describe Describe a table dump Dump table data load Load data into a table "},{"title":"yamcs tables describe","url":"/docs/cli/yamcs_tables_describe/","body":"NAME yamcs tables describe &ndash; Describe a table SYNOPSIS yamcs tables describe TABLE POSITIONAL ARGUMENTS TABLE The table to describe. "},{"title":"yamcs tables dump","url":"/docs/cli/yamcs_tables_dump/","body":"NAME yamcs tables dump &ndash; Dump table data SYNOPSIS yamcs tables dump [-d DIR, --dir DIR] TABLE ... OPTIONS -d DIR, --dir DIR Specifies the directory where to output dump files. Defaults to current directory. POSITIONAL ARGUMENTS TABLE ... The tables to dump. "},{"title":"yamcs tables list","url":"/docs/cli/yamcs_tables_list/","body":"NAME yamcs tables list &ndash; List tables SYNOPSIS yamcs tables list "},{"title":"yamcs tables load","url":"/docs/cli/yamcs_tables_load/","body":"NAME yamcs tables load &ndash; Load data into a table. SYNOPSIS yamcs tables load [-d DIR, --dir DIR] TABLE ... OPTIONS -d DIR, --dir DIR Specifies the directory where to locate dump files. Defaults to current directory. POSITIONAL ARGUMENTS TABLE ... The tables to load. "},{"title":"yamcsadmin","url":"/docs/server/yamcsadmin/","body":"NAME yamcsadmin &ndash; Tool for local Yamcs administration SYNOPSIS yamcsadmin [--etc-dir DIR] COMMAND OPTIONS --etc-dir DIR Override default Yamcs configuration directory -h, --help Show usage -v, --version Print version information and quit COMMANDS backup Perform and restore backups confcheck Check the configuration files of Yamcs parchive Parameter Archive operations password-hash Generate password hash for use in users.yaml rocksdb Provides low-level RocksDB data operations xtcedb Provides information about the XTCE database "},{"title":"yamcsadmin backup","url":"/docs/server/yamcsadmin_backup/","body":"NAME yamcsadmin backup &ndash; Perform and restore backups SYNOPSIS yamcsadmin backup COMMAND COMMANDS create Create a new backup delete Delete a backup list List the existing backups restore Restore a backup. &nbsp; ### yamcsadmin backup create NAME yamcsadmin backup create &ndash; Create a new backup SYNOPSIS yamcsadmin backup create [--dbDir DIR] [--backupDir DIR] OPTIONS --dbDir DIR Database directory. --backupDir DIR Backup Directory. &nbsp; ### yamcsamdin backup delete NAME yamcsadmin backup delete &ndash; Delete a backup SYNOPSIS yamcsadmin backup delete [--backupDir DIR] [--backupId ID] OPTIONS --backupDir DIR Backup Directory. --backupId ID Backup ID. &nbsp; ### yamcsadmin backup list NAME yamcsadmin backup list &ndash; List the existing backups SYNOPSIS yamcsadmin backup list [--backupDir DIR] OPTIONS --backupDir DIR Backup Directory. &nbsp; ### yamcsadmin backup restore NAME yamcsadmin backup restore &ndash; Restore a backup SYNOPSIS yamcsadmin backup restore [--backupDir DIR] [--backupId ID] [--restoreDir DIR] DECRIPTION Note that backups can only be restored when Yamcs is not running. OPTIONS --backupDir DIR Backup Directory. --backupId ID Backup ID. If not specified, defaults to the last backup --restoreDir DIR Directory where to restore the backup "},{"title":"yamcsadmin confcheck","url":"/docs/server/yamcsadmin_confcheck/","body":"NAME yamcsadmin confcheck &ndash; Check the configuration files of Yamcs SYNOPSIS yamcsadmin confcheck [--no-etc] [DIR] POSITIONAL ARGUMENTS [DIR] Use this directory in preference for loading configuration files. If --no-etc is specified, all configuration files will be loaded from this directory. Note that the data directory (yamcs.yaml dataDir) will be changed before starting the services, otherwise there will be RocksDB LOCK errors if a yamcs server is running. OPTIONS --no-etc Do not use any file from the default Yamcs etc directory. If this is specified, the argument config-dir becomes mandatory. "},{"title":"yamcsadmin parchive","url":"/docs/server/yamcsadmin_parchive/","body":"NAME yamcsadmin parchive &ndash; Parameter Archive operations SYNOPSIS yamcsadmin parchive --instance INSTANCE COMMAND OPTIONS --instance INSTANCE Yamcs instance. COMMANDS print-pid Print parameter name to parameter id mapping print-pgid Print parameter group compositions &nbsp; ### yamcsadmin parchive print-pid NAME yamcsadmin parchive print-pid &ndash; Print parameter name to parameter id mapping SYNOPSIS yamcsadmin parchive print-pid &nbsp; ### yamcsadmin parchive print-pgid NAME yamcsadmin parchive print-pgid &ndash; Print parameter group compositions SYNOPSIS yamcsadmin parchive print-pgid "},{"title":"yamcsadmin password-hash","url":"/docs/server/yamcsadmin_password-hash/","body":"NAME yamcsadmin password-hash &ndash; Generate password hash for use in users.yaml SYNOPSIS yamcsadmin password-hash DESCRIPTION Promps to enter and confirm a password, and generates a randomly salted PBKDF2 hash of this password. This hash may be used in users.yaml instead of the actual password, and allows verifying user passwords without storing them. "},{"title":"yamcsadmin rocksdb","url":"/docs/server/yamcsadmin_rocksdb/","body":"NAME yamcsadmin rocksdb &ndash; Provides low-level RocksDB data operations SYNOPSIS yamcsadmin rocksdb COMMAND COMMANDS compact Compact rocksdb database bench Benchmark rocksdb storage engine &nbsp; ### yamcsadmin rocksdb compact NAME yamcsadmin rocksdb compact &ndash; Compact rocksdb database SYNOPSIS yamcsadmin rocksdb compact [--dbDir DIR] [--sizeMB SIZE] OPTIONS --dbDir DIR Database directory. --sizeMB SIZE Target size of each SST file in MB (default is 256 MB). &nbsp; ### yamcsadmin rocksdb bench NAME yamcsadmin rocksdb bench &ndash; Benchmark rocksdb storage engine SYNOPSIS yamcsadmin rocksdb bench [--dbDir DIR] [--baseTime TIME] [--count COUNT] &nbsp;&nbsp;&nbsp;&nbsp;[--duration HOURS] OPTIONS --dbDir DIR Directory where the database will be created. A \"rocksbench\" archive instance wll be created in this directory --baseTime TIME Start inserting data with this time. Default: 2017-01-01T00:00:00 --count COUNT The partition counts for the 5 frequencies: [10/sec, 1/sec, 1/10sec, 1/60sec and 1/hour]. It has to be specified as a string (use quotes). --duration HOURS The duration in hours of the simulated data. Default: 24 DESCRIPTION The benchmark consists of a table load and a few selects. The table is loaded with telemetry packets received at frequencies of [10/sec, 1/sec, 1/10sec, 1/60sec and 1/hour]. The table will be identical to the tm table and will contain a histogram on pname (=packet name). It is possible to specify how many partitions (i.e. how many different pnames) to be loaded for each frequency and the time duration of the data. "},{"title":"yamcsadmin xtcedb","url":"/docs/server/yamcsadmin_xtcedb/","body":"NAME yamcsadmin xtcedb &ndash; Provides information about the XTCE database SYNOPSIS yamcsadmin xtcedb [-f FILE] COMMAND OPTIONS -f FILE Use this file instead of default mdb.yaml COMMANDS listConfigs List the MDB configurations defined in mdb.yaml print Print the contents of the XTCE DB verify Verify that the XTCE DB can be loaded &nbsp; ### yamcsadmin xtcedb listConfigs NAME yamcsadmin xtcedb listConfigs &ndash; List the MDB configurations defined in mdb.yaml SYNOPSIS yamcsadmin xtcedb listConfigs &nbsp; ### yamcsadmin xtcedb print NAME yamcsadmin xtcedb print &ndash; Print the contents of the XTCE DB SYNOPSIS yamcsadmin xtcedb print CONFIG POSITIONAL ARGUMENTS CONFIG Config name. &nbsp; ### yamcsadmin xtcedb verify NAME yamcsadmin xtcedb verify &ndash; Verify that the XTCE DB can be loaded SYNOPSIS yamcsadmin xtcedb verify CONFIG POSITIONAL ARGUMENTS CONFIG Config name. "},{"title":"yamcsd","url":"/docs/server/yamcsd/","body":"NAME yamcsd &ndash; Yamcs Server SYNOPSIS yamcsd DESCRIPTION yamcsd is the main program in a Yamcs installation, and is generally referred to as Yamcs Server. When Yamcs Server starts, it activates data links and starts listening for network connections from client programs. "}]
